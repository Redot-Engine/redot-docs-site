<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Line2D.xml. -->

<a id="Line2D"></a>

# Line2D

**Inherits:** [Node2D](Node2D.md) **\<** [CanvasItem](CanvasItem.md) **\<** [Node](Node.md) **\<** [Object](Object.md)

A 2D polyline that can optionally be textured.

<!-- classref-introduction-group -->

## Description

This node draws a 2D polyline, i.e. a shape consisting of several points connected by segments. **Line2D** is not a mathematical polyline, i.e. the segments are not infinitely thin. It is intended for rendering and it can be colored and optionally textured.

\ **Warning:** Certain configurations may be impossible to draw nicely, such as very sharp angles. In these situations, the node uses fallback drawing logic to look decent.

\ **Note:** **Line2D** is drawn using a 2D mesh.

<!-- classref-introduction-group -->

## Tutorials

- [Matrix Transform Demo](https://godotengine.org/asset-library/asset/2787)

- [2.5D Game Demo](https://godotengine.org/asset-library/asset/2783)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[antialiased](#Line2D_property_antialiased)</th>
      <th>`false`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[LineCapMode](Line2D.md#enum_Line2D_LineCapMode)</td>
      <td>[begin_cap_mode](#Line2D_property_begin_cap_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[closed](#Line2D_property_closed)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[default_color](#Line2D_property_default_color)</td>
      <td>`Color(1, 1, 1, 1)`</td>
    </tr>
    <tr>
      <td>[LineCapMode](Line2D.md#enum_Line2D_LineCapMode)</td>
      <td>[end_cap_mode](#Line2D_property_end_cap_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[Gradient](Gradient.md)</td>
      <td>[gradient](#Line2D_property_gradient)</td>
      <td></td>
    </tr>
    <tr>
      <td>[LineJointMode](Line2D.md#enum_Line2D_LineJointMode)</td>
      <td>[joint_mode](#Line2D_property_joint_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[PackedVector2Array](PackedVector2Array.md)</td>
      <td>[points](#Line2D_property_points)</td>
      <td>`PackedVector2Array()`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[round_precision](#Line2D_property_round_precision)</td>
      <td>`8`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[sharp_limit](#Line2D_property_sharp_limit)</td>
      <td>`2.0`</td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[texture](#Line2D_property_texture)</td>
      <td></td>
    </tr>
    <tr>
      <td>[LineTextureMode](Line2D.md#enum_Line2D_LineTextureMode)</td>
      <td>[texture_mode](#Line2D_property_texture_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[width](#Line2D_property_width)</td>
      <td>`10.0`</td>
    </tr>
    <tr>
      <td>[Curve](Curve.md)</td>
      <td>[width_curve](#Line2D_property_width_curve)</td>
      <td></td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>`void`</th>
      <th>[add_point](#Line2D_method_add_point)\ (\ position\: [Vector2](Vector2.md), index\: [int](int.md) = -1\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`void`</td>
      <td>[clear_points](#Line2D_method_clear_points)\ (\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_point_count](#Line2D_method_get_point_count)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[get_point_position](#Line2D_method_get_point_position)\ (\ index\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[remove_point](#Line2D_method_remove_point)\ (\ index\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_point_position](#Line2D_method_set_point_position)\ (\ index\: [int](int.md), position\: [Vector2](Vector2.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_Line2D_LineJointMode"></a>

<!-- classref-enumeration -->

enum **LineJointMode**: [ðŸ”—](#enum_Line2D_LineJointMode)

<a id="Line2D_constant_LINE_JOINT_SHARP"></a>

<!-- classref-enumeration-constant -->

[LineJointMode](Line2D.md#enum_Line2D_LineJointMode) **LINE_JOINT_SHARP** = `0`

Makes the polyline's joints pointy, connecting the sides of the two segments by extending them until they intersect. If the rotation of a joint is too big (based on [sharp_limit](Line2D.md#Line2D_property_sharp_limit)), the joint falls back to [LINE_JOINT_BEVEL](Line2D.md#Line2D_constant_LINE_JOINT_BEVEL) to prevent very long miters.<a id="Line2D_constant_LINE_JOINT_BEVEL"></a>

<!-- classref-enumeration-constant -->

[LineJointMode](Line2D.md#enum_Line2D_LineJointMode) **LINE_JOINT_BEVEL** = `1`

Makes the polyline's joints bevelled/chamfered, connecting the sides of the two segments with a simple line.<a id="Line2D_constant_LINE_JOINT_ROUND"></a>

<!-- classref-enumeration-constant -->

[LineJointMode](Line2D.md#enum_Line2D_LineJointMode) **LINE_JOINT_ROUND** = `2`

Makes the polyline's joints rounded, connecting the sides of the two segments with an arc. The detail of this arc depends on [round_precision](Line2D.md#Line2D_property_round_precision).<hr class="classref-item-separator"/>

<a id="enum_Line2D_LineCapMode"></a>

<!-- classref-enumeration -->

enum **LineCapMode**: [ðŸ”—](#enum_Line2D_LineCapMode)

<a id="Line2D_constant_LINE_CAP_NONE"></a>

<!-- classref-enumeration-constant -->

[LineCapMode](Line2D.md#enum_Line2D_LineCapMode) **LINE_CAP_NONE** = `0`

Draws no line cap.<a id="Line2D_constant_LINE_CAP_BOX"></a>

<!-- classref-enumeration-constant -->

[LineCapMode](Line2D.md#enum_Line2D_LineCapMode) **LINE_CAP_BOX** = `1`

Draws the line cap as a box, slightly extending the first/last segment.<a id="Line2D_constant_LINE_CAP_ROUND"></a>

<!-- classref-enumeration-constant -->

[LineCapMode](Line2D.md#enum_Line2D_LineCapMode) **LINE_CAP_ROUND** = `2`

Draws the line cap as a semicircle attached to the first/last segment.<hr class="classref-item-separator"/>

<a id="enum_Line2D_LineTextureMode"></a>

<!-- classref-enumeration -->

enum **LineTextureMode**: [ðŸ”—](#enum_Line2D_LineTextureMode)

<a id="Line2D_constant_LINE_TEXTURE_NONE"></a>

<!-- classref-enumeration-constant -->

[LineTextureMode](Line2D.md#enum_Line2D_LineTextureMode) **LINE_TEXTURE_NONE** = `0`

Takes the left pixels of the texture and renders them over the whole polyline.<a id="Line2D_constant_LINE_TEXTURE_TILE"></a>

<!-- classref-enumeration-constant -->

[LineTextureMode](Line2D.md#enum_Line2D_LineTextureMode) **LINE_TEXTURE_TILE** = `1`

Tiles the texture over the polyline. [CanvasItem.texture_repeat](CanvasItem.md#CanvasItem_property_texture_repeat) of the **Line2D** node must be [CanvasItem.TEXTURE_REPEAT_ENABLED](CanvasItem.md#CanvasItem_constant_TEXTURE_REPEAT_ENABLED) or [CanvasItem.TEXTURE_REPEAT_MIRROR](CanvasItem.md#CanvasItem_constant_TEXTURE_REPEAT_MIRROR) for it to work properly.<a id="Line2D_constant_LINE_TEXTURE_STRETCH"></a>

<!-- classref-enumeration-constant -->

[LineTextureMode](Line2D.md#enum_Line2D_LineTextureMode) **LINE_TEXTURE_STRETCH** = `2`

Stretches the texture across the polyline. [CanvasItem.texture_repeat](CanvasItem.md#CanvasItem_property_texture_repeat) of the **Line2D** node must be [CanvasItem.TEXTURE_REPEAT_DISABLED](CanvasItem.md#CanvasItem_constant_TEXTURE_REPEAT_DISABLED) for best results.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="Line2D_property_antialiased"></a>

<!-- classref-property -->

[bool](bool.md) **antialiased** = `false` [ðŸ”—](#Line2D_property_antialiased)

<!-- classref-property-setget -->

- `void` **set_antialiased**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_antialiased**\ (\ )

If ``true``, the polyline's border will be anti-aliased.

\ **Note:** **Line2D** is not accelerated by batching when being anti-aliased.

<hr class="classref-item-separator"/>

<a id="Line2D_property_begin_cap_mode"></a>

<!-- classref-property -->

[LineCapMode](Line2D.md#enum_Line2D_LineCapMode) **begin_cap_mode** = `0` [ðŸ”—](#Line2D_property_begin_cap_mode)

<!-- classref-property-setget -->

- `void` **set_begin_cap_mode**\ (\ value\: [LineCapMode](Line2D.md#enum_Line2D_LineCapMode)\ )
- [LineCapMode](Line2D.md#enum_Line2D_LineCapMode) **get_begin_cap_mode**\ (\ )

The style of the beginning of the polyline, if [closed](Line2D.md#Line2D_property_closed) is ``false``.

<hr class="classref-item-separator"/>

<a id="Line2D_property_closed"></a>

<!-- classref-property -->

[bool](bool.md) **closed** = `false` [ðŸ”—](#Line2D_property_closed)

<!-- classref-property-setget -->

- `void` **set_closed**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_closed**\ (\ )

If ``true`` and the polyline has more than 2 points, the last point and the first one will be connected by a segment.

\ **Note:** The shape of the closing segment is not guaranteed to be seamless if a [width_curve](Line2D.md#Line2D_property_width_curve) is provided.

\ **Note:** The joint between the closing segment and the first segment is drawn first and it samples the [gradient](Line2D.md#Line2D_property_gradient) and the [width_curve](Line2D.md#Line2D_property_width_curve) at the beginning. This is an implementation detail that might change in a future version.

<hr class="classref-item-separator"/>

<a id="Line2D_property_default_color"></a>

<!-- classref-property -->

[Color](Color.md) **default_color** = `Color(1, 1, 1, 1)` [ðŸ”—](#Line2D_property_default_color)

<!-- classref-property-setget -->

- `void` **set_default_color**\ (\ value\: [Color](Color.md)\ )
- [Color](Color.md) **get_default_color**\ (\ )

The color of the polyline. Will not be used if a gradient is set.

<hr class="classref-item-separator"/>

<a id="Line2D_property_end_cap_mode"></a>

<!-- classref-property -->

[LineCapMode](Line2D.md#enum_Line2D_LineCapMode) **end_cap_mode** = `0` [ðŸ”—](#Line2D_property_end_cap_mode)

<!-- classref-property-setget -->

- `void` **set_end_cap_mode**\ (\ value\: [LineCapMode](Line2D.md#enum_Line2D_LineCapMode)\ )
- [LineCapMode](Line2D.md#enum_Line2D_LineCapMode) **get_end_cap_mode**\ (\ )

The style of the end of the polyline, if [closed](Line2D.md#Line2D_property_closed) is ``false``.

<hr class="classref-item-separator"/>

<a id="Line2D_property_gradient"></a>

<!-- classref-property -->

[Gradient](Gradient.md) **gradient** [ðŸ”—](#Line2D_property_gradient)

<!-- classref-property-setget -->

- `void` **set_gradient**\ (\ value\: [Gradient](Gradient.md)\ )
- [Gradient](Gradient.md) **get_gradient**\ (\ )

The gradient is drawn through the whole line from start to finish. The [default_color](Line2D.md#Line2D_property_default_color) will not be used if this property is set.

<hr class="classref-item-separator"/>

<a id="Line2D_property_joint_mode"></a>

<!-- classref-property -->

[LineJointMode](Line2D.md#enum_Line2D_LineJointMode) **joint_mode** = `0` [ðŸ”—](#Line2D_property_joint_mode)

<!-- classref-property-setget -->

- `void` **set_joint_mode**\ (\ value\: [LineJointMode](Line2D.md#enum_Line2D_LineJointMode)\ )
- [LineJointMode](Line2D.md#enum_Line2D_LineJointMode) **get_joint_mode**\ (\ )

The style of the connections between segments of the polyline.

<hr class="classref-item-separator"/>

<a id="Line2D_property_points"></a>

<!-- classref-property -->

[PackedVector2Array](PackedVector2Array.md) **points** = `PackedVector2Array()` [ðŸ”—](#Line2D_property_points)

<!-- classref-property-setget -->

- `void` **set_points**\ (\ value\: [PackedVector2Array](PackedVector2Array.md)\ )
- [PackedVector2Array](PackedVector2Array.md) **get_points**\ (\ )

The points of the polyline, interpreted in local 2D coordinates. Segments are drawn between the adjacent points in this array.

**Note:** The returned array is *copied* and any changes to it will not update the original property value. See [PackedVector2Array](PackedVector2Array.md) for more details.

<hr class="classref-item-separator"/>

<a id="Line2D_property_round_precision"></a>

<!-- classref-property -->

[int](int.md) **round_precision** = `8` [ðŸ”—](#Line2D_property_round_precision)

<!-- classref-property-setget -->

- `void` **set_round_precision**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_round_precision**\ (\ )

The smoothness used for rounded joints and caps. Higher values result in smoother corners, but are more demanding to render and update.

<hr class="classref-item-separator"/>

<a id="Line2D_property_sharp_limit"></a>

<!-- classref-property -->

[float](float.md) **sharp_limit** = `2.0` [ðŸ”—](#Line2D_property_sharp_limit)

<!-- classref-property-setget -->

- `void` **set_sharp_limit**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_sharp_limit**\ (\ )

Determines the miter limit of the polyline. Normally, when [joint_mode](Line2D.md#Line2D_property_joint_mode) is set to [LINE_JOINT_SHARP](Line2D.md#Line2D_constant_LINE_JOINT_SHARP), sharp angles fall back to using the logic of [LINE_JOINT_BEVEL](Line2D.md#Line2D_constant_LINE_JOINT_BEVEL) joints to prevent very long miters. Higher values of this property mean that the fallback to a bevel joint will happen at sharper angles.

<hr class="classref-item-separator"/>

<a id="Line2D_property_texture"></a>

<!-- classref-property -->

[Texture2D](Texture2D.md) **texture** [ðŸ”—](#Line2D_property_texture)

<!-- classref-property-setget -->

- `void` **set_texture**\ (\ value\: [Texture2D](Texture2D.md)\ )
- [Texture2D](Texture2D.md) **get_texture**\ (\ )

The texture used for the polyline. Uses [texture_mode](Line2D.md#Line2D_property_texture_mode) for drawing style.

<hr class="classref-item-separator"/>

<a id="Line2D_property_texture_mode"></a>

<!-- classref-property -->

[LineTextureMode](Line2D.md#enum_Line2D_LineTextureMode) **texture_mode** = `0` [ðŸ”—](#Line2D_property_texture_mode)

<!-- classref-property-setget -->

- `void` **set_texture_mode**\ (\ value\: [LineTextureMode](Line2D.md#enum_Line2D_LineTextureMode)\ )
- [LineTextureMode](Line2D.md#enum_Line2D_LineTextureMode) **get_texture_mode**\ (\ )

The style to render the [texture](Line2D.md#Line2D_property_texture) of the polyline.

<hr class="classref-item-separator"/>

<a id="Line2D_property_width"></a>

<!-- classref-property -->

[float](float.md) **width** = `10.0` [ðŸ”—](#Line2D_property_width)

<!-- classref-property-setget -->

- `void` **set_width**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_width**\ (\ )

The polyline's width.

<hr class="classref-item-separator"/>

<a id="Line2D_property_width_curve"></a>

<!-- classref-property -->

[Curve](Curve.md) **width_curve** [ðŸ”—](#Line2D_property_width_curve)

<!-- classref-property-setget -->

- `void` **set_curve**\ (\ value\: [Curve](Curve.md)\ )
- [Curve](Curve.md) **get_curve**\ (\ )

The polyline's width curve. The width of the polyline over its length will be equivalent to the value of the width curve over its domain. The width curve should be a unit [Curve](Curve.md).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Line2D_method_add_point"></a>

<!-- classref-method -->

`void` **add_point**\ (\ position\: [Vector2](Vector2.md), index\: [int](int.md) = -1\ ) [ðŸ”—](#Line2D_method_add_point)

Adds a point with the specified `position` relative to the polyline's own position. If no `index` is provided, the new point will be added to the end of the points array.

If `index` is given, the new point is inserted before the existing point identified by index `index`. The indices of the points after the new point get increased by 1. The provided `index` must not exceed the number of existing points in the polyline. See [get_point_count()](Line2D.md#Line2D_method_get_point_count).

<hr class="classref-item-separator"/>

<a id="Line2D_method_clear_points"></a>

<!-- classref-method -->

`void` **clear_points**\ (\ ) [ðŸ”—](#Line2D_method_clear_points)

Removes all points from the polyline, making it empty.

<hr class="classref-item-separator"/>

<a id="Line2D_method_get_point_count"></a>

<!-- classref-method -->

[int](int.md) **get_point_count**\ (\ ) <span class="const">const</span> [ðŸ”—](#Line2D_method_get_point_count)

Returns the number of points in the polyline.

<hr class="classref-item-separator"/>

<a id="Line2D_method_get_point_position"></a>

<!-- classref-method -->

[Vector2](Vector2.md) **get_point_position**\ (\ index\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#Line2D_method_get_point_position)

Returns the position of the point at index `index`.

<hr class="classref-item-separator"/>

<a id="Line2D_method_remove_point"></a>

<!-- classref-method -->

`void` **remove_point**\ (\ index\: [int](int.md)\ ) [ðŸ”—](#Line2D_method_remove_point)

Removes the point at index `index` from the polyline.

<hr class="classref-item-separator"/>

<a id="Line2D_method_set_point_position"></a>

<!-- classref-method -->

`void` **set_point_position**\ (\ index\: [int](int.md), position\: [Vector2](Vector2.md)\ ) [ðŸ”—](#Line2D_method_set_point_position)

Overwrites the position of the point at the given `index` with the supplied `position`.

