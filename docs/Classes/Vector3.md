<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Vector3.xml. -->

<a id="Vector3"></a>

# Vector3

A 3D vector using floating-point coordinates.

<!-- classref-introduction-group -->

## Description

A 3-element structure that can be used to represent 3D coordinates or any other triplet of numeric values.

It uses floating-point coordinates. By default, these floating-point values use 32-bit precision, unlike [float](float.md) which is always 64-bit. If double precision is needed, compile the engine with the option ``precision=double``.

See [Vector3i](Vector3i.md) for its integer counterpart.

\ **Note:** In a boolean context, a Vector3 will evaluate to ``false`` if it's equal to ``Vector3(0, 0, 0)``. Otherwise, a Vector3 will always evaluate to ``true``.

<!-- classref-introduction-group -->

## Tutorials

- [Math documentation index](../tutorials/math/index.md)

- [Vector math](../tutorials/math/vector_math.md)

- [Advanced vector math](../tutorials/math/vectors_advanced.md)

- [3Blue1Brown Essence of Linear Algebra](https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab)

- [Matrix Transform Demo](https://godotengine.org/asset-library/asset/2787)

- [All 3D Demos](https://github.com/redot-engine/redot-demo-projects/tree/master/3d)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[float](float.md)</th>
      <th>[x](#Vector3_property_x)</th>
      <th>`0.0`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[float](float.md)</td>
      <td>[y](#Vector3_property_y)</td>
      <td>`0.0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[z](#Vector3_property_z)</td>
      <td>`0.0`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Constructors

<table>
  <thead>
    <tr>
      <th>[Vector3](Vector3.md)</th>
      <th>[Vector3](#Vector3_constructor_Vector3)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[Vector3](#Vector3_constructor_Vector3)\ (\ from\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[Vector3](#Vector3_constructor_Vector3)\ (\ from\: [Vector3i](Vector3i.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[Vector3](#Vector3_constructor_Vector3)\ (\ x\: [float](float.md), y\: [float](float.md), z\: [float](float.md)\ )</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Vector3](Vector3.md)</th>
      <th>[abs](#Vector3_method_abs)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[float](float.md)</td>
      <td>[angle_to](#Vector3_method_angle_to)\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[bezier_derivative](#Vector3_method_bezier_derivative)\ (\ control_1\: [Vector3](Vector3.md), control_2\: [Vector3](Vector3.md), end\: [Vector3](Vector3.md), t\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[bezier_interpolate](#Vector3_method_bezier_interpolate)\ (\ control_1\: [Vector3](Vector3.md), control_2\: [Vector3](Vector3.md), end\: [Vector3](Vector3.md), t\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[bounce](#Vector3_method_bounce)\ (\ n\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[ceil](#Vector3_method_ceil)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[clamp](#Vector3_method_clamp)\ (\ min\: [Vector3](Vector3.md), max\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[clampf](#Vector3_method_clampf)\ (\ min\: [float](float.md), max\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[cross](#Vector3_method_cross)\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[cubic_interpolate](#Vector3_method_cubic_interpolate)\ (\ b\: [Vector3](Vector3.md), pre_a\: [Vector3](Vector3.md), post_b\: [Vector3](Vector3.md), weight\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[cubic_interpolate_in_time](#Vector3_method_cubic_interpolate_in_time)\ (\ b\: [Vector3](Vector3.md), pre_a\: [Vector3](Vector3.md), post_b\: [Vector3](Vector3.md), weight\: [float](float.md), b_t\: [float](float.md), pre_a_t\: [float](float.md), post_b_t\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[direction_to](#Vector3_method_direction_to)\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[distance_squared_to](#Vector3_method_distance_squared_to)\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[distance_to](#Vector3_method_distance_to)\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[dot](#Vector3_method_dot)\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[floor](#Vector3_method_floor)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[inverse](#Vector3_method_inverse)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_equal_approx](#Vector3_method_is_equal_approx)\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_finite](#Vector3_method_is_finite)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_normalized](#Vector3_method_is_normalized)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_zero_approx](#Vector3_method_is_zero_approx)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[length](#Vector3_method_length)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[length_squared](#Vector3_method_length_squared)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[lerp](#Vector3_method_lerp)\ (\ to\: [Vector3](Vector3.md), weight\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[limit_length](#Vector3_method_limit_length)\ (\ length\: [float](float.md) = 1.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[max](#Vector3_method_max)\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[max_axis_index](#Vector3_method_max_axis_index)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[maxf](#Vector3_method_maxf)\ (\ with\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[min](#Vector3_method_min)\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[min_axis_index](#Vector3_method_min_axis_index)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[minf](#Vector3_method_minf)\ (\ with\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[move_toward](#Vector3_method_move_toward)\ (\ to\: [Vector3](Vector3.md), delta\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[normalized](#Vector3_method_normalized)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[octahedron_decode](#Vector3_method_octahedron_decode)\ (\ uv\: [Vector2](Vector2.md)\ ) <span class="static">static</span></td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[octahedron_encode](#Vector3_method_octahedron_encode)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Basis](Basis.md)</td>
      <td>[outer](#Vector3_method_outer)\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[posmod](#Vector3_method_posmod)\ (\ mod\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[posmodv](#Vector3_method_posmodv)\ (\ modv\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[project](#Vector3_method_project)\ (\ b\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[reflect](#Vector3_method_reflect)\ (\ n\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[rotated](#Vector3_method_rotated)\ (\ axis\: [Vector3](Vector3.md), angle\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[round](#Vector3_method_round)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[sign](#Vector3_method_sign)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[signed_angle_to](#Vector3_method_signed_angle_to)\ (\ to\: [Vector3](Vector3.md), axis\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[slerp](#Vector3_method_slerp)\ (\ to\: [Vector3](Vector3.md), weight\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[slide](#Vector3_method_slide)\ (\ n\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[snapped](#Vector3_method_snapped)\ (\ step\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[snappedf](#Vector3_method_snappedf)\ (\ step\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Operators

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[operator !=](#Vector3_operator_neq_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator *](#Vector3_operator_mul_Basis)\ (\ right\: [Basis](Basis.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator *](#Vector3_operator_mul_Quaternion)\ (\ right\: [Quaternion](Quaternion.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator *](#Vector3_operator_mul_Transform3D)\ (\ right\: [Transform3D](Transform3D.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator *](#Vector3_operator_mul_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator *](#Vector3_operator_mul_float)\ (\ right\: [float](float.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator *](#Vector3_operator_mul_int)\ (\ right\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator +](#Vector3_operator_sum_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator -](#Vector3_operator_dif_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator /](#Vector3_operator_div_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator /](#Vector3_operator_div_float)\ (\ right\: [float](float.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator /](#Vector3_operator_div_int)\ (\ right\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator \<](#Vector3_operator_lt_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator \<=](#Vector3_operator_lte_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator ==](#Vector3_operator_eq_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator >](#Vector3_operator_gt_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator >=](#Vector3_operator_gte_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[operator []](#Vector3_operator_idx_int)\ (\ index\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator unary+](#Vector3_operator_unplus)\ (\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator unary-](#Vector3_operator_unminus)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_Vector3_Axis"></a>

<!-- classref-enumeration -->

enum **Axis**: [ðŸ”—](#enum_Vector3_Axis)

<a id="Vector3_constant_AXIS_X"></a>

<!-- classref-enumeration-constant -->

[Axis](Vector3.md#enum_Vector3_Axis) **AXIS_X** = `0`

Enumerated value for the X axis. Returned by [max_axis_index()](Vector3.md#Vector3_method_max_axis_index) and [min_axis_index()](Vector3.md#Vector3_method_min_axis_index).<a id="Vector3_constant_AXIS_Y"></a>

<!-- classref-enumeration-constant -->

[Axis](Vector3.md#enum_Vector3_Axis) **AXIS_Y** = `1`

Enumerated value for the Y axis. Returned by [max_axis_index()](Vector3.md#Vector3_method_max_axis_index) and [min_axis_index()](Vector3.md#Vector3_method_min_axis_index).<a id="Vector3_constant_AXIS_Z"></a>

<!-- classref-enumeration-constant -->

[Axis](Vector3.md#enum_Vector3_Axis) **AXIS_Z** = `2`

Enumerated value for the Z axis. Returned by [max_axis_index()](Vector3.md#Vector3_method_max_axis_index) and [min_axis_index()](Vector3.md#Vector3_method_min_axis_index).<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Constants

<a id="Vector3_constant_ZERO"></a>

<!-- classref-constant -->

**ZERO** = `Vector3(0, 0, 0)` [ðŸ”—](#Vector3_constant_ZERO)

Zero vector, a vector with all components set to ``0``.

<a id="Vector3_constant_ONE"></a>

<!-- classref-constant -->

**ONE** = `Vector3(1, 1, 1)` [ðŸ”—](#Vector3_constant_ONE)

One vector, a vector with all components set to ``1``.

<a id="Vector3_constant_INF"></a>

<!-- classref-constant -->

**INF** = `Vector3(inf, inf, inf)` [ðŸ”—](#Vector3_constant_INF)

Infinity vector, a vector with all components set to [@GDScript.INF](@GDScript.md#@GDScript_constant_INF).

<a id="Vector3_constant_LEFT"></a>

<!-- classref-constant -->

**LEFT** = `Vector3(-1, 0, 0)` [ðŸ”—](#Vector3_constant_LEFT)

Left unit vector. Represents the local direction of left, and the global direction of west.

<a id="Vector3_constant_RIGHT"></a>

<!-- classref-constant -->

**RIGHT** = `Vector3(1, 0, 0)` [ðŸ”—](#Vector3_constant_RIGHT)

Right unit vector. Represents the local direction of right, and the global direction of east.

<a id="Vector3_constant_UP"></a>

<!-- classref-constant -->

**UP** = `Vector3(0, 1, 0)` [ðŸ”—](#Vector3_constant_UP)

Up unit vector.

<a id="Vector3_constant_DOWN"></a>

<!-- classref-constant -->

**DOWN** = `Vector3(0, -1, 0)` [ðŸ”—](#Vector3_constant_DOWN)

Down unit vector.

<a id="Vector3_constant_FORWARD"></a>

<!-- classref-constant -->

**FORWARD** = `Vector3(0, 0, -1)` [ðŸ”—](#Vector3_constant_FORWARD)

Forward unit vector. Represents the local direction of forward, and the global direction of north. Keep in mind that the forward direction for lights, cameras, etc is different from 3D assets like characters, which face towards the camera by convention. Use [MODEL_FRONT](Vector3.md#Vector3_constant_MODEL_FRONT) and similar constants when working in 3D asset space.

<a id="Vector3_constant_BACK"></a>

<!-- classref-constant -->

**BACK** = `Vector3(0, 0, 1)` [ðŸ”—](#Vector3_constant_BACK)

Back unit vector. Represents the local direction of back, and the global direction of south.

<a id="Vector3_constant_MODEL_LEFT"></a>

<!-- classref-constant -->

**MODEL_LEFT** = `Vector3(1, 0, 0)` [ðŸ”—](#Vector3_constant_MODEL_LEFT)

Unit vector pointing towards the left side of imported 3D assets.

<a id="Vector3_constant_MODEL_RIGHT"></a>

<!-- classref-constant -->

**MODEL_RIGHT** = `Vector3(-1, 0, 0)` [ðŸ”—](#Vector3_constant_MODEL_RIGHT)

Unit vector pointing towards the right side of imported 3D assets.

<a id="Vector3_constant_MODEL_TOP"></a>

<!-- classref-constant -->

**MODEL_TOP** = `Vector3(0, 1, 0)` [ðŸ”—](#Vector3_constant_MODEL_TOP)

Unit vector pointing towards the top side (up) of imported 3D assets.

<a id="Vector3_constant_MODEL_BOTTOM"></a>

<!-- classref-constant -->

**MODEL_BOTTOM** = `Vector3(0, -1, 0)` [ðŸ”—](#Vector3_constant_MODEL_BOTTOM)

Unit vector pointing towards the bottom side (down) of imported 3D assets.

<a id="Vector3_constant_MODEL_FRONT"></a>

<!-- classref-constant -->

**MODEL_FRONT** = `Vector3(0, 0, 1)` [ðŸ”—](#Vector3_constant_MODEL_FRONT)

Unit vector pointing towards the front side (facing forward) of imported 3D assets.

<a id="Vector3_constant_MODEL_REAR"></a>

<!-- classref-constant -->

**MODEL_REAR** = `Vector3(0, 0, -1)` [ðŸ”—](#Vector3_constant_MODEL_REAR)

Unit vector pointing towards the rear side (back) of imported 3D assets.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="Vector3_property_x"></a>

<!-- classref-property -->

[float](float.md) **x** = `0.0` [ðŸ”—](#Vector3_property_x)

The vector's X component. Also accessible by using the index position ``[0]``.

<hr class="classref-item-separator"/>

<a id="Vector3_property_y"></a>

<!-- classref-property -->

[float](float.md) **y** = `0.0` [ðŸ”—](#Vector3_property_y)

The vector's Y component. Also accessible by using the index position ``[1]``.

<hr class="classref-item-separator"/>

<a id="Vector3_property_z"></a>

<!-- classref-property -->

[float](float.md) **z** = `0.0` [ðŸ”—](#Vector3_property_z)

The vector's Z component. Also accessible by using the index position ``[2]``.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Constructor Descriptions

<a id="Vector3_constructor_Vector3"></a>

<!-- classref-constructor -->

[Vector3](Vector3.md) **Vector3**\ (\ ) [ðŸ”—](#Vector3_constructor_Vector3)

Constructs a default-initialized **Vector3** with all components set to ``0``.

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Vector3](Vector3.md) **Vector3**\ (\ from\: [Vector3](Vector3.md)\ )

Constructs a **Vector3** as a copy of the given **Vector3**.

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Vector3](Vector3.md) **Vector3**\ (\ from\: [Vector3i](Vector3i.md)\ )

Constructs a new **Vector3** from [Vector3i](Vector3i.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Vector3](Vector3.md) **Vector3**\ (\ x\: [float](float.md), y\: [float](float.md), z\: [float](float.md)\ )

Returns a **Vector3** with the given components.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Vector3_method_abs"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **abs**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_abs)

Returns a new vector with all components in absolute values (i.e. positive).

<hr class="classref-item-separator"/>

<a id="Vector3_method_angle_to"></a>

<!-- classref-method -->

[float](float.md) **angle_to**\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_angle_to)

Returns the unsigned minimum angle to the given vector, in radians.

<hr class="classref-item-separator"/>

<a id="Vector3_method_bezier_derivative"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **bezier_derivative**\ (\ control_1\: [Vector3](Vector3.md), control_2\: [Vector3](Vector3.md), end\: [Vector3](Vector3.md), t\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_bezier_derivative)

Returns the derivative at the given `t` on the [BÃ©zier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) defined by this vector and the given `control_1`, `control_2`, and `end` points.

<hr class="classref-item-separator"/>

<a id="Vector3_method_bezier_interpolate"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **bezier_interpolate**\ (\ control_1\: [Vector3](Vector3.md), control_2\: [Vector3](Vector3.md), end\: [Vector3](Vector3.md), t\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_bezier_interpolate)

Returns the point at the given `t` on the [BÃ©zier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) defined by this vector and the given `control_1`, `control_2`, and `end` points.

<hr class="classref-item-separator"/>

<a id="Vector3_method_bounce"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **bounce**\ (\ n\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_bounce)

Returns the vector "bounced off" from a plane defined by the given normal `n`.

\ **Note:** [bounce()](Vector3.md#Vector3_method_bounce) performs the operation that most engines and frameworks call ``reflect()``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_ceil"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **ceil**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_ceil)

Returns a new vector with all components rounded up (towards positive infinity).

<hr class="classref-item-separator"/>

<a id="Vector3_method_clamp"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **clamp**\ (\ min\: [Vector3](Vector3.md), max\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_clamp)

Returns a new vector with all components clamped between the components of `min` and `max`, by running [@GlobalScope.clamp()](@GlobalScope.md#@GlobalScope_method_clamp) on each component.

<hr class="classref-item-separator"/>

<a id="Vector3_method_clampf"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **clampf**\ (\ min\: [float](float.md), max\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_clampf)

Returns a new vector with all components clamped between `min` and `max`, by running [@GlobalScope.clamp()](@GlobalScope.md#@GlobalScope_method_clamp) on each component.

<hr class="classref-item-separator"/>

<a id="Vector3_method_cross"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **cross**\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_cross)

Returns the cross product of this vector and `with`.

This returns a vector perpendicular to both this and `with`, which would be the normal vector of the plane defined by the two vectors. As there are two such vectors, in opposite directions, this method returns the vector defined by a right-handed coordinate system. If the two vectors are parallel this returns an empty vector, making it useful for testing if two vectors are parallel.

<hr class="classref-item-separator"/>

<a id="Vector3_method_cubic_interpolate"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **cubic_interpolate**\ (\ b\: [Vector3](Vector3.md), pre_a\: [Vector3](Vector3.md), post_b\: [Vector3](Vector3.md), weight\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_cubic_interpolate)

Performs a cubic interpolation between this vector and `b` using `pre_a` and `post_b` as handles, and returns the result at position `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.

<hr class="classref-item-separator"/>

<a id="Vector3_method_cubic_interpolate_in_time"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **cubic_interpolate_in_time**\ (\ b\: [Vector3](Vector3.md), pre_a\: [Vector3](Vector3.md), post_b\: [Vector3](Vector3.md), weight\: [float](float.md), b_t\: [float](float.md), pre_a_t\: [float](float.md), post_b_t\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_cubic_interpolate_in_time)

Performs a cubic interpolation between this vector and `b` using `pre_a` and `post_b` as handles, and returns the result at position `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.

It can perform smoother interpolation than [cubic_interpolate()](Vector3.md#Vector3_method_cubic_interpolate) by the time values.

<hr class="classref-item-separator"/>

<a id="Vector3_method_direction_to"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **direction_to**\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_direction_to)

Returns the normalized vector pointing from this vector to `to`. This is equivalent to using ``(b - a).normalized()``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_distance_squared_to"></a>

<!-- classref-method -->

[float](float.md) **distance_squared_to**\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_distance_squared_to)

Returns the squared distance between this vector and `to`.

This method runs faster than [distance_to()](Vector3.md#Vector3_method_distance_to), so prefer it if you need to compare vectors or need the squared distance for some formula.

<hr class="classref-item-separator"/>

<a id="Vector3_method_distance_to"></a>

<!-- classref-method -->

[float](float.md) **distance_to**\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_distance_to)

Returns the distance between this vector and `to`.

<hr class="classref-item-separator"/>

<a id="Vector3_method_dot"></a>

<!-- classref-method -->

[float](float.md) **dot**\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_dot)

Returns the dot product of this vector and `with`. This can be used to compare the angle between two vectors. For example, this can be used to determine whether an enemy is facing the player.

The dot product will be ``0`` for a right angle (90 degrees), greater than 0 for angles narrower than 90 degrees and lower than 0 for angles wider than 90 degrees.

When using unit (normalized) vectors, the result will always be between ``-1.0`` (180 degree angle) when the vectors are facing opposite directions, and ``1.0`` (0 degree angle) when the vectors are aligned.

\ **Note:** ``a.dot(b)`` is equivalent to ``b.dot(a)``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_floor"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **floor**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_floor)

Returns a new vector with all components rounded down (towards negative infinity).

<hr class="classref-item-separator"/>

<a id="Vector3_method_inverse"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **inverse**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_inverse)

Returns the inverse of the vector. This is the same as ``Vector3(1.0 / v.x, 1.0 / v.y, 1.0 / v.z)``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_is_equal_approx"></a>

<!-- classref-method -->

[bool](bool.md) **is_equal_approx**\ (\ to\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_is_equal_approx)

Returns ``true`` if this vector and `to` are approximately equal, by running [@GlobalScope.is_equal_approx()](@GlobalScope.md#@GlobalScope_method_is_equal_approx) on each component.

<hr class="classref-item-separator"/>

<a id="Vector3_method_is_finite"></a>

<!-- classref-method -->

[bool](bool.md) **is_finite**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_is_finite)

Returns ``true`` if this vector is finite, by calling [@GlobalScope.is_finite()](@GlobalScope.md#@GlobalScope_method_is_finite) on each component.

<hr class="classref-item-separator"/>

<a id="Vector3_method_is_normalized"></a>

<!-- classref-method -->

[bool](bool.md) **is_normalized**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_is_normalized)

Returns ``true`` if the vector is normalized, i.e. its length is approximately equal to 1.

<hr class="classref-item-separator"/>

<a id="Vector3_method_is_zero_approx"></a>

<!-- classref-method -->

[bool](bool.md) **is_zero_approx**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_is_zero_approx)

Returns ``true`` if this vector's values are approximately zero, by running [@GlobalScope.is_zero_approx()](@GlobalScope.md#@GlobalScope_method_is_zero_approx) on each component.

This method is faster than using [is_equal_approx()](Vector3.md#Vector3_method_is_equal_approx) with one value as a zero vector.

<hr class="classref-item-separator"/>

<a id="Vector3_method_length"></a>

<!-- classref-method -->

[float](float.md) **length**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_length)

Returns the length (magnitude) of this vector.

<hr class="classref-item-separator"/>

<a id="Vector3_method_length_squared"></a>

<!-- classref-method -->

[float](float.md) **length_squared**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_length_squared)

Returns the squared length (squared magnitude) of this vector.

This method runs faster than [length()](Vector3.md#Vector3_method_length), so prefer it if you need to compare vectors or need the squared distance for some formula.

<hr class="classref-item-separator"/>

<a id="Vector3_method_lerp"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **lerp**\ (\ to\: [Vector3](Vector3.md), weight\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_lerp)

Returns the result of the linear interpolation between this vector and `to` by amount `weight`. `weight` is on the range of ``0.0`` to ``1.0``, representing the amount of interpolation.

<hr class="classref-item-separator"/>

<a id="Vector3_method_limit_length"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **limit_length**\ (\ length\: [float](float.md) = 1.0\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_limit_length)

Returns the vector with a maximum length by limiting its length to `length`. If the vector is non-finite, the result is undefined.

<hr class="classref-item-separator"/>

<a id="Vector3_method_max"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **max**\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_max)

Returns the component-wise maximum of this and `with`, equivalent to ``Vector3(maxf(x, with.x), maxf(y, with.y), maxf(z, with.z))``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_max_axis_index"></a>

<!-- classref-method -->

[int](int.md) **max_axis_index**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_max_axis_index)

Returns the axis of the vector's highest value. See ``AXIS_*`` constants. If all components are equal, this method returns [AXIS_X](Vector3.md#Vector3_constant_AXIS_X).

<hr class="classref-item-separator"/>

<a id="Vector3_method_maxf"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **maxf**\ (\ with\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_maxf)

Returns the component-wise maximum of this and `with`, equivalent to ``Vector3(maxf(x, with), maxf(y, with), maxf(z, with))``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_min"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **min**\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_min)

Returns the component-wise minimum of this and `with`, equivalent to ``Vector3(minf(x, with.x), minf(y, with.y), minf(z, with.z))``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_min_axis_index"></a>

<!-- classref-method -->

[int](int.md) **min_axis_index**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_min_axis_index)

Returns the axis of the vector's lowest value. See ``AXIS_*`` constants. If all components are equal, this method returns [AXIS_Z](Vector3.md#Vector3_constant_AXIS_Z).

<hr class="classref-item-separator"/>

<a id="Vector3_method_minf"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **minf**\ (\ with\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_minf)

Returns the component-wise minimum of this and `with`, equivalent to ``Vector3(minf(x, with), minf(y, with), minf(z, with))``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_move_toward"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **move_toward**\ (\ to\: [Vector3](Vector3.md), delta\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_move_toward)

Returns a new vector moved toward `to` by the fixed `delta` amount. Will not go past the final value.

<hr class="classref-item-separator"/>

<a id="Vector3_method_normalized"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **normalized**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_normalized)

Returns the result of scaling the vector to unit length. Equivalent to ``v / v.length()``. Returns ``(0, 0, 0)`` if ``v.length() == 0``. See also [is_normalized()](Vector3.md#Vector3_method_is_normalized).

\ **Note:** This function may return incorrect values if the input vector length is near zero.

<hr class="classref-item-separator"/>

<a id="Vector3_method_octahedron_decode"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **octahedron_decode**\ (\ uv\: [Vector2](Vector2.md)\ ) <span class="static">static</span> [ðŸ”—](#Vector3_method_octahedron_decode)

Returns the **Vector3** from an octahedral-compressed form created using [octahedron_encode()](Vector3.md#Vector3_method_octahedron_encode) (stored as a [Vector2](Vector2.md)).

<hr class="classref-item-separator"/>

<a id="Vector3_method_octahedron_encode"></a>

<!-- classref-method -->

[Vector2](Vector2.md) **octahedron_encode**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_octahedron_encode)

Returns the octahedral-encoded (oct32) form of this **Vector3** as a [Vector2](Vector2.md). Since a [Vector2](Vector2.md) occupies 1/3 less memory compared to **Vector3**, this form of compression can be used to pass greater amounts of [normalized()](Vector3.md#Vector3_method_normalized) **Vector3**\\ s without increasing storage or memory requirements. See also [octahedron_decode()](Vector3.md#Vector3_method_octahedron_decode).

\ **Note:** [octahedron_encode()](Vector3.md#Vector3_method_octahedron_encode) can only be used for [normalized()](Vector3.md#Vector3_method_normalized) vectors. [octahedron_encode()](Vector3.md#Vector3_method_octahedron_encode) does *not* check whether this **Vector3** is normalized, and will return a value that does not decompress to the original value if the **Vector3** is not normalized.

\ **Note:** Octahedral compression is *lossy*, although visual differences are rarely perceptible in real world scenarios.

<hr class="classref-item-separator"/>

<a id="Vector3_method_outer"></a>

<!-- classref-method -->

[Basis](Basis.md) **outer**\ (\ with\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_outer)

Returns the outer product with `with`.

<hr class="classref-item-separator"/>

<a id="Vector3_method_posmod"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **posmod**\ (\ mod\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_posmod)

Returns a vector composed of the [@GlobalScope.fposmod()](@GlobalScope.md#@GlobalScope_method_fposmod) of this vector's components and `mod`.

<hr class="classref-item-separator"/>

<a id="Vector3_method_posmodv"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **posmodv**\ (\ modv\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_posmodv)

Returns a vector composed of the [@GlobalScope.fposmod()](@GlobalScope.md#@GlobalScope_method_fposmod) of this vector's components and `modv`'s components.

<hr class="classref-item-separator"/>

<a id="Vector3_method_project"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **project**\ (\ b\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_project)

Returns a new vector resulting from projecting this vector onto the given vector `b`. The resulting new vector is parallel to `b`. See also [slide()](Vector3.md#Vector3_method_slide).

\ **Note:** If the vector `b` is a zero vector, the components of the resulting new vector will be [@GDScript.NAN](@GDScript.md#@GDScript_constant_NAN).

<hr class="classref-item-separator"/>

<a id="Vector3_method_reflect"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **reflect**\ (\ n\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_reflect)

Returns the result of reflecting the vector through a plane defined by the given normal vector `n`.

\ **Note:** [reflect()](Vector3.md#Vector3_method_reflect) differs from what other engines and frameworks call ``reflect()``. In other engines, ``reflect()`` returns the result of the vector reflected by the given plane. The reflection thus passes through the given normal. While in Redot the reflection passes through the plane and can be thought of as bouncing off the normal. See also [bounce()](Vector3.md#Vector3_method_bounce) which does what most engines call ``reflect()``.

<hr class="classref-item-separator"/>

<a id="Vector3_method_rotated"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **rotated**\ (\ axis\: [Vector3](Vector3.md), angle\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_rotated)

Returns the result of rotating this vector around a given axis by `angle` (in radians). The axis must be a normalized vector. See also [@GlobalScope.deg_to_rad()](@GlobalScope.md#@GlobalScope_method_deg_to_rad).

<hr class="classref-item-separator"/>

<a id="Vector3_method_round"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **round**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_round)

Returns a new vector with all components rounded to the nearest integer, with halfway cases rounded away from zero.

<hr class="classref-item-separator"/>

<a id="Vector3_method_sign"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **sign**\ (\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_sign)

Returns a new vector with each component set to ``1.0`` if it's positive, ``-1.0`` if it's negative, and ``0.0`` if it's zero. The result is identical to calling [@GlobalScope.sign()](@GlobalScope.md#@GlobalScope_method_sign) on each component.

<hr class="classref-item-separator"/>

<a id="Vector3_method_signed_angle_to"></a>

<!-- classref-method -->

[float](float.md) **signed_angle_to**\ (\ to\: [Vector3](Vector3.md), axis\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_signed_angle_to)

Returns the signed angle to the given vector, in radians. The sign of the angle is positive in a counter-clockwise direction and negative in a clockwise direction when viewed from the side specified by the `axis`.

<hr class="classref-item-separator"/>

<a id="Vector3_method_slerp"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **slerp**\ (\ to\: [Vector3](Vector3.md), weight\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_slerp)

Returns the result of spherical linear interpolation between this vector and `to`, by amount `weight`. `weight` is on the range of 0.0 to 1.0, representing the amount of interpolation.

This method also handles interpolating the lengths if the input vectors have different lengths. For the special case of one or both input vectors having zero length, this method behaves like [lerp()](Vector3.md#Vector3_method_lerp).

<hr class="classref-item-separator"/>

<a id="Vector3_method_slide"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **slide**\ (\ n\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_slide)

Returns a new vector resulting from sliding this vector along a plane with normal `n`. The resulting new vector is perpendicular to `n`, and is equivalent to this vector minus its projection on `n`. See also [project()](Vector3.md#Vector3_method_project).

\ **Note:** The vector `n` must be normalized. See also [normalized()](Vector3.md#Vector3_method_normalized).

<hr class="classref-item-separator"/>

<a id="Vector3_method_snapped"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **snapped**\ (\ step\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_snapped)

Returns a new vector with each component snapped to the nearest multiple of the corresponding component in `step`. This can also be used to round the components to an arbitrary number of decimals.

<hr class="classref-item-separator"/>

<a id="Vector3_method_snappedf"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **snappedf**\ (\ step\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Vector3_method_snappedf)

Returns a new vector with each component snapped to the nearest multiple of `step`. This can also be used to round the components to an arbitrary number of decimals.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Operator Descriptions

<a id="Vector3_operator_neq_Vector3"></a>

<!-- classref-operator -->

[bool](bool.md) **operator !=**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_neq_Vector3)

Returns ``true`` if the vectors are not equal.

\ **Note:** Due to floating-point precision errors, consider using [is_equal_approx()](Vector3.md#Vector3_method_is_equal_approx) instead, which is more reliable.

\ **Note:** Vectors with [@GDScript.NAN](@GDScript.md#@GDScript_constant_NAN) elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.

<hr class="classref-item-separator"/>

<a id="Vector3_operator_mul_Basis"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator ***\ (\ right\: [Basis](Basis.md)\ ) [ðŸ”—](#Vector3_operator_mul_Basis)

Inversely transforms (multiplies) the **Vector3** by the given [Basis](Basis.md) matrix, under the assumption that the basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).

\ ``vector * basis`` is equivalent to ``basis.transposed() * vector``. See [Basis.transposed()](Basis.md#Basis_method_transposed).

For transforming by inverse of a non-orthonormal basis (e.g. with scaling) ``basis.inverse() * vector`` can be used instead. See [Basis.inverse()](Basis.md#Basis_method_inverse).

<hr class="classref-item-separator"/>

<a id="Vector3_operator_mul_Quaternion"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator ***\ (\ right\: [Quaternion](Quaternion.md)\ ) [ðŸ”—](#Vector3_operator_mul_Quaternion)

Inversely transforms (multiplies) the **Vector3** by the given [Quaternion](Quaternion.md).

\ ``vector * quaternion`` is equivalent to ``quaternion.inverse() * vector``. See [Quaternion.inverse()](Quaternion.md#Quaternion_method_inverse).

<hr class="classref-item-separator"/>

<a id="Vector3_operator_mul_Transform3D"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator ***\ (\ right\: [Transform3D](Transform3D.md)\ ) [ðŸ”—](#Vector3_operator_mul_Transform3D)

Inversely transforms (multiplies) the **Vector3** by the given [Transform3D](Transform3D.md) transformation matrix, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).

\ ``vector * transform`` is equivalent to ``transform.inverse() * vector``. See [Transform3D.inverse()](Transform3D.md#Transform3D_method_inverse).

For transforming by inverse of an affine transformation (e.g. with scaling) ``transform.affine_inverse() * vector`` can be used instead. See [Transform3D.affine_inverse()](Transform3D.md#Transform3D_method_affine_inverse).

<hr class="classref-item-separator"/>

<a id="Vector3_operator_mul_Vector3"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator ***\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_mul_Vector3)

Multiplies each component of the **Vector3** by the components of the given **Vector3**.

```
    print(Vector3(10, 20, 30) * Vector3(3, 4, 5)) # Prints (30.0, 80.0, 150.0)
```


<hr class="classref-item-separator"/>

<a id="Vector3_operator_mul_float"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator ***\ (\ right\: [float](float.md)\ ) [ðŸ”—](#Vector3_operator_mul_float)

Multiplies each component of the **Vector3** by the given [float](float.md).

<hr class="classref-item-separator"/>

<a id="Vector3_operator_mul_int"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator ***\ (\ right\: [int](int.md)\ ) [ðŸ”—](#Vector3_operator_mul_int)

Multiplies each component of the **Vector3** by the given [int](int.md).

<hr class="classref-item-separator"/>

<a id="Vector3_operator_sum_Vector3"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator +**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_sum_Vector3)

Adds each component of the **Vector3** by the components of the given **Vector3**.

```
    print(Vector3(10, 20, 30) + Vector3(3, 4, 5)) # Prints (13.0, 24.0, 35.0)
```


<hr class="classref-item-separator"/>

<a id="Vector3_operator_dif_Vector3"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator -**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_dif_Vector3)

Subtracts each component of the **Vector3** by the components of the given **Vector3**.

```
    print(Vector3(10, 20, 30) - Vector3(3, 4, 5)) # Prints (7.0, 16.0, 25.0)
```


<hr class="classref-item-separator"/>

<a id="Vector3_operator_div_Vector3"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator /**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_div_Vector3)

Divides each component of the **Vector3** by the components of the given **Vector3**.

```
    print(Vector3(10, 20, 30) / Vector3(2, 5, 3)) # Prints (5.0, 4.0, 10.0)
```


<hr class="classref-item-separator"/>

<a id="Vector3_operator_div_float"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator /**\ (\ right\: [float](float.md)\ ) [ðŸ”—](#Vector3_operator_div_float)

Divides each component of the **Vector3** by the given [float](float.md).

<hr class="classref-item-separator"/>

<a id="Vector3_operator_div_int"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator /**\ (\ right\: [int](int.md)\ ) [ðŸ”—](#Vector3_operator_div_int)

Divides each component of the **Vector3** by the given [int](int.md).

<hr class="classref-item-separator"/>

<a id="Vector3_operator_lt_Vector3"></a>

<!-- classref-operator -->

[bool](bool.md) **operator &lt;**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_lt_Vector3)

Compares two **Vector3** vectors by first checking if the X value of the left vector is less than the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.

\ **Note:** Vectors with [@GDScript.NAN](@GDScript.md#@GDScript_constant_NAN) elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.

<hr class="classref-item-separator"/>

<a id="Vector3_operator_lte_Vector3"></a>

<!-- classref-operator -->

[bool](bool.md) **operator &lt;=**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_lte_Vector3)

Compares two **Vector3** vectors by first checking if the X value of the left vector is less than or equal to the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.

\ **Note:** Vectors with [@GDScript.NAN](@GDScript.md#@GDScript_constant_NAN) elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.

<hr class="classref-item-separator"/>

<a id="Vector3_operator_eq_Vector3"></a>

<!-- classref-operator -->

[bool](bool.md) **operator ==**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_eq_Vector3)

Returns ``true`` if the vectors are exactly equal.

\ **Note:** Due to floating-point precision errors, consider using [is_equal_approx()](Vector3.md#Vector3_method_is_equal_approx) instead, which is more reliable.

\ **Note:** Vectors with [@GDScript.NAN](@GDScript.md#@GDScript_constant_NAN) elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.

<hr class="classref-item-separator"/>

<a id="Vector3_operator_gt_Vector3"></a>

<!-- classref-operator -->

[bool](bool.md) **operator &gt;**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_gt_Vector3)

Compares two **Vector3** vectors by first checking if the X value of the left vector is greater than the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.

\ **Note:** Vectors with [@GDScript.NAN](@GDScript.md#@GDScript_constant_NAN) elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.

<hr class="classref-item-separator"/>

<a id="Vector3_operator_gte_Vector3"></a>

<!-- classref-operator -->

[bool](bool.md) **operator &gt;=**\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Vector3_operator_gte_Vector3)

Compares two **Vector3** vectors by first checking if the X value of the left vector is greater than or equal to the X value of the `right` vector. If the X values are exactly equal, then it repeats this check with the Y values of the two vectors, and then with the Z values. This operator is useful for sorting vectors.

\ **Note:** Vectors with [@GDScript.NAN](@GDScript.md#@GDScript_constant_NAN) elements don't behave the same as other vectors. Therefore, the results from this operator may not be accurate if NaNs are included.

<hr class="classref-item-separator"/>

<a id="Vector3_operator_idx_int"></a>

<!-- classref-operator -->

[float](float.md) **operator []**\ (\ index\: [int](int.md)\ ) [ðŸ”—](#Vector3_operator_idx_int)

Access vector components using their `index`. ``v[0]`` is equivalent to ``v.x``, ``v[1]`` is equivalent to ``v.y``, and ``v[2]`` is equivalent to ``v.z``.

<hr class="classref-item-separator"/>

<a id="Vector3_operator_unplus"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator unary+**\ (\ ) [ðŸ”—](#Vector3_operator_unplus)

Returns the same value as if the ``+`` was not there. Unary ``+`` does nothing, but sometimes it can make your code more readable.

<hr class="classref-item-separator"/>

<a id="Vector3_operator_unminus"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator unary-**\ (\ ) [ðŸ”—](#Vector3_operator_unminus)

Returns the negative value of the **Vector3**. This is the same as writing ``Vector3(-v.x, -v.y, -v.z)``. This operation flips the direction of the vector while keeping the same magnitude. With floats, the number zero can be either positive or negative.

