<!-- github_url: hide -->

<!-- keywords: textarea -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/TextEdit.xml. -->

<a id="TextEdit"></a>

# TextEdit

**Inherits:** [Control](Control.md) **\<** [CanvasItem](CanvasItem.md) **\<** [Node](Node.md) **\<** [Object](Object.md)

**Inherited By:** [CodeEdit](CodeEdit.md)

A multiline text editor.

<!-- classref-introduction-group -->

## Description

A multiline text editor. It also has limited facilities for editing code, such as syntax highlighting support. For more advanced facilities for editing code, see [CodeEdit](CodeEdit.md).

While entering text, it is possible to insert special characters using Unicode, OEM or Windows alt codes:

- To enter Unicode codepoints, hold :kbd:`Alt` and type the codepoint on the numpad. For example, to enter the character ``Ã¡`` (U+00E1), hold :kbd:`Alt` and type :kbd:`+E1` on the numpad (the leading zeroes can be omitted).

- To enter OEM codepoints, hold :kbd:`Alt` and type the code on the numpad. For example, to enter the character ``Ã¡`` (OEM 160), hold :kbd:`Alt` and type ``160`` on the numpad.

- To enter Windows codepoints, hold :kbd:`Alt` and type the code on the numpad. For example, to enter the character ``Ã¡`` (Windows 0225), hold :kbd:`Alt` and type :kbd:`0`, :kbd:`2`, :kbd:`2`, :kbd:`5` on the numpad. The leading zero here must **not** be omitted, as this is how Windows codepoints are distinguished from OEM codepoints.

\ **Note:** Most viewport, caret, and edit methods contain a ``caret_index`` argument for [caret_multiple](TextEdit.md#TextEdit_property_caret_multiple) support. The argument should be one of the following: ``-1`` for all carets, ``0`` for the main caret, or greater than ``0`` for secondary carets in the order they were created.

\ **Note:** When holding down :kbd:`Alt`, the vertical scroll wheel will scroll 5 times as fast as it would normally do. This also works in the Redot script editor.

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[AutowrapMode](TextServer.md#enum_TextServer_AutowrapMode)</th>
      <th>[autowrap_mode](#TextEdit_property_autowrap_mode)</th>
      <th>`3`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[backspace_deletes_composite_character_enabled](#TextEdit_property_backspace_deletes_composite_character_enabled)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[caret_blink](#TextEdit_property_caret_blink)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[caret_blink_interval](#TextEdit_property_caret_blink_interval)</td>
      <td>`0.65`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[caret_draw_when_editable_disabled](#TextEdit_property_caret_draw_when_editable_disabled)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[caret_mid_grapheme](#TextEdit_property_caret_mid_grapheme)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[caret_move_on_right_click](#TextEdit_property_caret_move_on_right_click)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[caret_multiple](#TextEdit_property_caret_multiple)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[CaretType](TextEdit.md#enum_TextEdit_CaretType)</td>
      <td>[caret_type](#TextEdit_property_caret_type)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>clip_contents</td>
      <td>`true` (overrides [Control.clip_contents](Control.md#Control_property_clip_contents))</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[context_menu_enabled](#TextEdit_property_context_menu_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[custom_word_separators](#TextEdit_property_custom_word_separators)</td>
      <td>`""`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[deselect_on_focus_loss_enabled](#TextEdit_property_deselect_on_focus_loss_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[drag_and_drop_selection_enabled](#TextEdit_property_drag_and_drop_selection_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[draw_control_chars](#TextEdit_property_draw_control_chars)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[draw_spaces](#TextEdit_property_draw_spaces)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[draw_tabs](#TextEdit_property_draw_tabs)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[editable](#TextEdit_property_editable)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[emoji_menu_enabled](#TextEdit_property_emoji_menu_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[empty_selection_clipboard_enabled](#TextEdit_property_empty_selection_clipboard_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[FocusMode](Control.md#enum_Control_FocusMode)</td>
      <td>focus_mode</td>
      <td>`2` (overrides [Control.focus_mode](Control.md#Control_property_focus_mode))</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[highlight_all_occurrences](#TextEdit_property_highlight_all_occurrences)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[highlight_current_line](#TextEdit_property_highlight_current_line)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[indent_wrapped_lines](#TextEdit_property_indent_wrapped_lines)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[language](#TextEdit_property_language)</td>
      <td>`""`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[middle_mouse_paste_enabled](#TextEdit_property_middle_mouse_paste_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[minimap_draw](#TextEdit_property_minimap_draw)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[minimap_width](#TextEdit_property_minimap_width)</td>
      <td>`80`</td>
    </tr>
    <tr>
      <td>[CursorShape](Control.md#enum_Control_CursorShape)</td>
      <td>mouse_default_cursor_shape</td>
      <td>`1` (overrides [Control.mouse_default_cursor_shape](Control.md#Control_property_mouse_default_cursor_shape))</td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[placeholder_text](#TextEdit_property_placeholder_text)</td>
      <td>`""`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[scroll_fit_content_height](#TextEdit_property_scroll_fit_content_height)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[scroll_fit_content_width](#TextEdit_property_scroll_fit_content_width)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[scroll_horizontal](#TextEdit_property_scroll_horizontal)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[scroll_past_end_of_file](#TextEdit_property_scroll_past_end_of_file)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[scroll_smooth](#TextEdit_property_scroll_smooth)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[scroll_v_scroll_speed](#TextEdit_property_scroll_v_scroll_speed)</td>
      <td>`80.0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[scroll_vertical](#TextEdit_property_scroll_vertical)</td>
      <td>`0.0`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[selecting_enabled](#TextEdit_property_selecting_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[shortcut_keys_enabled](#TextEdit_property_shortcut_keys_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[StructuredTextParser](TextServer.md#enum_TextServer_StructuredTextParser)</td>
      <td>[structured_text_bidi_override](#TextEdit_property_structured_text_bidi_override)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[structured_text_bidi_override_options](#TextEdit_property_structured_text_bidi_override_options)</td>
      <td>`[]`</td>
    </tr>
    <tr>
      <td>[SyntaxHighlighter](SyntaxHighlighter.md)</td>
      <td>[syntax_highlighter](#TextEdit_property_syntax_highlighter)</td>
      <td></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[tab_input_mode](#TextEdit_property_tab_input_mode)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[text](#TextEdit_property_text)</td>
      <td>`""`</td>
    </tr>
    <tr>
      <td>[TextDirection](Control.md#enum_Control_TextDirection)</td>
      <td>[text_direction](#TextEdit_property_text_direction)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[use_custom_word_separators](#TextEdit_property_use_custom_word_separators)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[use_default_word_separators](#TextEdit_property_use_default_word_separators)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[virtual_keyboard_enabled](#TextEdit_property_virtual_keyboard_enabled)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[virtual_keyboard_show_on_focus](#TextEdit_property_virtual_keyboard_show_on_focus)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[LineWrappingMode](TextEdit.md#enum_TextEdit_LineWrappingMode)</td>
      <td>[wrap_mode](#TextEdit_property_wrap_mode)</td>
      <td>`0`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>`void`</th>
      <th>[_backspace](#TextEdit_private_method__backspace)\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`void`</td>
      <td>[_copy](#TextEdit_private_method__copy)\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[_cut](#TextEdit_private_method__cut)\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[_handle_unicode_input](#TextEdit_private_method__handle_unicode_input)\ (\ unicode_char\: [int](int.md), caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[_paste](#TextEdit_private_method__paste)\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[_paste_primary_clipboard](#TextEdit_private_method__paste_primary_clipboard)\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[add_caret](#TextEdit_method_add_caret)\ (\ line\: [int](int.md), column\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[add_caret_at_carets](#TextEdit_method_add_caret_at_carets)\ (\ below\: [bool](bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[add_gutter](#TextEdit_method_add_gutter)\ (\ at\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[add_selection_for_next_occurrence](#TextEdit_method_add_selection_for_next_occurrence)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[adjust_carets_after_edit](#TextEdit_method_adjust_carets_after_edit)\ (\ caret\: [int](int.md), from_line\: [int](int.md), from_col\: [int](int.md), to_line\: [int](int.md), to_col\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[adjust_viewport_to_caret](#TextEdit_method_adjust_viewport_to_caret)\ (\ caret_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[apply_ime](#TextEdit_method_apply_ime)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[backspace](#TextEdit_method_backspace)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[begin_complex_operation](#TextEdit_method_begin_complex_operation)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[begin_multicaret_edit](#TextEdit_method_begin_multicaret_edit)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[cancel_ime](#TextEdit_method_cancel_ime)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[center_viewport_to_caret](#TextEdit_method_center_viewport_to_caret)\ (\ caret_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[clear](#TextEdit_method_clear)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[clear_undo_history](#TextEdit_method_clear_undo_history)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[collapse_carets](#TextEdit_method_collapse_carets)\ (\ from_line\: [int](int.md), from_column\: [int](int.md), to_line\: [int](int.md), to_column\: [int](int.md), inclusive\: [bool](bool.md) = false\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[copy](#TextEdit_method_copy)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[cut](#TextEdit_method_cut)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[delete_selection](#TextEdit_method_delete_selection)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[deselect](#TextEdit_method_deselect)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[end_action](#TextEdit_method_end_action)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[end_complex_operation](#TextEdit_method_end_complex_operation)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[end_multicaret_edit](#TextEdit_method_end_multicaret_edit)\ (\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_caret_column](#TextEdit_method_get_caret_column)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_caret_count](#TextEdit_method_get_caret_count)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[get_caret_draw_pos](#TextEdit_method_get_caret_draw_pos)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[PackedInt32Array](PackedInt32Array.md)</td>
      <td>[get_caret_index_edit_order](#TextEdit_method_get_caret_index_edit_order)\ (\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_caret_line](#TextEdit_method_get_caret_line)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_caret_wrap_index](#TextEdit_method_get_caret_wrap_index)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_first_non_whitespace_column](#TextEdit_method_get_first_non_whitespace_column)\ (\ line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_first_visible_line](#TextEdit_method_get_first_visible_line)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_gutter_count](#TextEdit_method_get_gutter_count)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[get_gutter_name](#TextEdit_method_get_gutter_name)\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[GutterType](TextEdit.md#enum_TextEdit_GutterType)</td>
      <td>[get_gutter_type](#TextEdit_method_get_gutter_type)\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_gutter_width](#TextEdit_method_get_gutter_width)\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[HScrollBar](HScrollBar.md)</td>
      <td>[get_h_scroll_bar](#TextEdit_method_get_h_scroll_bar)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_indent_level](#TextEdit_method_get_indent_level)\ (\ line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_last_full_visible_line](#TextEdit_method_get_last_full_visible_line)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_last_full_visible_line_wrap_index](#TextEdit_method_get_last_full_visible_line_wrap_index)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_last_unhidden_line](#TextEdit_method_get_last_unhidden_line)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[get_line](#TextEdit_method_get_line)\ (\ line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[get_line_background_color](#TextEdit_method_get_line_background_color)\ (\ line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2i](Vector2i.md)</td>
      <td>[get_line_column_at_pos](#TextEdit_method_get_line_column_at_pos)\ (\ position\: [Vector2i](Vector2i.md), clamp_line\: [bool](bool.md) = true, clamp_column\: [bool](bool.md) = true\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_line_count](#TextEdit_method_get_line_count)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[get_line_gutter_icon](#TextEdit_method_get_line_gutter_icon)\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[get_line_gutter_item_color](#TextEdit_method_get_line_gutter_item_color)\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[get_line_gutter_metadata](#TextEdit_method_get_line_gutter_metadata)\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[get_line_gutter_text](#TextEdit_method_get_line_gutter_text)\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_line_height](#TextEdit_method_get_line_height)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Array](Array.md)\[[Vector2i](Vector2i.md)\]</td>
      <td>[get_line_ranges_from_carets](#TextEdit_method_get_line_ranges_from_carets)\ (\ only_selections\: [bool](bool.md) = false, merge_adjacent\: [bool](bool.md) = true\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_line_width](#TextEdit_method_get_line_width)\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = -1\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[get_line_with_ime](#TextEdit_method_get_line_with_ime)\ (\ line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_line_wrap_count](#TextEdit_method_get_line_wrap_count)\ (\ line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_line_wrap_index_at_column](#TextEdit_method_get_line_wrap_index_at_column)\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[PackedStringArray](PackedStringArray.md)</td>
      <td>[get_line_wrapped_text](#TextEdit_method_get_line_wrapped_text)\ (\ line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[get_local_mouse_pos](#TextEdit_method_get_local_mouse_pos)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[PopupMenu](PopupMenu.md)</td>
      <td>[get_menu](#TextEdit_method_get_menu)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_minimap_line_at_pos](#TextEdit_method_get_minimap_line_at_pos)\ (\ position\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_minimap_visible_lines](#TextEdit_method_get_minimap_visible_lines)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_next_composite_character_column](#TextEdit_method_get_next_composite_character_column)\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2i](Vector2i.md)</td>
      <td>[get_next_visible_line_index_offset_from](#TextEdit_method_get_next_visible_line_index_offset_from)\ (\ line\: [int](int.md), wrap_index\: [int](int.md), visible_amount\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_next_visible_line_offset_from](#TextEdit_method_get_next_visible_line_offset_from)\ (\ line\: [int](int.md), visible_amount\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2i](Vector2i.md)</td>
      <td>[get_pos_at_line_column](#TextEdit_method_get_pos_at_line_column)\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_previous_composite_character_column](#TextEdit_method_get_previous_composite_character_column)\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[get_rect_at_line_column](#TextEdit_method_get_rect_at_line_column)\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_saved_version](#TextEdit_method_get_saved_version)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[get_scroll_pos_for_line](#TextEdit_method_get_scroll_pos_for_line)\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[get_selected_text](#TextEdit_method_get_selected_text)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_at_line_column](#TextEdit_method_get_selection_at_line_column)\ (\ line\: [int](int.md), column\: [int](int.md), include_edges\: [bool](bool.md) = true, only_selections\: [bool](bool.md) = true\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_column](#TextEdit_method_get_selection_column)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_from_column](#TextEdit_method_get_selection_from_column)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_from_line](#TextEdit_method_get_selection_from_line)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_line](#TextEdit_method_get_selection_line)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode)</td>
      <td>[get_selection_mode](#TextEdit_method_get_selection_mode)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_origin_column](#TextEdit_method_get_selection_origin_column)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_origin_line](#TextEdit_method_get_selection_origin_line)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_to_column](#TextEdit_method_get_selection_to_column)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_selection_to_line](#TextEdit_method_get_selection_to_line)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[PackedInt32Array](PackedInt32Array.md)</td>
      <td>[get_sorted_carets](#TextEdit_method_get_sorted_carets)\ (\ include_ignored_carets\: [bool](bool.md) = false\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_tab_size](#TextEdit_method_get_tab_size)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_total_gutter_width](#TextEdit_method_get_total_gutter_width)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_total_visible_line_count](#TextEdit_method_get_total_visible_line_count)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[VScrollBar](VScrollBar.md)</td>
      <td>[get_v_scroll_bar](#TextEdit_method_get_v_scroll_bar)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_version](#TextEdit_method_get_version)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_visible_line_count](#TextEdit_method_get_visible_line_count)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_visible_line_count_in_range](#TextEdit_method_get_visible_line_count_in_range)\ (\ from_line\: [int](int.md), to_line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[get_word_at_pos](#TextEdit_method_get_word_at_pos)\ (\ position\: [Vector2](Vector2.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[get_word_under_caret](#TextEdit_method_get_word_under_caret)\ (\ caret_index\: [int](int.md) = -1\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_ime_text](#TextEdit_method_has_ime_text)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_redo](#TextEdit_method_has_redo)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_selection](#TextEdit_method_has_selection)\ (\ caret_index\: [int](int.md) = -1\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_undo](#TextEdit_method_has_undo)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[insert_line_at](#TextEdit_method_insert_line_at)\ (\ line\: [int](int.md), text\: [String](String.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[insert_text](#TextEdit_method_insert_text)\ (\ text\: [String](String.md), line\: [int](int.md), column\: [int](int.md), before_selection_begin\: [bool](bool.md) = true, before_selection_end\: [bool](bool.md) = false\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[insert_text_at_caret](#TextEdit_method_insert_text_at_caret)\ (\ text\: [String](String.md), caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_caret_after_selection_origin](#TextEdit_method_is_caret_after_selection_origin)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_caret_visible](#TextEdit_method_is_caret_visible)\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_dragging_cursor](#TextEdit_method_is_dragging_cursor)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_gutter_clickable](#TextEdit_method_is_gutter_clickable)\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_gutter_drawn](#TextEdit_method_is_gutter_drawn)\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_gutter_overwritable](#TextEdit_method_is_gutter_overwritable)\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_in_mulitcaret_edit](#TextEdit_method_is_in_mulitcaret_edit)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_line_gutter_clickable](#TextEdit_method_is_line_gutter_clickable)\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_line_wrapped](#TextEdit_method_is_line_wrapped)\ (\ line\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_menu_visible](#TextEdit_method_is_menu_visible)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_mouse_over_selection](#TextEdit_method_is_mouse_over_selection)\ (\ edges\: [bool](bool.md), caret_index\: [int](int.md) = -1\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_overtype_mode_enabled](#TextEdit_method_is_overtype_mode_enabled)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[menu_option](#TextEdit_method_menu_option)\ (\ option\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[merge_gutters](#TextEdit_method_merge_gutters)\ (\ from_line\: [int](int.md), to_line\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[merge_overlapping_carets](#TextEdit_method_merge_overlapping_carets)\ (\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[multicaret_edit_ignore_caret](#TextEdit_method_multicaret_edit_ignore_caret)\ (\ caret_index\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[paste](#TextEdit_method_paste)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[paste_primary_clipboard](#TextEdit_method_paste_primary_clipboard)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[redo](#TextEdit_method_redo)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[remove_caret](#TextEdit_method_remove_caret)\ (\ caret\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[remove_gutter](#TextEdit_method_remove_gutter)\ (\ gutter\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[remove_line_at](#TextEdit_method_remove_line_at)\ (\ line\: [int](int.md), move_carets_down\: [bool](bool.md) = true\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[remove_secondary_carets](#TextEdit_method_remove_secondary_carets)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[remove_text](#TextEdit_method_remove_text)\ (\ from_line\: [int](int.md), from_column\: [int](int.md), to_line\: [int](int.md), to_column\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector2i](Vector2i.md)</td>
      <td>[search](#TextEdit_method_search)\ (\ text\: [String](String.md), flags\: [int](int.md), from_line\: [int](int.md), from_column\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[select](#TextEdit_method_select)\ (\ origin_line\: [int](int.md), origin_column\: [int](int.md), caret_line\: [int](int.md), caret_column\: [int](int.md), caret_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[select_all](#TextEdit_method_select_all)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[select_word_under_caret](#TextEdit_method_select_word_under_caret)\ (\ caret_index\: [int](int.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_caret_column](#TextEdit_method_set_caret_column)\ (\ column\: [int](int.md), adjust_viewport\: [bool](bool.md) = true, caret_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_caret_line](#TextEdit_method_set_caret_line)\ (\ line\: [int](int.md), adjust_viewport\: [bool](bool.md) = true, can_be_hidden\: [bool](bool.md) = true, wrap_index\: [int](int.md) = 0, caret_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_gutter_clickable](#TextEdit_method_set_gutter_clickable)\ (\ gutter\: [int](int.md), clickable\: [bool](bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_gutter_custom_draw](#TextEdit_method_set_gutter_custom_draw)\ (\ column\: [int](int.md), draw_callback\: [Callable](Callable.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_gutter_draw](#TextEdit_method_set_gutter_draw)\ (\ gutter\: [int](int.md), draw\: [bool](bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_gutter_name](#TextEdit_method_set_gutter_name)\ (\ gutter\: [int](int.md), name\: [String](String.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_gutter_overwritable](#TextEdit_method_set_gutter_overwritable)\ (\ gutter\: [int](int.md), overwritable\: [bool](bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_gutter_type](#TextEdit_method_set_gutter_type)\ (\ gutter\: [int](int.md), type\: [GutterType](TextEdit.md#enum_TextEdit_GutterType)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_gutter_width](#TextEdit_method_set_gutter_width)\ (\ gutter\: [int](int.md), width\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line](#TextEdit_method_set_line)\ (\ line\: [int](int.md), new_text\: [String](String.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_as_center_visible](#TextEdit_method_set_line_as_center_visible)\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_as_first_visible](#TextEdit_method_set_line_as_first_visible)\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_as_last_visible](#TextEdit_method_set_line_as_last_visible)\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_background_color](#TextEdit_method_set_line_background_color)\ (\ line\: [int](int.md), color\: [Color](Color.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_gutter_clickable](#TextEdit_method_set_line_gutter_clickable)\ (\ line\: [int](int.md), gutter\: [int](int.md), clickable\: [bool](bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_gutter_icon](#TextEdit_method_set_line_gutter_icon)\ (\ line\: [int](int.md), gutter\: [int](int.md), icon\: [Texture2D](Texture2D.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_gutter_item_color](#TextEdit_method_set_line_gutter_item_color)\ (\ line\: [int](int.md), gutter\: [int](int.md), color\: [Color](Color.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_gutter_metadata](#TextEdit_method_set_line_gutter_metadata)\ (\ line\: [int](int.md), gutter\: [int](int.md), metadata\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_line_gutter_text](#TextEdit_method_set_line_gutter_text)\ (\ line\: [int](int.md), gutter\: [int](int.md), text\: [String](String.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_overtype_mode_enabled](#TextEdit_method_set_overtype_mode_enabled)\ (\ enabled\: [bool](bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_search_flags](#TextEdit_method_set_search_flags)\ (\ flags\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_search_text](#TextEdit_method_set_search_text)\ (\ search_text\: [String](String.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_selection_mode](#TextEdit_method_set_selection_mode)\ (\ mode\: [SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_selection_origin_column](#TextEdit_method_set_selection_origin_column)\ (\ column\: [int](int.md), caret_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_selection_origin_line](#TextEdit_method_set_selection_origin_line)\ (\ line\: [int](int.md), can_be_hidden\: [bool](bool.md) = true, wrap_index\: [int](int.md) = -1, caret_index\: [int](int.md) = 0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_tab_size](#TextEdit_method_set_tab_size)\ (\ size\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_tooltip_request_func](#TextEdit_method_set_tooltip_request_func)\ (\ callback\: [Callable](Callable.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[skip_selection_for_next_occurrence](#TextEdit_method_skip_selection_for_next_occurrence)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[start_action](#TextEdit_method_start_action)\ (\ action\: [EditAction](TextEdit.md#enum_TextEdit_EditAction)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[swap_lines](#TextEdit_method_swap_lines)\ (\ from_line\: [int](int.md), to_line\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[tag_saved_version](#TextEdit_method_tag_saved_version)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[undo](#TextEdit_method_undo)\ (\ )</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Theme Properties

<table>
  <thead>
    <tr>
      <th>[Color](Color.md)</th>
      <th>[background_color](#TextEdit_theme_color_background_color)</th>
      <th>`Color(0, 0, 0, 0)`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[caret_background_color](#TextEdit_theme_color_caret_background_color)</td>
      <td>`Color(0, 0, 0, 1)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[caret_color](#TextEdit_theme_color_caret_color)</td>
      <td>`Color(0.875, 0.875, 0.875, 1)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[current_line_color](#TextEdit_theme_color_current_line_color)</td>
      <td>`Color(0.25, 0.25, 0.26, 0.8)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[font_color](#TextEdit_theme_color_font_color)</td>
      <td>`Color(0.875, 0.875, 0.875, 1)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[font_outline_color](#TextEdit_theme_color_font_outline_color)</td>
      <td>`Color(0, 0, 0, 1)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[font_placeholder_color](#TextEdit_theme_color_font_placeholder_color)</td>
      <td>`Color(0.875, 0.875, 0.875, 0.6)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[font_readonly_color](#TextEdit_theme_color_font_readonly_color)</td>
      <td>`Color(0.875, 0.875, 0.875, 0.5)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[font_selected_color](#TextEdit_theme_color_font_selected_color)</td>
      <td>`Color(0, 0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[search_result_border_color](#TextEdit_theme_color_search_result_border_color)</td>
      <td>`Color(0.3, 0.3, 0.3, 0.4)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[search_result_color](#TextEdit_theme_color_search_result_color)</td>
      <td>`Color(0.3, 0.3, 0.3, 1)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[selection_color](#TextEdit_theme_color_selection_color)</td>
      <td>`Color(0.5, 0.5, 0.5, 1)`</td>
    </tr>
    <tr>
      <td>[Color](Color.md)</td>
      <td>[word_highlighted_color](#TextEdit_theme_color_word_highlighted_color)</td>
      <td>`Color(0.5, 0.5, 0.5, 0.25)`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[caret_width](#TextEdit_theme_constant_caret_width)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[line_spacing](#TextEdit_theme_constant_line_spacing)</td>
      <td>`4`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[outline_size](#TextEdit_theme_constant_outline_size)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[Font](Font.md)</td>
      <td>[font](#TextEdit_theme_font_font)</td>
      <td></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[font_size](#TextEdit_theme_font_size_font_size)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[space](#TextEdit_theme_icon_space)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[tab](#TextEdit_theme_icon_tab)</td>
      <td></td>
    </tr>
    <tr>
      <td>[StyleBox](StyleBox.md)</td>
      <td>[focus](#TextEdit_theme_style_focus)</td>
      <td></td>
    </tr>
    <tr>
      <td>[StyleBox](StyleBox.md)</td>
      <td>[normal](#TextEdit_theme_style_normal)</td>
      <td></td>
    </tr>
    <tr>
      <td>[StyleBox](StyleBox.md)</td>
      <td>[read_only](#TextEdit_theme_style_read_only)</td>
      <td></td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Signals

<a id="TextEdit_signal_caret_changed"></a>

<!-- classref-signal -->

**caret_changed**\ (\ ) [ðŸ”—](#TextEdit_signal_caret_changed)

Emitted when any caret changes position.

<hr class="classref-item-separator"/>

<a id="TextEdit_signal_gutter_added"></a>

<!-- classref-signal -->

**gutter_added**\ (\ ) [ðŸ”—](#TextEdit_signal_gutter_added)

Emitted when a gutter is added.

<hr class="classref-item-separator"/>

<a id="TextEdit_signal_gutter_clicked"></a>

<!-- classref-signal -->

**gutter_clicked**\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) [ðŸ”—](#TextEdit_signal_gutter_clicked)

Emitted when a gutter is clicked.

<hr class="classref-item-separator"/>

<a id="TextEdit_signal_gutter_removed"></a>

<!-- classref-signal -->

**gutter_removed**\ (\ ) [ðŸ”—](#TextEdit_signal_gutter_removed)

Emitted when a gutter is removed.

<hr class="classref-item-separator"/>

<a id="TextEdit_signal_lines_edited_from"></a>

<!-- classref-signal -->

**lines_edited_from**\ (\ from_line\: [int](int.md), to_line\: [int](int.md)\ ) [ðŸ”—](#TextEdit_signal_lines_edited_from)

Emitted immediately when the text changes.

When text is added `from_line` will be less than `to_line`. On a remove `to_line` will be less than `from_line`.

<hr class="classref-item-separator"/>

<a id="TextEdit_signal_text_changed"></a>

<!-- classref-signal -->

**text_changed**\ (\ ) [ðŸ”—](#TextEdit_signal_text_changed)

Emitted when the text changes.

<hr class="classref-item-separator"/>

<a id="TextEdit_signal_text_set"></a>

<!-- classref-signal -->

**text_set**\ (\ ) [ðŸ”—](#TextEdit_signal_text_set)

Emitted when [clear()](TextEdit.md#TextEdit_method_clear) is called or [text](TextEdit.md#TextEdit_property_text) is set.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_TextEdit_MenuItems"></a>

<!-- classref-enumeration -->

enum **MenuItems**: [ðŸ”—](#enum_TextEdit_MenuItems)

<a id="TextEdit_constant_MENU_CUT"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_CUT** = `0`

Cuts (copies and clears) the selected text.<a id="TextEdit_constant_MENU_COPY"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_COPY** = `1`

Copies the selected text.<a id="TextEdit_constant_MENU_PASTE"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_PASTE** = `2`

Pastes the clipboard text over the selected text (or at the cursor's position).<a id="TextEdit_constant_MENU_CLEAR"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_CLEAR** = `3`

Erases the whole **TextEdit** text.<a id="TextEdit_constant_MENU_SELECT_ALL"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_SELECT_ALL** = `4`

Selects the whole **TextEdit** text.<a id="TextEdit_constant_MENU_UNDO"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_UNDO** = `5`

Undoes the previous action.<a id="TextEdit_constant_MENU_REDO"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_REDO** = `6`

Redoes the previous action.<a id="TextEdit_constant_MENU_SUBMENU_TEXT_DIR"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_SUBMENU_TEXT_DIR** = `7`

ID of "Text Writing Direction" submenu.<a id="TextEdit_constant_MENU_DIR_INHERITED"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_DIR_INHERITED** = `8`

Sets text direction to inherited.<a id="TextEdit_constant_MENU_DIR_AUTO"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_DIR_AUTO** = `9`

Sets text direction to automatic.<a id="TextEdit_constant_MENU_DIR_LTR"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_DIR_LTR** = `10`

Sets text direction to left-to-right.<a id="TextEdit_constant_MENU_DIR_RTL"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_DIR_RTL** = `11`

Sets text direction to right-to-left.<a id="TextEdit_constant_MENU_DISPLAY_UCC"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_DISPLAY_UCC** = `12`

Toggles control character display.<a id="TextEdit_constant_MENU_SUBMENU_INSERT_UCC"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_SUBMENU_INSERT_UCC** = `13`

ID of "Insert Control Character" submenu.<a id="TextEdit_constant_MENU_INSERT_LRM"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_LRM** = `14`

Inserts left-to-right mark (LRM) character.<a id="TextEdit_constant_MENU_INSERT_RLM"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_RLM** = `15`

Inserts right-to-left mark (RLM) character.<a id="TextEdit_constant_MENU_INSERT_LRE"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_LRE** = `16`

Inserts start of left-to-right embedding (LRE) character.<a id="TextEdit_constant_MENU_INSERT_RLE"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_RLE** = `17`

Inserts start of right-to-left embedding (RLE) character.<a id="TextEdit_constant_MENU_INSERT_LRO"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_LRO** = `18`

Inserts start of left-to-right override (LRO) character.<a id="TextEdit_constant_MENU_INSERT_RLO"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_RLO** = `19`

Inserts start of right-to-left override (RLO) character.<a id="TextEdit_constant_MENU_INSERT_PDF"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_PDF** = `20`

Inserts pop direction formatting (PDF) character.<a id="TextEdit_constant_MENU_INSERT_ALM"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_ALM** = `21`

Inserts Arabic letter mark (ALM) character.<a id="TextEdit_constant_MENU_INSERT_LRI"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_LRI** = `22`

Inserts left-to-right isolate (LRI) character.<a id="TextEdit_constant_MENU_INSERT_RLI"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_RLI** = `23`

Inserts right-to-left isolate (RLI) character.<a id="TextEdit_constant_MENU_INSERT_FSI"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_FSI** = `24`

Inserts first strong isolate (FSI) character.<a id="TextEdit_constant_MENU_INSERT_PDI"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_PDI** = `25`

Inserts pop direction isolate (PDI) character.<a id="TextEdit_constant_MENU_INSERT_ZWJ"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_ZWJ** = `26`

Inserts zero width joiner (ZWJ) character.<a id="TextEdit_constant_MENU_INSERT_ZWNJ"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_ZWNJ** = `27`

Inserts zero width non-joiner (ZWNJ) character.<a id="TextEdit_constant_MENU_INSERT_WJ"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_WJ** = `28`

Inserts word joiner (WJ) character.<a id="TextEdit_constant_MENU_INSERT_SHY"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_INSERT_SHY** = `29`

Inserts soft hyphen (SHY) character.<a id="TextEdit_constant_MENU_EMOJI_AND_SYMBOL"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_EMOJI_AND_SYMBOL** = `30`

Opens system emoji and symbol picker.<a id="TextEdit_constant_MENU_MAX"></a>

<!-- classref-enumeration-constant -->

[MenuItems](TextEdit.md#enum_TextEdit_MenuItems) **MENU_MAX** = `31`

Represents the size of the [MenuItems](TextEdit.md#enum_TextEdit_MenuItems) enum.<hr class="classref-item-separator"/>

<a id="enum_TextEdit_EditAction"></a>

<!-- classref-enumeration -->

enum **EditAction**: [ðŸ”—](#enum_TextEdit_EditAction)

<a id="TextEdit_constant_ACTION_NONE"></a>

<!-- classref-enumeration-constant -->

[EditAction](TextEdit.md#enum_TextEdit_EditAction) **ACTION_NONE** = `0`

No current action.<a id="TextEdit_constant_ACTION_TYPING"></a>

<!-- classref-enumeration-constant -->

[EditAction](TextEdit.md#enum_TextEdit_EditAction) **ACTION_TYPING** = `1`

A typing action.<a id="TextEdit_constant_ACTION_BACKSPACE"></a>

<!-- classref-enumeration-constant -->

[EditAction](TextEdit.md#enum_TextEdit_EditAction) **ACTION_BACKSPACE** = `2`

A backwards delete action.<a id="TextEdit_constant_ACTION_DELETE"></a>

<!-- classref-enumeration-constant -->

[EditAction](TextEdit.md#enum_TextEdit_EditAction) **ACTION_DELETE** = `3`

A forward delete action.<hr class="classref-item-separator"/>

<a id="enum_TextEdit_SearchFlags"></a>

<!-- classref-enumeration -->

enum **SearchFlags**: [ðŸ”—](#enum_TextEdit_SearchFlags)

<a id="TextEdit_constant_SEARCH_MATCH_CASE"></a>

<!-- classref-enumeration-constant -->

[SearchFlags](TextEdit.md#enum_TextEdit_SearchFlags) **SEARCH_MATCH_CASE** = `1`

Match case when searching.<a id="TextEdit_constant_SEARCH_WHOLE_WORDS"></a>

<!-- classref-enumeration-constant -->

[SearchFlags](TextEdit.md#enum_TextEdit_SearchFlags) **SEARCH_WHOLE_WORDS** = `2`

Match whole words when searching.<a id="TextEdit_constant_SEARCH_BACKWARDS"></a>

<!-- classref-enumeration-constant -->

[SearchFlags](TextEdit.md#enum_TextEdit_SearchFlags) **SEARCH_BACKWARDS** = `4`

Search from end to beginning.<hr class="classref-item-separator"/>

<a id="enum_TextEdit_CaretType"></a>

<!-- classref-enumeration -->

enum **CaretType**: [ðŸ”—](#enum_TextEdit_CaretType)

<a id="TextEdit_constant_CARET_TYPE_LINE"></a>

<!-- classref-enumeration-constant -->

[CaretType](TextEdit.md#enum_TextEdit_CaretType) **CARET_TYPE_LINE** = `0`

Vertical line caret.<a id="TextEdit_constant_CARET_TYPE_BLOCK"></a>

<!-- classref-enumeration-constant -->

[CaretType](TextEdit.md#enum_TextEdit_CaretType) **CARET_TYPE_BLOCK** = `1`

Block caret.<hr class="classref-item-separator"/>

<a id="enum_TextEdit_SelectionMode"></a>

<!-- classref-enumeration -->

enum **SelectionMode**: [ðŸ”—](#enum_TextEdit_SelectionMode)

<a id="TextEdit_constant_SELECTION_MODE_NONE"></a>

<!-- classref-enumeration-constant -->

[SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode) **SELECTION_MODE_NONE** = `0`

Not selecting.<a id="TextEdit_constant_SELECTION_MODE_SHIFT"></a>

<!-- classref-enumeration-constant -->

[SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode) **SELECTION_MODE_SHIFT** = `1`

Select as if ``shift`` is pressed.<a id="TextEdit_constant_SELECTION_MODE_POINTER"></a>

<!-- classref-enumeration-constant -->

[SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode) **SELECTION_MODE_POINTER** = `2`

Select single characters as if the user single clicked.<a id="TextEdit_constant_SELECTION_MODE_WORD"></a>

<!-- classref-enumeration-constant -->

[SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode) **SELECTION_MODE_WORD** = `3`

Select whole words as if the user double clicked.<a id="TextEdit_constant_SELECTION_MODE_LINE"></a>

<!-- classref-enumeration-constant -->

[SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode) **SELECTION_MODE_LINE** = `4`

Select whole lines as if the user triple clicked.<hr class="classref-item-separator"/>

<a id="enum_TextEdit_LineWrappingMode"></a>

<!-- classref-enumeration -->

enum **LineWrappingMode**: [ðŸ”—](#enum_TextEdit_LineWrappingMode)

<a id="TextEdit_constant_LINE_WRAPPING_NONE"></a>

<!-- classref-enumeration-constant -->

[LineWrappingMode](TextEdit.md#enum_TextEdit_LineWrappingMode) **LINE_WRAPPING_NONE** = `0`

Line wrapping is disabled.<a id="TextEdit_constant_LINE_WRAPPING_BOUNDARY"></a>

<!-- classref-enumeration-constant -->

[LineWrappingMode](TextEdit.md#enum_TextEdit_LineWrappingMode) **LINE_WRAPPING_BOUNDARY** = `1`

Line wrapping occurs at the control boundary, beyond what would normally be visible.<hr class="classref-item-separator"/>

<a id="enum_TextEdit_GutterType"></a>

<!-- classref-enumeration -->

enum **GutterType**: [ðŸ”—](#enum_TextEdit_GutterType)

<a id="TextEdit_constant_GUTTER_TYPE_STRING"></a>

<!-- classref-enumeration-constant -->

[GutterType](TextEdit.md#enum_TextEdit_GutterType) **GUTTER_TYPE_STRING** = `0`

When a gutter is set to string using [set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type), it is used to contain text set via the [set_line_gutter_text()](TextEdit.md#TextEdit_method_set_line_gutter_text) method.<a id="TextEdit_constant_GUTTER_TYPE_ICON"></a>

<!-- classref-enumeration-constant -->

[GutterType](TextEdit.md#enum_TextEdit_GutterType) **GUTTER_TYPE_ICON** = `1`

When a gutter is set to icon using [set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type), it is used to contain an icon set via the [set_line_gutter_icon()](TextEdit.md#TextEdit_method_set_line_gutter_icon) method.<a id="TextEdit_constant_GUTTER_TYPE_CUSTOM"></a>

<!-- classref-enumeration-constant -->

[GutterType](TextEdit.md#enum_TextEdit_GutterType) **GUTTER_TYPE_CUSTOM** = `2`

When a gutter is set to custom using [set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type), it is used to contain custom visuals controlled by a callback method set via the [set_gutter_custom_draw()](TextEdit.md#TextEdit_method_set_gutter_custom_draw) method.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="TextEdit_property_autowrap_mode"></a>

<!-- classref-property -->

[AutowrapMode](TextServer.md#enum_TextServer_AutowrapMode) **autowrap_mode** = `3` [ðŸ”—](#TextEdit_property_autowrap_mode)

<!-- classref-property-setget -->

- `void` **set_autowrap_mode**\ (\ value\: [AutowrapMode](TextServer.md#enum_TextServer_AutowrapMode)\ )
- [AutowrapMode](TextServer.md#enum_TextServer_AutowrapMode) **get_autowrap_mode**\ (\ )

If [wrap_mode](TextEdit.md#TextEdit_property_wrap_mode) is set to [LINE_WRAPPING_BOUNDARY](TextEdit.md#TextEdit_constant_LINE_WRAPPING_BOUNDARY), sets text wrapping mode.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_backspace_deletes_composite_character_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **backspace_deletes_composite_character_enabled** = `false` [ðŸ”—](#TextEdit_property_backspace_deletes_composite_character_enabled)

<!-- classref-property-setget -->

- `void` **set_backspace_deletes_composite_character_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_backspace_deletes_composite_character_enabled**\ (\ )

If ``true`` and [caret_mid_grapheme](TextEdit.md#TextEdit_property_caret_mid_grapheme) is ``false``, backspace deletes an entire composite character such as â¤ï¸â€ðŸ©¹, instead of deleting part of the composite character.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_caret_blink"></a>

<!-- classref-property -->

[bool](bool.md) **caret_blink** = `false` [ðŸ”—](#TextEdit_property_caret_blink)

<!-- classref-property-setget -->

- `void` **set_caret_blink_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_caret_blink_enabled**\ (\ )

If ``true``, makes the caret blink.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_caret_blink_interval"></a>

<!-- classref-property -->

[float](float.md) **caret_blink_interval** = `0.65` [ðŸ”—](#TextEdit_property_caret_blink_interval)

<!-- classref-property-setget -->

- `void` **set_caret_blink_interval**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_caret_blink_interval**\ (\ )

The interval at which the caret blinks (in seconds).

<hr class="classref-item-separator"/>

<a id="TextEdit_property_caret_draw_when_editable_disabled"></a>

<!-- classref-property -->

[bool](bool.md) **caret_draw_when_editable_disabled** = `false` [ðŸ”—](#TextEdit_property_caret_draw_when_editable_disabled)

<!-- classref-property-setget -->

- `void` **set_draw_caret_when_editable_disabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_drawing_caret_when_editable_disabled**\ (\ )

If ``true``, caret will be visible when [editable](TextEdit.md#TextEdit_property_editable) is disabled.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_caret_mid_grapheme"></a>

<!-- classref-property -->

[bool](bool.md) **caret_mid_grapheme** = `false` [ðŸ”—](#TextEdit_property_caret_mid_grapheme)

<!-- classref-property-setget -->

- `void` **set_caret_mid_grapheme_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_caret_mid_grapheme_enabled**\ (\ )

Allow moving caret, selecting and removing the individual composite character components.

\ **Note:** :kbd:`Backspace` is always removing individual composite character components.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_caret_move_on_right_click"></a>

<!-- classref-property -->

[bool](bool.md) **caret_move_on_right_click** = `true` [ðŸ”—](#TextEdit_property_caret_move_on_right_click)

<!-- classref-property-setget -->

- `void` **set_move_caret_on_right_click_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_move_caret_on_right_click_enabled**\ (\ )

If ``true``, a right-click moves the caret at the mouse position before displaying the context menu.

If ``false``, the context menu ignores mouse location.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_caret_multiple"></a>

<!-- classref-property -->

[bool](bool.md) **caret_multiple** = `true` [ðŸ”—](#TextEdit_property_caret_multiple)

<!-- classref-property-setget -->

- `void` **set_multiple_carets_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_multiple_carets_enabled**\ (\ )

If ``true``, multiple carets are allowed. Left-clicking with :kbd:`Alt` adds a new caret. See [add_caret()](TextEdit.md#TextEdit_method_add_caret) and [get_caret_count()](TextEdit.md#TextEdit_method_get_caret_count).

<hr class="classref-item-separator"/>

<a id="TextEdit_property_caret_type"></a>

<!-- classref-property -->

[CaretType](TextEdit.md#enum_TextEdit_CaretType) **caret_type** = `0` [ðŸ”—](#TextEdit_property_caret_type)

<!-- classref-property-setget -->

- `void` **set_caret_type**\ (\ value\: [CaretType](TextEdit.md#enum_TextEdit_CaretType)\ )
- [CaretType](TextEdit.md#enum_TextEdit_CaretType) **get_caret_type**\ (\ )

Set the type of caret to draw.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_context_menu_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **context_menu_enabled** = `true` [ðŸ”—](#TextEdit_property_context_menu_enabled)

<!-- classref-property-setget -->

- `void` **set_context_menu_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_context_menu_enabled**\ (\ )

If ``true``, a right-click displays the context menu.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_custom_word_separators"></a>

<!-- classref-property -->

[String](String.md) **custom_word_separators** = `""` [ðŸ”—](#TextEdit_property_custom_word_separators)

<!-- classref-property-setget -->

- `void` **set_custom_word_separators**\ (\ value\: [String](String.md)\ )
- [String](String.md) **get_custom_word_separators**\ (\ )

The characters to consider as word delimiters if [use_custom_word_separators](TextEdit.md#TextEdit_property_use_custom_word_separators) is ``true``. The characters should be defined without separation, for example ``#_!``.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_deselect_on_focus_loss_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **deselect_on_focus_loss_enabled** = `true` [ðŸ”—](#TextEdit_property_deselect_on_focus_loss_enabled)

<!-- classref-property-setget -->

- `void` **set_deselect_on_focus_loss_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_deselect_on_focus_loss_enabled**\ (\ )

If ``true``, the selected text will be deselected when focus is lost.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_drag_and_drop_selection_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **drag_and_drop_selection_enabled** = `true` [ðŸ”—](#TextEdit_property_drag_and_drop_selection_enabled)

<!-- classref-property-setget -->

- `void` **set_drag_and_drop_selection_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_drag_and_drop_selection_enabled**\ (\ )

If ``true``, allow drag and drop of selected text. Text can still be dropped from other sources.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_draw_control_chars"></a>

<!-- classref-property -->

[bool](bool.md) **draw_control_chars** = `false` [ðŸ”—](#TextEdit_property_draw_control_chars)

<!-- classref-property-setget -->

- `void` **set_draw_control_chars**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_draw_control_chars**\ (\ )

If ``true``, control characters are displayed.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_draw_spaces"></a>

<!-- classref-property -->

[bool](bool.md) **draw_spaces** = `false` [ðŸ”—](#TextEdit_property_draw_spaces)

<!-- classref-property-setget -->

- `void` **set_draw_spaces**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_drawing_spaces**\ (\ )

If ``true``, the "space" character will have a visible representation.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_draw_tabs"></a>

<!-- classref-property -->

[bool](bool.md) **draw_tabs** = `false` [ðŸ”—](#TextEdit_property_draw_tabs)

<!-- classref-property-setget -->

- `void` **set_draw_tabs**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_drawing_tabs**\ (\ )

If ``true``, the "tab" character will have a visible representation.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_editable"></a>

<!-- classref-property -->

[bool](bool.md) **editable** = `true` [ðŸ”—](#TextEdit_property_editable)

<!-- classref-property-setget -->

- `void` **set_editable**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_editable**\ (\ )

If ``false``, existing text cannot be modified and new text cannot be added.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_emoji_menu_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **emoji_menu_enabled** = `true` [ðŸ”—](#TextEdit_property_emoji_menu_enabled)

<!-- classref-property-setget -->

- `void` **set_emoji_menu_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_emoji_menu_enabled**\ (\ )

If ``true``, "Emoji and Symbols" menu is enabled.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_empty_selection_clipboard_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **empty_selection_clipboard_enabled** = `true` [ðŸ”—](#TextEdit_property_empty_selection_clipboard_enabled)

<!-- classref-property-setget -->

- `void` **set_empty_selection_clipboard_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_empty_selection_clipboard_enabled**\ (\ )

If ``true``, copying or cutting without a selection is performed on all lines with a caret. Otherwise, copy and cut require a selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_highlight_all_occurrences"></a>

<!-- classref-property -->

[bool](bool.md) **highlight_all_occurrences** = `false` [ðŸ”—](#TextEdit_property_highlight_all_occurrences)

<!-- classref-property-setget -->

- `void` **set_highlight_all_occurrences**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_highlight_all_occurrences_enabled**\ (\ )

If ``true``, all occurrences of the selected text will be highlighted.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_highlight_current_line"></a>

<!-- classref-property -->

[bool](bool.md) **highlight_current_line** = `false` [ðŸ”—](#TextEdit_property_highlight_current_line)

<!-- classref-property-setget -->

- `void` **set_highlight_current_line**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_highlight_current_line_enabled**\ (\ )

If ``true``, the line containing the cursor is highlighted.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_indent_wrapped_lines"></a>

<!-- classref-property -->

[bool](bool.md) **indent_wrapped_lines** = `false` [ðŸ”—](#TextEdit_property_indent_wrapped_lines)

<!-- classref-property-setget -->

- `void` **set_indent_wrapped_lines**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_indent_wrapped_lines**\ (\ )

If ``true``, all wrapped lines are indented to the same amount as the unwrapped line.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_language"></a>

<!-- classref-property -->

[String](String.md) **language** = `""` [ðŸ”—](#TextEdit_property_language)

<!-- classref-property-setget -->

- `void` **set_language**\ (\ value\: [String](String.md)\ )
- [String](String.md) **get_language**\ (\ )

Language code used for line-breaking and text shaping algorithms, if left empty current locale is used instead.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_middle_mouse_paste_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **middle_mouse_paste_enabled** = `true` [ðŸ”—](#TextEdit_property_middle_mouse_paste_enabled)

<!-- classref-property-setget -->

- `void` **set_middle_mouse_paste_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_middle_mouse_paste_enabled**\ (\ )

If ``false``, using middle mouse button to paste clipboard will be disabled.

\ **Note:** This method is only implemented on Linux.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_minimap_draw"></a>

<!-- classref-property -->

[bool](bool.md) **minimap_draw** = `false` [ðŸ”—](#TextEdit_property_minimap_draw)

<!-- classref-property-setget -->

- `void` **set_draw_minimap**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_drawing_minimap**\ (\ )

If ``true``, a minimap is shown, providing an outline of your source code. The minimap uses a fixed-width text size.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_minimap_width"></a>

<!-- classref-property -->

[int](int.md) **minimap_width** = `80` [ðŸ”—](#TextEdit_property_minimap_width)

<!-- classref-property-setget -->

- `void` **set_minimap_width**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_minimap_width**\ (\ )

The width, in pixels, of the minimap.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_placeholder_text"></a>

<!-- classref-property -->

[String](String.md) **placeholder_text** = `""` [ðŸ”—](#TextEdit_property_placeholder_text)

<!-- classref-property-setget -->

- `void` **set_placeholder**\ (\ value\: [String](String.md)\ )
- [String](String.md) **get_placeholder**\ (\ )

Text shown when the **TextEdit** is empty. It is **not** the **TextEdit**'s default value (see [text](TextEdit.md#TextEdit_property_text)).

<hr class="classref-item-separator"/>

<a id="TextEdit_property_scroll_fit_content_height"></a>

<!-- classref-property -->

[bool](bool.md) **scroll_fit_content_height** = `false` [ðŸ”—](#TextEdit_property_scroll_fit_content_height)

<!-- classref-property-setget -->

- `void` **set_fit_content_height_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_fit_content_height_enabled**\ (\ )

If ``true``, **TextEdit** will disable vertical scroll and fit minimum height to the number of visible lines. When both this property and [scroll_fit_content_width](TextEdit.md#TextEdit_property_scroll_fit_content_width) are ``true``, no scrollbars will be displayed.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_scroll_fit_content_width"></a>

<!-- classref-property -->

[bool](bool.md) **scroll_fit_content_width** = `false` [ðŸ”—](#TextEdit_property_scroll_fit_content_width)

<!-- classref-property-setget -->

- `void` **set_fit_content_width_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_fit_content_width_enabled**\ (\ )

If ``true``, **TextEdit** will disable horizontal scroll and fit minimum width to the widest line in the text. When both this property and [scroll_fit_content_height](TextEdit.md#TextEdit_property_scroll_fit_content_height) are ``true``, no scrollbars will be displayed.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_scroll_horizontal"></a>

<!-- classref-property -->

[int](int.md) **scroll_horizontal** = `0` [ðŸ”—](#TextEdit_property_scroll_horizontal)

<!-- classref-property-setget -->

- `void` **set_h_scroll**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_h_scroll**\ (\ )

If there is a horizontal scrollbar, this determines the current horizontal scroll value in pixels.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_scroll_past_end_of_file"></a>

<!-- classref-property -->

[bool](bool.md) **scroll_past_end_of_file** = `false` [ðŸ”—](#TextEdit_property_scroll_past_end_of_file)

<!-- classref-property-setget -->

- `void` **set_scroll_past_end_of_file_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_scroll_past_end_of_file_enabled**\ (\ )

Allow scrolling past the last line into "virtual" space.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_scroll_smooth"></a>

<!-- classref-property -->

[bool](bool.md) **scroll_smooth** = `false` [ðŸ”—](#TextEdit_property_scroll_smooth)

<!-- classref-property-setget -->

- `void` **set_smooth_scroll_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_smooth_scroll_enabled**\ (\ )

Scroll smoothly over the text rather than jumping to the next location.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_scroll_v_scroll_speed"></a>

<!-- classref-property -->

[float](float.md) **scroll_v_scroll_speed** = `80.0` [ðŸ”—](#TextEdit_property_scroll_v_scroll_speed)

<!-- classref-property-setget -->

- `void` **set_v_scroll_speed**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_v_scroll_speed**\ (\ )

Sets the scroll speed with the minimap or when [scroll_smooth](TextEdit.md#TextEdit_property_scroll_smooth) is enabled.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_scroll_vertical"></a>

<!-- classref-property -->

[float](float.md) **scroll_vertical** = `0.0` [ðŸ”—](#TextEdit_property_scroll_vertical)

<!-- classref-property-setget -->

- `void` **set_v_scroll**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_v_scroll**\ (\ )

If there is a vertical scrollbar, this determines the current vertical scroll value in line numbers, starting at 0 for the top line.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_selecting_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **selecting_enabled** = `true` [ðŸ”—](#TextEdit_property_selecting_enabled)

<!-- classref-property-setget -->

- `void` **set_selecting_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_selecting_enabled**\ (\ )

If ``true``, text can be selected.

If ``false``, text can not be selected by the user or by the [select()](TextEdit.md#TextEdit_method_select) or [select_all()](TextEdit.md#TextEdit_method_select_all) methods.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_shortcut_keys_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **shortcut_keys_enabled** = `true` [ðŸ”—](#TextEdit_property_shortcut_keys_enabled)

<!-- classref-property-setget -->

- `void` **set_shortcut_keys_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_shortcut_keys_enabled**\ (\ )

If ``true``, shortcut keys for context menu items are enabled, even if the context menu is disabled.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_structured_text_bidi_override"></a>

<!-- classref-property -->

[StructuredTextParser](TextServer.md#enum_TextServer_StructuredTextParser) **structured_text_bidi_override** = `0` [ðŸ”—](#TextEdit_property_structured_text_bidi_override)

<!-- classref-property-setget -->

- `void` **set_structured_text_bidi_override**\ (\ value\: [StructuredTextParser](TextServer.md#enum_TextServer_StructuredTextParser)\ )
- [StructuredTextParser](TextServer.md#enum_TextServer_StructuredTextParser) **get_structured_text_bidi_override**\ (\ )

Set BiDi algorithm override for the structured text.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_structured_text_bidi_override_options"></a>

<!-- classref-property -->

[Array](Array.md) **structured_text_bidi_override_options** = `[]` [ðŸ”—](#TextEdit_property_structured_text_bidi_override_options)

<!-- classref-property-setget -->

- `void` **set_structured_text_bidi_override_options**\ (\ value\: [Array](Array.md)\ )
- [Array](Array.md) **get_structured_text_bidi_override_options**\ (\ )

Set additional options for BiDi override.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_syntax_highlighter"></a>

<!-- classref-property -->

[SyntaxHighlighter](SyntaxHighlighter.md) **syntax_highlighter** [ðŸ”—](#TextEdit_property_syntax_highlighter)

<!-- classref-property-setget -->

- `void` **set_syntax_highlighter**\ (\ value\: [SyntaxHighlighter](SyntaxHighlighter.md)\ )
- [SyntaxHighlighter](SyntaxHighlighter.md) **get_syntax_highlighter**\ (\ )

The syntax highlighter to use.

\ **Note:** A [SyntaxHighlighter](SyntaxHighlighter.md) instance should not be used across multiple **TextEdit** nodes.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_tab_input_mode"></a>

<!-- classref-property -->

[bool](bool.md) **tab_input_mode** = `true` [ðŸ”—](#TextEdit_property_tab_input_mode)

<!-- classref-property-setget -->

- `void` **set_tab_input_mode**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_tab_input_mode**\ (\ )

If ``true``, [ProjectSettings.input/ui_text_indent](ProjectSettings.md#ProjectSettings_property_input/ui_text_indent) input ``Tab`` character, otherwise it moves keyboard focus to the next [Control](Control.md) in the scene.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_text"></a>

<!-- classref-property -->

[String](String.md) **text** = `""` [ðŸ”—](#TextEdit_property_text)

<!-- classref-property-setget -->

- `void` **set_text**\ (\ value\: [String](String.md)\ )
- [String](String.md) **get_text**\ (\ )

String value of the **TextEdit**.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_text_direction"></a>

<!-- classref-property -->

[TextDirection](Control.md#enum_Control_TextDirection) **text_direction** = `0` [ðŸ”—](#TextEdit_property_text_direction)

<!-- classref-property-setget -->

- `void` **set_text_direction**\ (\ value\: [TextDirection](Control.md#enum_Control_TextDirection)\ )
- [TextDirection](Control.md#enum_Control_TextDirection) **get_text_direction**\ (\ )

Base text writing direction.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_use_custom_word_separators"></a>

<!-- classref-property -->

[bool](bool.md) **use_custom_word_separators** = `false` [ðŸ”—](#TextEdit_property_use_custom_word_separators)

<!-- classref-property-setget -->

- `void` **set_use_custom_word_separators**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_custom_word_separators_enabled**\ (\ )

If ``false``, using :kbd:`Ctrl + Left` or :kbd:`Ctrl + Right` (:kbd:`Cmd + Left` or :kbd:`Cmd + Right` on macOS) bindings will use the behavior of [use_default_word_separators](TextEdit.md#TextEdit_property_use_default_word_separators). If ``true``, it will also stop the caret if a character within [custom_word_separators](TextEdit.md#TextEdit_property_custom_word_separators) is detected. Useful for subword moving. This behavior also will be applied to the behavior of text selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_use_default_word_separators"></a>

<!-- classref-property -->

[bool](bool.md) **use_default_word_separators** = `true` [ðŸ”—](#TextEdit_property_use_default_word_separators)

<!-- classref-property-setget -->

- `void` **set_use_default_word_separators**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_default_word_separators_enabled**\ (\ )

If ``false``, using :kbd:`Ctrl + Left` or :kbd:`Ctrl + Right` (:kbd:`Cmd + Left` or :kbd:`Cmd + Right` on macOS) bindings will stop moving caret only if a space or punctuation is detected. If ``true``, it will also stop the caret if a character is part of ``!"#$%&'()*+,-./:;&lt;=&gt;?@[\]^`{|}~``, the Unicode General Punctuation table, or the Unicode CJK Punctuation table. Useful for subword moving. This behavior also will be applied to the behavior of text selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_virtual_keyboard_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **virtual_keyboard_enabled** = `true` [ðŸ”—](#TextEdit_property_virtual_keyboard_enabled)

<!-- classref-property-setget -->

- `void` **set_virtual_keyboard_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_virtual_keyboard_enabled**\ (\ )

If ``true``, the native virtual keyboard is enabled on platforms that support it.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_virtual_keyboard_show_on_focus"></a>

<!-- classref-property -->

[bool](bool.md) **virtual_keyboard_show_on_focus** = `true` [ðŸ”—](#TextEdit_property_virtual_keyboard_show_on_focus)

<!-- classref-property-setget -->

- `void` **set_virtual_keyboard_show_on_focus**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_virtual_keyboard_show_on_focus**\ (\ )

If ``true``, the native virtual keyboard is shown on focus events on platforms that support it.

<hr class="classref-item-separator"/>

<a id="TextEdit_property_wrap_mode"></a>

<!-- classref-property -->

[LineWrappingMode](TextEdit.md#enum_TextEdit_LineWrappingMode) **wrap_mode** = `0` [ðŸ”—](#TextEdit_property_wrap_mode)

<!-- classref-property-setget -->

- `void` **set_line_wrapping_mode**\ (\ value\: [LineWrappingMode](TextEdit.md#enum_TextEdit_LineWrappingMode)\ )
- [LineWrappingMode](TextEdit.md#enum_TextEdit_LineWrappingMode) **get_line_wrapping_mode**\ (\ )

Sets the line wrapping mode to use.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="TextEdit_private_method__backspace"></a>

<!-- classref-method -->

`void` **_backspace**\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span> [ðŸ”—](#TextEdit_private_method__backspace)

Override this method to define what happens when the user presses the backspace key.

<hr class="classref-item-separator"/>

<a id="TextEdit_private_method__copy"></a>

<!-- classref-method -->

`void` **_copy**\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span> [ðŸ”—](#TextEdit_private_method__copy)

Override this method to define what happens when the user performs a copy operation.

<hr class="classref-item-separator"/>

<a id="TextEdit_private_method__cut"></a>

<!-- classref-method -->

`void` **_cut**\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span> [ðŸ”—](#TextEdit_private_method__cut)

Override this method to define what happens when the user performs a cut operation.

<hr class="classref-item-separator"/>

<a id="TextEdit_private_method__handle_unicode_input"></a>

<!-- classref-method -->

`void` **_handle_unicode_input**\ (\ unicode_char\: [int](int.md), caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span> [ðŸ”—](#TextEdit_private_method__handle_unicode_input)

Override this method to define what happens when the user types in the provided key `unicode_char`.

<hr class="classref-item-separator"/>

<a id="TextEdit_private_method__paste"></a>

<!-- classref-method -->

`void` **_paste**\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span> [ðŸ”—](#TextEdit_private_method__paste)

Override this method to define what happens when the user performs a paste operation.

<hr class="classref-item-separator"/>

<a id="TextEdit_private_method__paste_primary_clipboard"></a>

<!-- classref-method -->

`void` **_paste_primary_clipboard**\ (\ caret_index\: [int](int.md)\ ) <span class="virtual">virtual</span> [ðŸ”—](#TextEdit_private_method__paste_primary_clipboard)

Override this method to define what happens when the user performs a paste operation with middle mouse button.

\ **Note:** This method is only implemented on Linux.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_add_caret"></a>

<!-- classref-method -->

[int](int.md) **add_caret**\ (\ line\: [int](int.md), column\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_add_caret)

Adds a new caret at the given location. Returns the index of the new caret, or ``-1`` if the location is invalid.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_add_caret_at_carets"></a>

<!-- classref-method -->

`void` **add_caret_at_carets**\ (\ below\: [bool](bool.md)\ ) [ðŸ”—](#TextEdit_method_add_caret_at_carets)

Adds an additional caret above or below every caret. If `below` is ``true`` the new caret will be added below and above otherwise.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_add_gutter"></a>

<!-- classref-method -->

`void` **add_gutter**\ (\ at\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_add_gutter)

Register a new gutter to this **TextEdit**. Use `at` to have a specific gutter order. A value of ``-1`` appends the gutter to the right.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_add_selection_for_next_occurrence"></a>

<!-- classref-method -->

`void` **add_selection_for_next_occurrence**\ (\ ) [ðŸ”—](#TextEdit_method_add_selection_for_next_occurrence)

Adds a selection and a caret for the next occurrence of the current selection. If there is no active selection, selects word under caret.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_adjust_carets_after_edit"></a>

<!-- classref-method -->

`void` **adjust_carets_after_edit**\ (\ caret\: [int](int.md), from_line\: [int](int.md), from_col\: [int](int.md), to_line\: [int](int.md), to_col\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_adjust_carets_after_edit)

**Deprecated:** No longer necessary since methods now adjust carets themselves.

This method does nothing.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_adjust_viewport_to_caret"></a>

<!-- classref-method -->

`void` **adjust_viewport_to_caret**\ (\ caret_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_adjust_viewport_to_caret)

Adjust the viewport so the caret is visible.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_apply_ime"></a>

<!-- classref-method -->

`void` **apply_ime**\ (\ ) [ðŸ”—](#TextEdit_method_apply_ime)

Applies text from the [Input Method Editor](https://en.wikipedia.org/wiki/Input_method) (IME) to each caret and closes the IME if it is open.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_backspace"></a>

<!-- classref-method -->

`void` **backspace**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_backspace)

Called when the user presses the backspace key. Can be overridden with [_backspace()](TextEdit.md#TextEdit_private_method__backspace).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_begin_complex_operation"></a>

<!-- classref-method -->

`void` **begin_complex_operation**\ (\ ) [ðŸ”—](#TextEdit_method_begin_complex_operation)

Starts a multipart edit. All edits will be treated as one action until [end_complex_operation()](TextEdit.md#TextEdit_method_end_complex_operation) is called.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_begin_multicaret_edit"></a>

<!-- classref-method -->

`void` **begin_multicaret_edit**\ (\ ) [ðŸ”—](#TextEdit_method_begin_multicaret_edit)

Starts an edit for multiple carets. The edit must be ended with [end_multicaret_edit()](TextEdit.md#TextEdit_method_end_multicaret_edit). Multicaret edits can be used to edit text at multiple carets and delay merging the carets until the end, so the caret indexes aren't affected immediately. [begin_multicaret_edit()](TextEdit.md#TextEdit_method_begin_multicaret_edit) and [end_multicaret_edit()](TextEdit.md#TextEdit_method_end_multicaret_edit) can be nested, and the merge will happen at the last [end_multicaret_edit()](TextEdit.md#TextEdit_method_end_multicaret_edit).

```
    begin_complex_operation()
    begin_multicaret_edit()
    for i in range(get_caret_count()):
        if multicaret_edit_ignore_caret(i):
            continue
        # Logic here.
    end_multicaret_edit()
    end_complex_operation()
```


<hr class="classref-item-separator"/>

<a id="TextEdit_method_cancel_ime"></a>

<!-- classref-method -->

`void` **cancel_ime**\ (\ ) [ðŸ”—](#TextEdit_method_cancel_ime)

Closes the [Input Method Editor](https://en.wikipedia.org/wiki/Input_method) (IME) if it is open. Any text in the IME will be lost.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_center_viewport_to_caret"></a>

<!-- classref-method -->

`void` **center_viewport_to_caret**\ (\ caret_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_center_viewport_to_caret)

Centers the viewport on the line the editing caret is at. This also resets the [scroll_horizontal](TextEdit.md#TextEdit_property_scroll_horizontal) value to ``0``.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_clear"></a>

<!-- classref-method -->

`void` **clear**\ (\ ) [ðŸ”—](#TextEdit_method_clear)

Performs a full reset of **TextEdit**, including undo history.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_clear_undo_history"></a>

<!-- classref-method -->

`void` **clear_undo_history**\ (\ ) [ðŸ”—](#TextEdit_method_clear_undo_history)

Clears the undo history.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_collapse_carets"></a>

<!-- classref-method -->

`void` **collapse_carets**\ (\ from_line\: [int](int.md), from_column\: [int](int.md), to_line\: [int](int.md), to_column\: [int](int.md), inclusive\: [bool](bool.md) = false\ ) [ðŸ”—](#TextEdit_method_collapse_carets)

Collapse all carets in the given range to the `from_line` and `from_column` position.

\ `inclusive` applies to both ends.

If [is_in_mulitcaret_edit()](TextEdit.md#TextEdit_method_is_in_mulitcaret_edit) is ``true``, carets that are collapsed will be ``true`` for [multicaret_edit_ignore_caret()](TextEdit.md#TextEdit_method_multicaret_edit_ignore_caret).

\ [merge_overlapping_carets()](TextEdit.md#TextEdit_method_merge_overlapping_carets) will be called if any carets were collapsed.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_copy"></a>

<!-- classref-method -->

`void` **copy**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_copy)

Copies the current text selection. Can be overridden with [_copy()](TextEdit.md#TextEdit_private_method__copy).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_cut"></a>

<!-- classref-method -->

`void` **cut**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_cut)

Cut's the current selection. Can be overridden with [_cut()](TextEdit.md#TextEdit_private_method__cut).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_delete_selection"></a>

<!-- classref-method -->

`void` **delete_selection**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_delete_selection)

Deletes the selected text.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_deselect"></a>

<!-- classref-method -->

`void` **deselect**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_deselect)

Deselects the current selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_end_action"></a>

<!-- classref-method -->

`void` **end_action**\ (\ ) [ðŸ”—](#TextEdit_method_end_action)

Marks the end of steps in the current action started with [start_action()](TextEdit.md#TextEdit_method_start_action).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_end_complex_operation"></a>

<!-- classref-method -->

`void` **end_complex_operation**\ (\ ) [ðŸ”—](#TextEdit_method_end_complex_operation)

Ends a multipart edit, started with [begin_complex_operation()](TextEdit.md#TextEdit_method_begin_complex_operation). If called outside a complex operation, the current operation is pushed onto the undo/redo stack.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_end_multicaret_edit"></a>

<!-- classref-method -->

`void` **end_multicaret_edit**\ (\ ) [ðŸ”—](#TextEdit_method_end_multicaret_edit)

Ends an edit for multiple carets, that was started with [begin_multicaret_edit()](TextEdit.md#TextEdit_method_begin_multicaret_edit). If this was the last [end_multicaret_edit()](TextEdit.md#TextEdit_method_end_multicaret_edit) and [merge_overlapping_carets()](TextEdit.md#TextEdit_method_merge_overlapping_carets) was called, carets will be merged.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_caret_column"></a>

<!-- classref-method -->

[int](int.md) **get_caret_column**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_caret_column)

Returns the column the editing caret is at.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_caret_count"></a>

<!-- classref-method -->

[int](int.md) **get_caret_count**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_caret_count)

Returns the number of carets in this **TextEdit**.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_caret_draw_pos"></a>

<!-- classref-method -->

[Vector2](Vector2.md) **get_caret_draw_pos**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_caret_draw_pos)

Returns the caret pixel draw position.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_caret_index_edit_order"></a>

<!-- classref-method -->

[PackedInt32Array](PackedInt32Array.md) **get_caret_index_edit_order**\ (\ ) [ðŸ”—](#TextEdit_method_get_caret_index_edit_order)

**Deprecated:** Carets no longer need to be edited in any specific order. If the carets need to be sorted, use [get_sorted_carets()](TextEdit.md#TextEdit_method_get_sorted_carets) instead.

Returns a list of caret indexes in their edit order, this done from bottom to top. Edit order refers to the way actions such as [insert_text_at_caret()](TextEdit.md#TextEdit_method_insert_text_at_caret) are applied.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_caret_line"></a>

<!-- classref-method -->

[int](int.md) **get_caret_line**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_caret_line)

Returns the line the editing caret is on.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_caret_wrap_index"></a>

<!-- classref-method -->

[int](int.md) **get_caret_wrap_index**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_caret_wrap_index)

Returns the wrap index the editing caret is on.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_first_non_whitespace_column"></a>

<!-- classref-method -->

[int](int.md) **get_first_non_whitespace_column**\ (\ line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_first_non_whitespace_column)

Returns the first column containing a non-whitespace character on the given line. If there is only whitespace, returns the number of characters.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_first_visible_line"></a>

<!-- classref-method -->

[int](int.md) **get_first_visible_line**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_first_visible_line)

Returns the first visible line.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_gutter_count"></a>

<!-- classref-method -->

[int](int.md) **get_gutter_count**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_gutter_count)

Returns the number of gutters registered.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_gutter_name"></a>

<!-- classref-method -->

[String](String.md) **get_gutter_name**\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_gutter_name)

Returns the name of the gutter at the given index.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_gutter_type"></a>

<!-- classref-method -->

[GutterType](TextEdit.md#enum_TextEdit_GutterType) **get_gutter_type**\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_gutter_type)

Returns the type of the gutter at the given index. Gutters can contain icons, text, or custom visuals.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_gutter_width"></a>

<!-- classref-method -->

[int](int.md) **get_gutter_width**\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_gutter_width)

Returns the width of the gutter at the given index.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_h_scroll_bar"></a>

<!-- classref-method -->

[HScrollBar](HScrollBar.md) **get_h_scroll_bar**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_h_scroll_bar)

Returns the [HScrollBar](HScrollBar.md) used by **TextEdit**.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_indent_level"></a>

<!-- classref-method -->

[int](int.md) **get_indent_level**\ (\ line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_indent_level)

Returns the indent level of the given line. This is the number of spaces and tabs at the beginning of the line, with the tabs taking the tab size into account (see [get_tab_size()](TextEdit.md#TextEdit_method_get_tab_size)).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_last_full_visible_line"></a>

<!-- classref-method -->

[int](int.md) **get_last_full_visible_line**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_last_full_visible_line)

Returns the last visible line. Use [get_last_full_visible_line_wrap_index()](TextEdit.md#TextEdit_method_get_last_full_visible_line_wrap_index) for the wrap index.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_last_full_visible_line_wrap_index"></a>

<!-- classref-method -->

[int](int.md) **get_last_full_visible_line_wrap_index**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_last_full_visible_line_wrap_index)

Returns the last visible wrap index of the last visible line.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_last_unhidden_line"></a>

<!-- classref-method -->

[int](int.md) **get_last_unhidden_line**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_last_unhidden_line)

Returns the last unhidden line in the entire **TextEdit**.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line"></a>

<!-- classref-method -->

[String](String.md) **get_line**\ (\ line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line)

Returns the text of a specific line.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_background_color"></a>

<!-- classref-method -->

[Color](Color.md) **get_line_background_color**\ (\ line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_background_color)

Returns the custom background color of the given line. If no color is set, returns ``Color(0, 0, 0, 0)``.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_column_at_pos"></a>

<!-- classref-method -->

[Vector2i](Vector2i.md) **get_line_column_at_pos**\ (\ position\: [Vector2i](Vector2i.md), clamp_line\: [bool](bool.md) = true, clamp_column\: [bool](bool.md) = true\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_column_at_pos)

Returns the line and column at the given position. In the returned vector, ``x`` is the column and ``y`` is the line.

If `clamp_line` is ``false`` and `position` is below the last line, ``Vector2i(-1, -1)`` is returned.

If `clamp_column` is ``false`` and `position` is outside the column range of the line, ``Vector2i(-1, -1)`` is returned.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_count"></a>

<!-- classref-method -->

[int](int.md) **get_line_count**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_count)

Returns the number of lines in the text.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_gutter_icon"></a>

<!-- classref-method -->

[Texture2D](Texture2D.md) **get_line_gutter_icon**\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_gutter_icon)

Returns the icon currently in `gutter` at `line`. This only works when the gutter type is [GUTTER_TYPE_ICON](TextEdit.md#TextEdit_constant_GUTTER_TYPE_ICON) (see [set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type)).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_gutter_item_color"></a>

<!-- classref-method -->

[Color](Color.md) **get_line_gutter_item_color**\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_gutter_item_color)

Returns the color currently in `gutter` at `line`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_gutter_metadata"></a>

<!-- classref-method -->

[Variant](Variant.md) **get_line_gutter_metadata**\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_gutter_metadata)

Returns the metadata currently in `gutter` at `line`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_gutter_text"></a>

<!-- classref-method -->

[String](String.md) **get_line_gutter_text**\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_gutter_text)

Returns the text currently in `gutter` at `line`. This only works when the gutter type is [GUTTER_TYPE_STRING](TextEdit.md#TextEdit_constant_GUTTER_TYPE_STRING) (see [set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type)).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_height"></a>

<!-- classref-method -->

[int](int.md) **get_line_height**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_height)

Returns the maximum value of the line height among all lines.

\ **Note:** The return value is influenced by [line_spacing](TextEdit.md#TextEdit_theme_constant_line_spacing) and [font_size](TextEdit.md#TextEdit_theme_font_size_font_size). And it will not be less than ``1``.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_ranges_from_carets"></a>

<!-- classref-method -->

[Array](Array.md)\[[Vector2i](Vector2i.md)\] **get_line_ranges_from_carets**\ (\ only_selections\: [bool](bool.md) = false, merge_adjacent\: [bool](bool.md) = true\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_ranges_from_carets)

Returns an [Array](Array.md) of line ranges where ``x`` is the first line and ``y`` is the last line. All lines within these ranges will have a caret on them or be part of a selection. Each line will only be part of one line range, even if it has multiple carets on it.

If a selection's end column ([get_selection_to_column()](TextEdit.md#TextEdit_method_get_selection_to_column)) is at column ``0``, that line will not be included. If a selection begins on the line after another selection ends and `merge_adjacent` is ``true``, or they begin and end on the same line, one line range will include both selections.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_width"></a>

<!-- classref-method -->

[int](int.md) **get_line_width**\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = -1\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_width)

Returns the width in pixels of the `wrap_index` on `line`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_with_ime"></a>

<!-- classref-method -->

[String](String.md) **get_line_with_ime**\ (\ line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_with_ime)

Returns line text as it is currently displayed, including IME composition string.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_wrap_count"></a>

<!-- classref-method -->

[int](int.md) **get_line_wrap_count**\ (\ line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_wrap_count)

Returns the number of times the given line is wrapped.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_wrap_index_at_column"></a>

<!-- classref-method -->

[int](int.md) **get_line_wrap_index_at_column**\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_wrap_index_at_column)

Returns the wrap index of the given column on the given line. This ranges from ``0`` to [get_line_wrap_count()](TextEdit.md#TextEdit_method_get_line_wrap_count).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_line_wrapped_text"></a>

<!-- classref-method -->

[PackedStringArray](PackedStringArray.md) **get_line_wrapped_text**\ (\ line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_line_wrapped_text)

Returns an array of [String](String.md)\\ s representing each wrapped index.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_local_mouse_pos"></a>

<!-- classref-method -->

[Vector2](Vector2.md) **get_local_mouse_pos**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_local_mouse_pos)

Returns the local mouse position adjusted for the text direction.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_menu"></a>

<!-- classref-method -->

[PopupMenu](PopupMenu.md) **get_menu**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_menu)

Returns the [PopupMenu](PopupMenu.md) of this **TextEdit**. By default, this menu is displayed when right-clicking on the **TextEdit**.

You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see [MenuItems](TextEdit.md#enum_TextEdit_MenuItems)). For example:




```gdscript
    func _ready():
        var menu = get_menu()
        # Remove all items after "Redo".
        menu.item_count = menu.get_item_index(MENU_REDO) + 1
        # Add custom items.
        menu.add_separator()
        menu.add_item("Insert Date", MENU_MAX + 1)
        # Connect callback.
        menu.id_pressed.connect(_on_item_pressed)

    func _on_item_pressed(id):
        if id == MENU_MAX + 1:
            insert_text_at_caret(Time.get_date_string_from_system())
```


```csharp
    public override void _Ready()
    {
        var menu = GetMenu();
        // Remove all items after "Redo".
        menu.ItemCount = menu.GetItemIndex(TextEdit.MenuItems.Redo) + 1;
        // Add custom items.
        menu.AddSeparator();
        menu.AddItem("Insert Date", TextEdit.MenuItems.Max + 1);
        // Add event handler.
        menu.IdPressed += OnItemPressed;
    }

    public void OnItemPressed(int id)
    {
        if (id == TextEdit.MenuItems.Max + 1)
        {
            InsertTextAtCaret(Time.GetDateStringFromSystem());
        }
    }
```




\ **Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [Window.visible](Window.md#Window_property_visible) property.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_minimap_line_at_pos"></a>

<!-- classref-method -->

[int](int.md) **get_minimap_line_at_pos**\ (\ position\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_minimap_line_at_pos)

Returns the equivalent minimap line at `position`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_minimap_visible_lines"></a>

<!-- classref-method -->

[int](int.md) **get_minimap_visible_lines**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_minimap_visible_lines)

Returns the number of lines that may be drawn on the minimap.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_next_composite_character_column"></a>

<!-- classref-method -->

[int](int.md) **get_next_composite_character_column**\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_next_composite_character_column)

Returns the correct column at the end of a composite character like â¤ï¸â€ðŸ©¹ (mending heart; Unicode: ``U+2764 U+FE0F U+200D U+1FA79``) which is comprised of more than one Unicode code point, if the caret is at the start of the composite character. Also returns the correct column with the caret at mid grapheme and for non-composite characters.

\ **Note:** To check at caret location use ``get_next_composite_character_column(get_caret_line(), get_caret_column())``

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_next_visible_line_index_offset_from"></a>

<!-- classref-method -->

[Vector2i](Vector2i.md) **get_next_visible_line_index_offset_from**\ (\ line\: [int](int.md), wrap_index\: [int](int.md), visible_amount\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_next_visible_line_index_offset_from)

Similar to [get_next_visible_line_offset_from()](TextEdit.md#TextEdit_method_get_next_visible_line_offset_from), but takes into account the line wrap indexes. In the returned vector, ``x`` is the line, ``y`` is the wrap index.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_next_visible_line_offset_from"></a>

<!-- classref-method -->

[int](int.md) **get_next_visible_line_offset_from**\ (\ line\: [int](int.md), visible_amount\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_next_visible_line_offset_from)

Returns the count to the next visible line from `line` to ``line + visible_amount``. Can also count backwards. For example if a **TextEdit** has 5 lines with lines 2 and 3 hidden, calling this with ``line = 1, visible_amount = 1`` would return 3.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_pos_at_line_column"></a>

<!-- classref-method -->

[Vector2i](Vector2i.md) **get_pos_at_line_column**\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_pos_at_line_column)

Returns the local position for the given `line` and `column`. If ``x`` or ``y`` of the returned vector equal ``-1``, the position is outside of the viewable area of the control.

\ **Note:** The Y position corresponds to the bottom side of the line. Use [get_rect_at_line_column()](TextEdit.md#TextEdit_method_get_rect_at_line_column) to get the top side position.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_previous_composite_character_column"></a>

<!-- classref-method -->

[int](int.md) **get_previous_composite_character_column**\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_previous_composite_character_column)

Returns the correct column at the start of a composite character like â¤ï¸â€ðŸ©¹ (mending heart; Unicode: ``U+2764 U+FE0F U+200D U+1FA79``) which is comprised of more than one Unicode code point, if the caret is at the end of the composite character. Also returns the correct column with the caret at mid grapheme and for non-composite characters.

\ **Note:** To check at caret location use ``get_previous_composite_character_column(get_caret_line(), get_caret_column())``

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_rect_at_line_column"></a>

<!-- classref-method -->

[Rect2i](Rect2i.md) **get_rect_at_line_column**\ (\ line\: [int](int.md), column\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_rect_at_line_column)

Returns the local position and size for the grapheme at the given `line` and `column`. If ``x`` or ``y`` position of the returned rect equal ``-1``, the position is outside of the viewable area of the control.

\ **Note:** The Y position of the returned rect corresponds to the top side of the line, unlike [get_pos_at_line_column()](TextEdit.md#TextEdit_method_get_pos_at_line_column) which returns the bottom side.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_saved_version"></a>

<!-- classref-method -->

[int](int.md) **get_saved_version**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_saved_version)

Returns the last tagged saved version from [tag_saved_version()](TextEdit.md#TextEdit_method_tag_saved_version).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_scroll_pos_for_line"></a>

<!-- classref-method -->

[float](float.md) **get_scroll_pos_for_line**\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_scroll_pos_for_line)

Returns the scroll position for `wrap_index` of `line`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selected_text"></a>

<!-- classref-method -->

[String](String.md) **get_selected_text**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_get_selected_text)

Returns the text inside the selection of a caret, or all the carets if `caret_index` is its default value ``-1``.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_at_line_column"></a>

<!-- classref-method -->

[int](int.md) **get_selection_at_line_column**\ (\ line\: [int](int.md), column\: [int](int.md), include_edges\: [bool](bool.md) = true, only_selections\: [bool](bool.md) = true\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_at_line_column)

Returns the caret index of the selection at the given `line` and `column`, or ``-1`` if there is none.

If `include_edges` is ``false``, the position must be inside the selection and not at either end. If `only_selections` is ``false``, carets without a selection will also be considered.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_column"></a>

<!-- classref-method -->

[int](int.md) **get_selection_column**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_column)

**Deprecated:** Use [get_selection_origin_column()](TextEdit.md#TextEdit_method_get_selection_origin_column) instead.

Returns the original start column of the selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_from_column"></a>

<!-- classref-method -->

[int](int.md) **get_selection_from_column**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_from_column)

Returns the selection begin column. Returns the caret column if there is no selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_from_line"></a>

<!-- classref-method -->

[int](int.md) **get_selection_from_line**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_from_line)

Returns the selection begin line. Returns the caret line if there is no selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_line"></a>

<!-- classref-method -->

[int](int.md) **get_selection_line**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_line)

**Deprecated:** Use [get_selection_origin_line()](TextEdit.md#TextEdit_method_get_selection_origin_line) instead.

Returns the original start line of the selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_mode"></a>

<!-- classref-method -->

[SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode) **get_selection_mode**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_mode)

Returns the current selection mode.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_origin_column"></a>

<!-- classref-method -->

[int](int.md) **get_selection_origin_column**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_origin_column)

Returns the origin column of the selection. This is the opposite end from the caret.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_origin_line"></a>

<!-- classref-method -->

[int](int.md) **get_selection_origin_line**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_origin_line)

Returns the origin line of the selection. This is the opposite end from the caret.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_to_column"></a>

<!-- classref-method -->

[int](int.md) **get_selection_to_column**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_to_column)

Returns the selection end column. Returns the caret column if there is no selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_selection_to_line"></a>

<!-- classref-method -->

[int](int.md) **get_selection_to_line**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_selection_to_line)

Returns the selection end line. Returns the caret line if there is no selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_sorted_carets"></a>

<!-- classref-method -->

[PackedInt32Array](PackedInt32Array.md) **get_sorted_carets**\ (\ include_ignored_carets\: [bool](bool.md) = false\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_sorted_carets)

Returns the carets sorted by selection beginning from lowest line and column to highest (from top to bottom of text).

If `include_ignored_carets` is ``false``, carets from [multicaret_edit_ignore_caret()](TextEdit.md#TextEdit_method_multicaret_edit_ignore_caret) will be ignored.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_tab_size"></a>

<!-- classref-method -->

[int](int.md) **get_tab_size**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_tab_size)

Returns the **TextEdit**'s' tab size.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_total_gutter_width"></a>

<!-- classref-method -->

[int](int.md) **get_total_gutter_width**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_total_gutter_width)

Returns the total width of all gutters and internal padding.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_total_visible_line_count"></a>

<!-- classref-method -->

[int](int.md) **get_total_visible_line_count**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_total_visible_line_count)

Returns the total number of lines in the text. This includes wrapped lines and excludes folded lines. If [wrap_mode](TextEdit.md#TextEdit_property_wrap_mode) is set to [LINE_WRAPPING_NONE](TextEdit.md#TextEdit_constant_LINE_WRAPPING_NONE) and no lines are folded (see [CodeEdit.is_line_folded()](CodeEdit.md#CodeEdit_method_is_line_folded)) then this is equivalent to [get_line_count()](TextEdit.md#TextEdit_method_get_line_count). See [get_visible_line_count_in_range()](TextEdit.md#TextEdit_method_get_visible_line_count_in_range) for a limited range of lines.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_v_scroll_bar"></a>

<!-- classref-method -->

[VScrollBar](VScrollBar.md) **get_v_scroll_bar**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_v_scroll_bar)

Returns the [VScrollBar](VScrollBar.md) of the **TextEdit**.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_version"></a>

<!-- classref-method -->

[int](int.md) **get_version**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_version)

Returns the current version of the **TextEdit**. The version is a count of recorded operations by the undo/redo history.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_visible_line_count"></a>

<!-- classref-method -->

[int](int.md) **get_visible_line_count**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_visible_line_count)

Returns the number of lines that can visually fit, rounded down, based on this control's height.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_visible_line_count_in_range"></a>

<!-- classref-method -->

[int](int.md) **get_visible_line_count_in_range**\ (\ from_line\: [int](int.md), to_line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_visible_line_count_in_range)

Returns the total number of lines between `from_line` and `to_line` (inclusive) in the text. This includes wrapped lines and excludes folded lines. If the range covers all lines it is equivalent to [get_total_visible_line_count()](TextEdit.md#TextEdit_method_get_total_visible_line_count).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_word_at_pos"></a>

<!-- classref-method -->

[String](String.md) **get_word_at_pos**\ (\ position\: [Vector2](Vector2.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_word_at_pos)

Returns the word at `position`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_get_word_under_caret"></a>

<!-- classref-method -->

[String](String.md) **get_word_under_caret**\ (\ caret_index\: [int](int.md) = -1\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_get_word_under_caret)

Returns a [String](String.md) text with the word under the caret's location.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_has_ime_text"></a>

<!-- classref-method -->

[bool](bool.md) **has_ime_text**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_has_ime_text)

Returns ``true`` if the user has text in the [Input Method Editor](https://en.wikipedia.org/wiki/Input_method) (IME).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_has_redo"></a>

<!-- classref-method -->

[bool](bool.md) **has_redo**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_has_redo)

Returns ``true`` if a "redo" action is available.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_has_selection"></a>

<!-- classref-method -->

[bool](bool.md) **has_selection**\ (\ caret_index\: [int](int.md) = -1\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_has_selection)

Returns ``true`` if the user has selected text.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_has_undo"></a>

<!-- classref-method -->

[bool](bool.md) **has_undo**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_has_undo)

Returns ``true`` if an "undo" action is available.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_insert_line_at"></a>

<!-- classref-method -->

`void` **insert_line_at**\ (\ line\: [int](int.md), text\: [String](String.md)\ ) [ðŸ”—](#TextEdit_method_insert_line_at)

Inserts a new line with `text` at `line`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_insert_text"></a>

<!-- classref-method -->

`void` **insert_text**\ (\ text\: [String](String.md), line\: [int](int.md), column\: [int](int.md), before_selection_begin\: [bool](bool.md) = true, before_selection_end\: [bool](bool.md) = false\ ) [ðŸ”—](#TextEdit_method_insert_text)

Inserts the `text` at `line` and `column`.

If `before_selection_begin` is ``true``, carets and selections that begin at `line` and `column` will moved to the end of the inserted text, along with all carets after it.

If `before_selection_end` is ``true``, selections that end at `line` and `column` will be extended to the end of the inserted text. These parameters can be used to insert text inside of or outside of selections.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_insert_text_at_caret"></a>

<!-- classref-method -->

`void` **insert_text_at_caret**\ (\ text\: [String](String.md), caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_insert_text_at_caret)

Insert the specified text at the caret position.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_caret_after_selection_origin"></a>

<!-- classref-method -->

[bool](bool.md) **is_caret_after_selection_origin**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_caret_after_selection_origin)

Returns ``true`` if the caret of the selection is after the selection origin. This can be used to determine the direction of the selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_caret_visible"></a>

<!-- classref-method -->

[bool](bool.md) **is_caret_visible**\ (\ caret_index\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_caret_visible)

Returns ``true`` if the caret is visible, ``false`` otherwise. A caret will be considered hidden if it is outside the scrollable area when scrolling is enabled.

\ **Note:** [is_caret_visible()](TextEdit.md#TextEdit_method_is_caret_visible) does not account for a caret being off-screen if it is still within the scrollable area. It will return ``true`` even if the caret is off-screen as long as it meets **TextEdit**'s own conditions for being visible. This includes uses of [scroll_fit_content_width](TextEdit.md#TextEdit_property_scroll_fit_content_width) and [scroll_fit_content_height](TextEdit.md#TextEdit_property_scroll_fit_content_height) that cause the **TextEdit** to expand beyond the viewport's bounds.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_dragging_cursor"></a>

<!-- classref-method -->

[bool](bool.md) **is_dragging_cursor**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_dragging_cursor)

Returns ``true`` if the user is dragging their mouse for scrolling, selecting, or text dragging.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_gutter_clickable"></a>

<!-- classref-method -->

[bool](bool.md) **is_gutter_clickable**\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_gutter_clickable)

Returns ``true`` if the gutter at the given index is clickable. See [set_gutter_clickable()](TextEdit.md#TextEdit_method_set_gutter_clickable).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_gutter_drawn"></a>

<!-- classref-method -->

[bool](bool.md) **is_gutter_drawn**\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_gutter_drawn)

Returns ``true`` if the gutter at the given index is currently drawn. See [set_gutter_draw()](TextEdit.md#TextEdit_method_set_gutter_draw).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_gutter_overwritable"></a>

<!-- classref-method -->

[bool](bool.md) **is_gutter_overwritable**\ (\ gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_gutter_overwritable)

Returns ``true`` if the gutter at the given index is overwritable. See [set_gutter_overwritable()](TextEdit.md#TextEdit_method_set_gutter_overwritable).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_in_mulitcaret_edit"></a>

<!-- classref-method -->

[bool](bool.md) **is_in_mulitcaret_edit**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_in_mulitcaret_edit)

Returns ``true`` if a [begin_multicaret_edit()](TextEdit.md#TextEdit_method_begin_multicaret_edit) has been called and [end_multicaret_edit()](TextEdit.md#TextEdit_method_end_multicaret_edit) has not yet been called.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_line_gutter_clickable"></a>

<!-- classref-method -->

[bool](bool.md) **is_line_gutter_clickable**\ (\ line\: [int](int.md), gutter\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_line_gutter_clickable)

Returns ``true`` if the gutter at the given index on the given line is clickable. See [set_line_gutter_clickable()](TextEdit.md#TextEdit_method_set_line_gutter_clickable).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_line_wrapped"></a>

<!-- classref-method -->

[bool](bool.md) **is_line_wrapped**\ (\ line\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_line_wrapped)

Returns if the given line is wrapped.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_menu_visible"></a>

<!-- classref-method -->

[bool](bool.md) **is_menu_visible**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_menu_visible)

Returns ``true`` if the menu is visible. Use this instead of ``get_menu().visible`` to improve performance (so the creation of the menu is avoided). See [get_menu()](TextEdit.md#TextEdit_method_get_menu).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_mouse_over_selection"></a>

<!-- classref-method -->

[bool](bool.md) **is_mouse_over_selection**\ (\ edges\: [bool](bool.md), caret_index\: [int](int.md) = -1\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_mouse_over_selection)

Returns ``true`` if the mouse is over a selection. If `edges` is ``true``, the edges are considered part of the selection.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_is_overtype_mode_enabled"></a>

<!-- classref-method -->

[bool](bool.md) **is_overtype_mode_enabled**\ (\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_is_overtype_mode_enabled)

Returns ``true`` if overtype mode is enabled. See [set_overtype_mode_enabled()](TextEdit.md#TextEdit_method_set_overtype_mode_enabled).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_menu_option"></a>

<!-- classref-method -->

`void` **menu_option**\ (\ option\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_menu_option)

Executes a given action as defined in the [MenuItems](TextEdit.md#enum_TextEdit_MenuItems) enum.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_merge_gutters"></a>

<!-- classref-method -->

`void` **merge_gutters**\ (\ from_line\: [int](int.md), to_line\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_merge_gutters)

Merge the gutters from `from_line` into `to_line`. Only overwritable gutters will be copied. See [set_gutter_overwritable()](TextEdit.md#TextEdit_method_set_gutter_overwritable).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_merge_overlapping_carets"></a>

<!-- classref-method -->

`void` **merge_overlapping_carets**\ (\ ) [ðŸ”—](#TextEdit_method_merge_overlapping_carets)

Merges any overlapping carets. Will favor the newest caret, or the caret with a selection.

If [is_in_mulitcaret_edit()](TextEdit.md#TextEdit_method_is_in_mulitcaret_edit) is ``true``, the merge will be queued to happen at the end of the multicaret edit. See [begin_multicaret_edit()](TextEdit.md#TextEdit_method_begin_multicaret_edit) and [end_multicaret_edit()](TextEdit.md#TextEdit_method_end_multicaret_edit).

\ **Note:** This is not called when a caret changes position but after certain actions, so it is possible to get into a state where carets overlap.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_multicaret_edit_ignore_caret"></a>

<!-- classref-method -->

[bool](bool.md) **multicaret_edit_ignore_caret**\ (\ caret_index\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_multicaret_edit_ignore_caret)

Returns ``true`` if the given `caret_index` should be ignored as part of a multicaret edit. See [begin_multicaret_edit()](TextEdit.md#TextEdit_method_begin_multicaret_edit) and [end_multicaret_edit()](TextEdit.md#TextEdit_method_end_multicaret_edit). Carets that should be ignored are ones that were part of removed text and will likely be merged at the end of the edit, or carets that were added during the edit.

It is recommended to ``continue`` within a loop iterating on multiple carets if a caret should be ignored.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_paste"></a>

<!-- classref-method -->

`void` **paste**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_paste)

Paste at the current location. Can be overridden with [_paste()](TextEdit.md#TextEdit_private_method__paste).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_paste_primary_clipboard"></a>

<!-- classref-method -->

`void` **paste_primary_clipboard**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_paste_primary_clipboard)

Pastes the primary clipboard.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_redo"></a>

<!-- classref-method -->

`void` **redo**\ (\ ) [ðŸ”—](#TextEdit_method_redo)

Perform redo operation.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_remove_caret"></a>

<!-- classref-method -->

`void` **remove_caret**\ (\ caret\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_remove_caret)

Removes the given caret index.

\ **Note:** This can result in adjustment of all other caret indices.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_remove_gutter"></a>

<!-- classref-method -->

`void` **remove_gutter**\ (\ gutter\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_remove_gutter)

Removes the gutter at the given index.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_remove_line_at"></a>

<!-- classref-method -->

`void` **remove_line_at**\ (\ line\: [int](int.md), move_carets_down\: [bool](bool.md) = true\ ) [ðŸ”—](#TextEdit_method_remove_line_at)

Removes the line of text at `line`. Carets on this line will attempt to match their previous visual x position.

If `move_carets_down` is ``true`` carets will move to the next line down, otherwise carets will move up.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_remove_secondary_carets"></a>

<!-- classref-method -->

`void` **remove_secondary_carets**\ (\ ) [ðŸ”—](#TextEdit_method_remove_secondary_carets)

Removes all additional carets.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_remove_text"></a>

<!-- classref-method -->

`void` **remove_text**\ (\ from_line\: [int](int.md), from_column\: [int](int.md), to_line\: [int](int.md), to_column\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_remove_text)

Removes text between the given positions.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_search"></a>

<!-- classref-method -->

[Vector2i](Vector2i.md) **search**\ (\ text\: [String](String.md), flags\: [int](int.md), from_line\: [int](int.md), from_column\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#TextEdit_method_search)

Perform a search inside the text. Search flags can be specified in the [SearchFlags](TextEdit.md#enum_TextEdit_SearchFlags) enum.

In the returned vector, ``x`` is the column, ``y`` is the line. If no results are found, both are equal to ``-1``.




```gdscript
    var result = search("print", SEARCH_WHOLE_WORDS, 0, 0)
    if result.x != -1:
        # Result found.
        var line_number = result.y
        var column_number = result.x
```


```csharp
    Vector2I result = Search("print", (uint)TextEdit.SearchFlags.WholeWords, 0, 0);
    if (result.X != -1)
    {
        // Result found.
        int lineNumber = result.Y;
        int columnNumber = result.X;
    }
```




<hr class="classref-item-separator"/>

<a id="TextEdit_method_select"></a>

<!-- classref-method -->

`void` **select**\ (\ origin_line\: [int](int.md), origin_column\: [int](int.md), caret_line\: [int](int.md), caret_column\: [int](int.md), caret_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_select)

Selects text from `origin_line` and `origin_column` to `caret_line` and `caret_column` for the given `caret_index`. This moves the selection origin and the caret. If the positions are the same, the selection will be deselected.

If [selecting_enabled](TextEdit.md#TextEdit_property_selecting_enabled) is ``false``, no selection will occur.

\ **Note:** If supporting multiple carets this will not check for any overlap. See [merge_overlapping_carets()](TextEdit.md#TextEdit_method_merge_overlapping_carets).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_select_all"></a>

<!-- classref-method -->

`void` **select_all**\ (\ ) [ðŸ”—](#TextEdit_method_select_all)

Select all the text.

If [selecting_enabled](TextEdit.md#TextEdit_property_selecting_enabled) is ``false``, no selection will occur.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_select_word_under_caret"></a>

<!-- classref-method -->

`void` **select_word_under_caret**\ (\ caret_index\: [int](int.md) = -1\ ) [ðŸ”—](#TextEdit_method_select_word_under_caret)

Selects the word under the caret.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_caret_column"></a>

<!-- classref-method -->

`void` **set_caret_column**\ (\ column\: [int](int.md), adjust_viewport\: [bool](bool.md) = true, caret_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_set_caret_column)

Moves the caret to the specified `column` index.

If `adjust_viewport` is ``true``, the viewport will center at the caret position after the move occurs.

\ **Note:** If supporting multiple carets this will not check for any overlap. See [merge_overlapping_carets()](TextEdit.md#TextEdit_method_merge_overlapping_carets).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_caret_line"></a>

<!-- classref-method -->

`void` **set_caret_line**\ (\ line\: [int](int.md), adjust_viewport\: [bool](bool.md) = true, can_be_hidden\: [bool](bool.md) = true, wrap_index\: [int](int.md) = 0, caret_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_set_caret_line)

Moves the caret to the specified `line` index. The caret column will be moved to the same visual position it was at the last time [set_caret_column()](TextEdit.md#TextEdit_method_set_caret_column) was called, or clamped to the end of the line.

If `adjust_viewport` is ``true``, the viewport will center at the caret position after the move occurs.

If `can_be_hidden` is ``true``, the specified `line` can be hidden.

If `wrap_index` is ``-1``, the caret column will be clamped to the `line`'s length. If `wrap_index` is greater than ``-1``, the column will be moved to attempt to match the visual x position on the line's `wrap_index` to the position from the last time [set_caret_column()](TextEdit.md#TextEdit_method_set_caret_column) was called.

\ **Note:** If supporting multiple carets this will not check for any overlap. See [merge_overlapping_carets()](TextEdit.md#TextEdit_method_merge_overlapping_carets).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_gutter_clickable"></a>

<!-- classref-method -->

`void` **set_gutter_clickable**\ (\ gutter\: [int](int.md), clickable\: [bool](bool.md)\ ) [ðŸ”—](#TextEdit_method_set_gutter_clickable)

If ``true``, the mouse cursor will change to a pointing hand ([Control.CURSOR_POINTING_HAND](Control.md#Control_constant_CURSOR_POINTING_HAND)) when hovering over the gutter at the given index. See [is_gutter_clickable()](TextEdit.md#TextEdit_method_is_gutter_clickable) and [set_line_gutter_clickable()](TextEdit.md#TextEdit_method_set_line_gutter_clickable).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_gutter_custom_draw"></a>

<!-- classref-method -->

`void` **set_gutter_custom_draw**\ (\ column\: [int](int.md), draw_callback\: [Callable](Callable.md)\ ) [ðŸ”—](#TextEdit_method_set_gutter_custom_draw)

Set a custom draw callback for the gutter at the given index. `draw_callback` must take the following arguments: A line index [int](int.md), a gutter index [int](int.md), and an area [Rect2](Rect2.md). This callback only works when the gutter type is [GUTTER_TYPE_CUSTOM](TextEdit.md#TextEdit_constant_GUTTER_TYPE_CUSTOM) (see [set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type)).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_gutter_draw"></a>

<!-- classref-method -->

`void` **set_gutter_draw**\ (\ gutter\: [int](int.md), draw\: [bool](bool.md)\ ) [ðŸ”—](#TextEdit_method_set_gutter_draw)

If ``true``, the gutter at the given index is drawn. The gutter type ([set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type)) determines how it is drawn. See [is_gutter_drawn()](TextEdit.md#TextEdit_method_is_gutter_drawn).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_gutter_name"></a>

<!-- classref-method -->

`void` **set_gutter_name**\ (\ gutter\: [int](int.md), name\: [String](String.md)\ ) [ðŸ”—](#TextEdit_method_set_gutter_name)

Sets the name of the gutter at the given index.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_gutter_overwritable"></a>

<!-- classref-method -->

`void` **set_gutter_overwritable**\ (\ gutter\: [int](int.md), overwritable\: [bool](bool.md)\ ) [ðŸ”—](#TextEdit_method_set_gutter_overwritable)

If ``true``, the line data of the gutter at the given index can be overridden when using [merge_gutters()](TextEdit.md#TextEdit_method_merge_gutters). See [is_gutter_overwritable()](TextEdit.md#TextEdit_method_is_gutter_overwritable).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_gutter_type"></a>

<!-- classref-method -->

`void` **set_gutter_type**\ (\ gutter\: [int](int.md), type\: [GutterType](TextEdit.md#enum_TextEdit_GutterType)\ ) [ðŸ”—](#TextEdit_method_set_gutter_type)

Sets the type of gutter at the given index. Gutters can contain icons, text, or custom visuals.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_gutter_width"></a>

<!-- classref-method -->

`void` **set_gutter_width**\ (\ gutter\: [int](int.md), width\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_set_gutter_width)

Set the width of the gutter at the given index.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line"></a>

<!-- classref-method -->

`void` **set_line**\ (\ line\: [int](int.md), new_text\: [String](String.md)\ ) [ðŸ”—](#TextEdit_method_set_line)

Sets the text for a specific `line`.

Carets on the line will attempt to keep their visual x position.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_as_center_visible"></a>

<!-- classref-method -->

`void` **set_line_as_center_visible**\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_set_line_as_center_visible)

Positions the `wrap_index` of `line` at the center of the viewport.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_as_first_visible"></a>

<!-- classref-method -->

`void` **set_line_as_first_visible**\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_set_line_as_first_visible)

Positions the `wrap_index` of `line` at the top of the viewport.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_as_last_visible"></a>

<!-- classref-method -->

`void` **set_line_as_last_visible**\ (\ line\: [int](int.md), wrap_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_set_line_as_last_visible)

Positions the `wrap_index` of `line` at the bottom of the viewport.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_background_color"></a>

<!-- classref-method -->

`void` **set_line_background_color**\ (\ line\: [int](int.md), color\: [Color](Color.md)\ ) [ðŸ”—](#TextEdit_method_set_line_background_color)

Sets the custom background color of the given line. If transparent, this color is applied on top of the default background color (See [background_color](TextEdit.md#TextEdit_theme_color_background_color)). If set to ``Color(0, 0, 0, 0)``, no additional color is applied.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_gutter_clickable"></a>

<!-- classref-method -->

`void` **set_line_gutter_clickable**\ (\ line\: [int](int.md), gutter\: [int](int.md), clickable\: [bool](bool.md)\ ) [ðŸ”—](#TextEdit_method_set_line_gutter_clickable)

If `clickable` is ``true``, makes the `gutter` on the given `line` clickable. This is like [set_gutter_clickable()](TextEdit.md#TextEdit_method_set_gutter_clickable), but for a single line. If [is_gutter_clickable()](TextEdit.md#TextEdit_method_is_gutter_clickable) is ``true``, this will not have any effect. See [is_line_gutter_clickable()](TextEdit.md#TextEdit_method_is_line_gutter_clickable) and [gutter_clicked](TextEdit.md#TextEdit_signal_gutter_clicked).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_gutter_icon"></a>

<!-- classref-method -->

`void` **set_line_gutter_icon**\ (\ line\: [int](int.md), gutter\: [int](int.md), icon\: [Texture2D](Texture2D.md)\ ) [ðŸ”—](#TextEdit_method_set_line_gutter_icon)

Sets the icon for `gutter` on `line` to `icon`. This only works when the gutter type is [GUTTER_TYPE_ICON](TextEdit.md#TextEdit_constant_GUTTER_TYPE_ICON) (see [set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type)).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_gutter_item_color"></a>

<!-- classref-method -->

`void` **set_line_gutter_item_color**\ (\ line\: [int](int.md), gutter\: [int](int.md), color\: [Color](Color.md)\ ) [ðŸ”—](#TextEdit_method_set_line_gutter_item_color)

Sets the color for `gutter` on `line` to `color`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_gutter_metadata"></a>

<!-- classref-method -->

`void` **set_line_gutter_metadata**\ (\ line\: [int](int.md), gutter\: [int](int.md), metadata\: [Variant](Variant.md)\ ) [ðŸ”—](#TextEdit_method_set_line_gutter_metadata)

Sets the metadata for `gutter` on `line` to `metadata`.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_line_gutter_text"></a>

<!-- classref-method -->

`void` **set_line_gutter_text**\ (\ line\: [int](int.md), gutter\: [int](int.md), text\: [String](String.md)\ ) [ðŸ”—](#TextEdit_method_set_line_gutter_text)

Sets the text for `gutter` on `line` to `text`. This only works when the gutter type is [GUTTER_TYPE_STRING](TextEdit.md#TextEdit_constant_GUTTER_TYPE_STRING) (see [set_gutter_type()](TextEdit.md#TextEdit_method_set_gutter_type)).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_overtype_mode_enabled"></a>

<!-- classref-method -->

`void` **set_overtype_mode_enabled**\ (\ enabled\: [bool](bool.md)\ ) [ðŸ”—](#TextEdit_method_set_overtype_mode_enabled)

If ``true``, enables overtype mode. In this mode, typing overrides existing text instead of inserting text. The [ProjectSettings.input/ui_text_toggle_insert_mode](ProjectSettings.md#ProjectSettings_property_input/ui_text_toggle_insert_mode) action toggles overtype mode. See [is_overtype_mode_enabled()](TextEdit.md#TextEdit_method_is_overtype_mode_enabled).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_search_flags"></a>

<!-- classref-method -->

`void` **set_search_flags**\ (\ flags\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_set_search_flags)

Sets the search `flags`. This is used with [set_search_text()](TextEdit.md#TextEdit_method_set_search_text) to highlight occurrences of the searched text. Search flags can be specified from the [SearchFlags](TextEdit.md#enum_TextEdit_SearchFlags) enum.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_search_text"></a>

<!-- classref-method -->

`void` **set_search_text**\ (\ search_text\: [String](String.md)\ ) [ðŸ”—](#TextEdit_method_set_search_text)

Sets the search text. See [set_search_flags()](TextEdit.md#TextEdit_method_set_search_flags).

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_selection_mode"></a>

<!-- classref-method -->

`void` **set_selection_mode**\ (\ mode\: [SelectionMode](TextEdit.md#enum_TextEdit_SelectionMode)\ ) [ðŸ”—](#TextEdit_method_set_selection_mode)

Sets the current selection mode.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_selection_origin_column"></a>

<!-- classref-method -->

`void` **set_selection_origin_column**\ (\ column\: [int](int.md), caret_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_set_selection_origin_column)

Sets the selection origin column to the `column` for the given `caret_index`. If the selection origin is moved to the caret position, the selection will deselect.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_selection_origin_line"></a>

<!-- classref-method -->

`void` **set_selection_origin_line**\ (\ line\: [int](int.md), can_be_hidden\: [bool](bool.md) = true, wrap_index\: [int](int.md) = -1, caret_index\: [int](int.md) = 0\ ) [ðŸ”—](#TextEdit_method_set_selection_origin_line)

Sets the selection origin line to the `line` for the given `caret_index`. If the selection origin is moved to the caret position, the selection will deselect.

If `can_be_hidden` is ``false``, The line will be set to the nearest unhidden line below or above.

If `wrap_index` is ``-1``, the selection origin column will be clamped to the `line`'s length. If `wrap_index` is greater than ``-1``, the column will be moved to attempt to match the visual x position on the line's `wrap_index` to the position from the last time [set_selection_origin_column()](TextEdit.md#TextEdit_method_set_selection_origin_column) or [select()](TextEdit.md#TextEdit_method_select) was called.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_tab_size"></a>

<!-- classref-method -->

`void` **set_tab_size**\ (\ size\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_set_tab_size)

Sets the tab size for the **TextEdit** to use.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_set_tooltip_request_func"></a>

<!-- classref-method -->

`void` **set_tooltip_request_func**\ (\ callback\: [Callable](Callable.md)\ ) [ðŸ”—](#TextEdit_method_set_tooltip_request_func)

Provide custom tooltip text. The callback method must take the following args: ``hovered_word: String``.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_skip_selection_for_next_occurrence"></a>

<!-- classref-method -->

`void` **skip_selection_for_next_occurrence**\ (\ ) [ðŸ”—](#TextEdit_method_skip_selection_for_next_occurrence)

Moves a selection and a caret for the next occurrence of the current selection. If there is no active selection, moves to the next occurrence of the word under caret.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_start_action"></a>

<!-- classref-method -->

`void` **start_action**\ (\ action\: [EditAction](TextEdit.md#enum_TextEdit_EditAction)\ ) [ðŸ”—](#TextEdit_method_start_action)

Starts an action, will end the current action if `action` is different.

An action will also end after a call to [end_action()](TextEdit.md#TextEdit_method_end_action), after [ProjectSettings.gui/timers/text_edit_idle_detect_sec](ProjectSettings.md#ProjectSettings_property_gui/timers/text_edit_idle_detect_sec) is triggered or a new undoable step outside the [start_action()](TextEdit.md#TextEdit_method_start_action) and [end_action()](TextEdit.md#TextEdit_method_end_action) calls.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_swap_lines"></a>

<!-- classref-method -->

`void` **swap_lines**\ (\ from_line\: [int](int.md), to_line\: [int](int.md)\ ) [ðŸ”—](#TextEdit_method_swap_lines)

Swaps the two lines. Carets will be swapped with the lines.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_tag_saved_version"></a>

<!-- classref-method -->

`void` **tag_saved_version**\ (\ ) [ðŸ”—](#TextEdit_method_tag_saved_version)

Tag the current version as saved.

<hr class="classref-item-separator"/>

<a id="TextEdit_method_undo"></a>

<!-- classref-method -->

`void` **undo**\ (\ ) [ðŸ”—](#TextEdit_method_undo)

Perform undo operation.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Theme Property Descriptions

<a id="TextEdit_theme_color_background_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **background_color** = `Color(0, 0, 0, 0)` [ðŸ”—](#TextEdit_theme_color_background_color)

Sets the background [Color](Color.md) of this **TextEdit**.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_caret_background_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **caret_background_color** = `Color(0, 0, 0, 1)` [ðŸ”—](#TextEdit_theme_color_caret_background_color)

[Color](Color.md) of the text behind the caret when using a block caret.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_caret_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **caret_color** = `Color(0.875, 0.875, 0.875, 1)` [ðŸ”—](#TextEdit_theme_color_caret_color)

[Color](Color.md) of the caret. This can be set to a fully transparent color to hide the caret entirely.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_current_line_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **current_line_color** = `Color(0.25, 0.25, 0.26, 0.8)` [ðŸ”—](#TextEdit_theme_color_current_line_color)

Background [Color](Color.md) of the line containing the caret.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_font_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **font_color** = `Color(0.875, 0.875, 0.875, 1)` [ðŸ”—](#TextEdit_theme_color_font_color)

Sets the font [Color](Color.md).

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_font_outline_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **font_outline_color** = `Color(0, 0, 0, 1)` [ðŸ”—](#TextEdit_theme_color_font_outline_color)

The tint of text outline of the **TextEdit**.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_font_placeholder_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **font_placeholder_color** = `Color(0.875, 0.875, 0.875, 0.6)` [ðŸ”—](#TextEdit_theme_color_font_placeholder_color)

Font color for [placeholder_text](TextEdit.md#TextEdit_property_placeholder_text).

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_font_readonly_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **font_readonly_color** = `Color(0.875, 0.875, 0.875, 0.5)` [ðŸ”—](#TextEdit_theme_color_font_readonly_color)

Sets the font [Color](Color.md) when [editable](TextEdit.md#TextEdit_property_editable) is disabled.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_font_selected_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **font_selected_color** = `Color(0, 0, 0, 0)` [ðŸ”—](#TextEdit_theme_color_font_selected_color)

Sets the [Color](Color.md) of the selected text. If equal to ``Color(0, 0, 0, 0)``, it will be ignored.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_search_result_border_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **search_result_border_color** = `Color(0.3, 0.3, 0.3, 0.4)` [ðŸ”—](#TextEdit_theme_color_search_result_border_color)

[Color](Color.md) of the border around text that matches the search query.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_search_result_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **search_result_color** = `Color(0.3, 0.3, 0.3, 1)` [ðŸ”—](#TextEdit_theme_color_search_result_color)

[Color](Color.md) behind the text that matches the search query.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_selection_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **selection_color** = `Color(0.5, 0.5, 0.5, 1)` [ðŸ”—](#TextEdit_theme_color_selection_color)

Sets the highlight [Color](Color.md) of text selections.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_color_word_highlighted_color"></a>

<!-- classref-themeproperty -->

[Color](Color.md) **word_highlighted_color** = `Color(0.5, 0.5, 0.5, 0.25)` [ðŸ”—](#TextEdit_theme_color_word_highlighted_color)

Sets the highlight [Color](Color.md) of multiple occurrences. [highlight_all_occurrences](TextEdit.md#TextEdit_property_highlight_all_occurrences) has to be enabled.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_constant_caret_width"></a>

<!-- classref-themeproperty -->

[int](int.md) **caret_width** = `1` [ðŸ”—](#TextEdit_theme_constant_caret_width)

The caret's width in pixels. Greater values can be used to improve accessibility by ensuring the caret is easily visible, or to ensure consistency with a large font size. If set to ``0`` or lower, the caret width is automatically set to 1 pixel and multiplied by the display scaling factor.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_constant_line_spacing"></a>

<!-- classref-themeproperty -->

[int](int.md) **line_spacing** = `4` [ðŸ”—](#TextEdit_theme_constant_line_spacing)

Additional vertical spacing between lines (in pixels), spacing is added to line descent. This value can be negative.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_constant_outline_size"></a>

<!-- classref-themeproperty -->

[int](int.md) **outline_size** = `0` [ðŸ”—](#TextEdit_theme_constant_outline_size)

The size of the text outline.

\ **Note:** If using a font with [FontFile.multichannel_signed_distance_field](FontFile.md#FontFile_property_multichannel_signed_distance_field) enabled, its [FontFile.msdf_pixel_range](FontFile.md#FontFile_property_msdf_pixel_range) must be set to at least *twice* the value of [outline_size](TextEdit.md#TextEdit_theme_constant_outline_size) for outline rendering to look correct. Otherwise, the outline may appear to be cut off earlier than intended.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_font_font"></a>

<!-- classref-themeproperty -->

[Font](Font.md) **font** [ðŸ”—](#TextEdit_theme_font_font)

Sets the default [Font](Font.md).

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_font_size_font_size"></a>

<!-- classref-themeproperty -->

[int](int.md) **font_size** [ðŸ”—](#TextEdit_theme_font_size_font_size)

Sets default font size.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_icon_space"></a>

<!-- classref-themeproperty -->

[Texture2D](Texture2D.md) **space** [ðŸ”—](#TextEdit_theme_icon_space)

Sets a custom [Texture2D](Texture2D.md) for space text characters.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_icon_tab"></a>

<!-- classref-themeproperty -->

[Texture2D](Texture2D.md) **tab** [ðŸ”—](#TextEdit_theme_icon_tab)

Sets a custom [Texture2D](Texture2D.md) for tab text characters.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_style_focus"></a>

<!-- classref-themeproperty -->

[StyleBox](StyleBox.md) **focus** [ðŸ”—](#TextEdit_theme_style_focus)

Sets the [StyleBox](StyleBox.md) when in focus. The [focus](TextEdit.md#TextEdit_theme_style_focus) [StyleBox](StyleBox.md) is displayed *over* the base [StyleBox](StyleBox.md), so a partially transparent [StyleBox](StyleBox.md) should be used to ensure the base [StyleBox](StyleBox.md) remains visible. A [StyleBox](StyleBox.md) that represents an outline or an underline works well for this purpose. To disable the focus visual effect, assign a [StyleBoxEmpty](StyleBoxEmpty.md) resource. Note that disabling the focus visual effect will harm keyboard/controller navigation usability, so this is not recommended for accessibility reasons.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_style_normal"></a>

<!-- classref-themeproperty -->

[StyleBox](StyleBox.md) **normal** [ðŸ”—](#TextEdit_theme_style_normal)

Sets the [StyleBox](StyleBox.md) of this **TextEdit**.

<hr class="classref-item-separator"/>

<a id="TextEdit_theme_style_read_only"></a>

<!-- classref-themeproperty -->

[StyleBox](StyleBox.md) **read_only** [ðŸ”—](#TextEdit_theme_style_read_only)

Sets the [StyleBox](StyleBox.md) of this **TextEdit** when [editable](TextEdit.md#TextEdit_property_editable) is disabled.

