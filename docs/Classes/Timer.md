<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Timer.xml. -->

<a id="Timer"></a>

# Timer

**Inherits:** [Node](Node.md) **\<** [Object](Object.md)

A countdown timer.

<!-- classref-introduction-group -->

## Description

The **Timer** node is a countdown timer and is the simplest way to handle time-based logic in the engine. When a timer reaches the end of its [wait_time](Timer.md#Timer_property_wait_time), it will emit the [timeout](Timer.md#Timer_signal_timeout) signal.

After a timer enters the scene tree, it can be manually started with [start()](Timer.md#Timer_method_start). A timer node is also started automatically if [autostart](Timer.md#Timer_property_autostart) is ``true``.

Without requiring much code, a timer node can be added and configured in the editor. The [timeout](Timer.md#Timer_signal_timeout) signal it emits can also be connected through the Node dock in the editor:

```
    func _on_timer_timeout():
        print("Time to attack!")
```


\ **Note:** To create a one-shot timer without instantiating a node, use [SceneTree.create_timer()](SceneTree.md#SceneTree_method_create_timer).

\ **Note:** Timers in Time mode are affected by [Engine.time_scale](Engine.md#Engine_property_time_scale). The higher the time scale, the sooner timers will end. How often a timer processes may depend on the framerate or [Engine.physics_ticks_per_second](Engine.md#Engine_property_physics_ticks_per_second).

<!-- classref-introduction-group -->

## Tutorials

- [2D Dodge The Creeps Demo](https://godotengine.org/asset-library/asset/2712)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[autostart](#Timer_property_autostart)</th>
      <th>`false`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[ignore_time_scale](#Timer_property_ignore_time_scale)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[one_shot](#Timer_property_one_shot)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[paused](#Timer_property_paused)</td>
      <td></td>
    </tr>
    <tr>
      <td>[TimerProcessCallback](Timer.md#enum_Timer_TimerProcessCallback)</td>
      <td>[process_callback](#Timer_property_process_callback)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[TimerProcessType](Timer.md#enum_Timer_TimerProcessType)</td>
      <td>[process_type](#Timer_property_process_type)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[time_left](#Timer_property_time_left)</td>
      <td></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[wait_time](#Timer_property_wait_time)</td>
      <td>`1.0`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[is_stopped](#Timer_method_is_stopped)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`void`</td>
      <td>[start](#Timer_method_start)\ (\ time_sec\: [float](float.md) = -1\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[stop](#Timer_method_stop)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Signals

<a id="Timer_signal_timeout"></a>

<!-- classref-signal -->

**timeout**\ (\ ) [ðŸ”—](#Timer_signal_timeout)

Emitted when the timer reaches the end.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_Timer_TimerProcessCallback"></a>

<!-- classref-enumeration -->

enum **TimerProcessCallback**: [ðŸ”—](#enum_Timer_TimerProcessCallback)

<a id="Timer_constant_TIMER_PROCESS_PHYSICS"></a>

<!-- classref-enumeration-constant -->

[TimerProcessCallback](Timer.md#enum_Timer_TimerProcessCallback) **TIMER_PROCESS_PHYSICS** = `0`

Update the timer every physics process frame (see [Node.NOTIFICATION_INTERNAL_PHYSICS_PROCESS](Node.md#Node_constant_NOTIFICATION_INTERNAL_PHYSICS_PROCESS)).<a id="Timer_constant_TIMER_PROCESS_IDLE"></a>

<!-- classref-enumeration-constant -->

[TimerProcessCallback](Timer.md#enum_Timer_TimerProcessCallback) **TIMER_PROCESS_IDLE** = `1`

Update the timer every process (rendered) frame (see [Node.NOTIFICATION_INTERNAL_PROCESS](Node.md#Node_constant_NOTIFICATION_INTERNAL_PROCESS)).<hr class="classref-item-separator"/>

<a id="enum_Timer_TimerProcessType"></a>

<!-- classref-enumeration -->

enum **TimerProcessType**: [ðŸ”—](#enum_Timer_TimerProcessType)

<a id="Timer_constant_TIMER_PROCESS_TYPE_TIME"></a>

<!-- classref-enumeration-constant -->

[TimerProcessType](Timer.md#enum_Timer_TimerProcessType) **TIMER_PROCESS_TYPE_TIME** = `0`

Timer works with seconds. In this mode the timer is affected by [Engine.time_scale](Engine.md#Engine_property_time_scale).<a id="Timer_constant_TIMER_PROCESS_TYPE_FRAMES"></a>

<!-- classref-enumeration-constant -->

[TimerProcessType](Timer.md#enum_Timer_TimerProcessType) **TIMER_PROCESS_TYPE_FRAMES** = `1`

Timer works with frames. Speed depends on the framerate. Accepts non-fractional values only.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="Timer_property_autostart"></a>

<!-- classref-property -->

[bool](bool.md) **autostart** = `false` [ðŸ”—](#Timer_property_autostart)

<!-- classref-property-setget -->

- `void` **set_autostart**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **has_autostart**\ (\ )

If ``true``, the timer will start immediately when it enters the scene tree.

\ **Note:** After the timer enters the tree, this property is automatically set to ``false``.

\ **Note:** This property does nothing when the timer is running in the editor.

<hr class="classref-item-separator"/>

<a id="Timer_property_ignore_time_scale"></a>

<!-- classref-property -->

[bool](bool.md) **ignore_time_scale** = `false` [ðŸ”—](#Timer_property_ignore_time_scale)

<!-- classref-property-setget -->

- `void` **set_ignore_time_scale**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_ignoring_time_scale**\ (\ )

If ``true``, the timer will ignore [Engine.time_scale](Engine.md#Engine_property_time_scale) and update with the real, elapsed time.

<hr class="classref-item-separator"/>

<a id="Timer_property_one_shot"></a>

<!-- classref-property -->

[bool](bool.md) **one_shot** = `false` [ðŸ”—](#Timer_property_one_shot)

<!-- classref-property-setget -->

- `void` **set_one_shot**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_one_shot**\ (\ )

If ``true``, the timer will stop after reaching the end. Otherwise, as by default, the timer will automatically restart.

<hr class="classref-item-separator"/>

<a id="Timer_property_paused"></a>

<!-- classref-property -->

[bool](bool.md) **paused** [ðŸ”—](#Timer_property_paused)

<!-- classref-property-setget -->

- `void` **set_paused**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_paused**\ (\ )

If ``true``, the timer is paused. A paused timer does not process until this property is set back to ``false``, even when [start()](Timer.md#Timer_method_start) is called. See also [stop()](Timer.md#Timer_method_stop).

<hr class="classref-item-separator"/>

<a id="Timer_property_process_callback"></a>

<!-- classref-property -->

[TimerProcessCallback](Timer.md#enum_Timer_TimerProcessCallback) **process_callback** = `1` [ðŸ”—](#Timer_property_process_callback)

<!-- classref-property-setget -->

- `void` **set_timer_process_callback**\ (\ value\: [TimerProcessCallback](Timer.md#enum_Timer_TimerProcessCallback)\ )
- [TimerProcessCallback](Timer.md#enum_Timer_TimerProcessCallback) **get_timer_process_callback**\ (\ )

Specifies when the timer is updated during the main loop.

<hr class="classref-item-separator"/>

<a id="Timer_property_process_type"></a>

<!-- classref-property -->

[TimerProcessType](Timer.md#enum_Timer_TimerProcessType) **process_type** = `0` [ðŸ”—](#Timer_property_process_type)

<!-- classref-property-setget -->

- `void` **set_timer_process_type**\ (\ value\: [TimerProcessType](Timer.md#enum_Timer_TimerProcessType)\ )
- [TimerProcessType](Timer.md#enum_Timer_TimerProcessType) **get_timer_process_type**\ (\ )

Specifies which units the timer uses to count. (see [TimerProcessType](Timer.md#enum_Timer_TimerProcessType)).

<hr class="classref-item-separator"/>

<a id="Timer_property_time_left"></a>

<!-- classref-property -->

[float](float.md) **time_left** [ðŸ”—](#Timer_property_time_left)

<!-- classref-property-setget -->

- [float](float.md) **get_time_left**\ (\ )

The timer's remaining time in seconds. This is always ``0`` if the timer is stopped.

\ **Note:** This property is read-only and cannot be modified. It is based on [wait_time](Timer.md#Timer_property_wait_time).

<hr class="classref-item-separator"/>

<a id="Timer_property_wait_time"></a>

<!-- classref-property -->

[float](float.md) **wait_time** = `1.0` [ðŸ”—](#Timer_property_wait_time)

<!-- classref-property-setget -->

- `void` **set_wait_time**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_wait_time**\ (\ )

The time required for the timer to end, in seconds or frames. This property can also be set every time [start()](Timer.md#Timer_method_start) is called.

Time mode uses floats while Frame mode only accepts and returns non-fractional numbers.

\ **Note:** Timers can only process once per physics or process frame (depending on the [process_callback](Timer.md#Timer_property_process_callback)). In Time mode, an unstable framerate may cause the timer to end inconsistently, which is especially noticeable if the wait time is lower than roughly ``0.05`` seconds. For very short timers, it is recommended to write your own code instead of using a **Timer** node. Timers are also affected by [Engine.time_scale](Engine.md#Engine_property_time_scale).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Timer_method_is_stopped"></a>

<!-- classref-method -->

[bool](bool.md) **is_stopped**\ (\ ) <span class="const">const</span> [ðŸ”—](#Timer_method_is_stopped)

Returns ``true`` if the timer is stopped or has not started.

<hr class="classref-item-separator"/>

<a id="Timer_method_start"></a>

<!-- classref-method -->

`void` **start**\ (\ time_sec\: [float](float.md) = -1\ ) [ðŸ”—](#Timer_method_start)

Starts the timer, or resets the timer if it was started already. Fails if the timer is not inside the scene tree. If `time_sec` is greater than ``0``, this value is used for the [wait_time](Timer.md#Timer_property_wait_time).

\ **Note:** This method does not resume a paused timer. See [paused](Timer.md#Timer_property_paused).

<hr class="classref-item-separator"/>

<a id="Timer_method_stop"></a>

<!-- classref-method -->

`void` **stop**\ (\ ) [ðŸ”—](#Timer_method_stop)

Stops the timer. See also [paused](Timer.md#Timer_property_paused). Unlike [start()](Timer.md#Timer_method_start), this can safely be called if the timer is not inside the scene tree.

\ **Note:** Calling [stop()](Timer.md#Timer_method_stop) does not emit the [timeout](Timer.md#Timer_signal_timeout) signal, as the timer is not considered to have timed out. If this is desired, use ``$Timer.timeout.emit()`` after calling [stop()](Timer.md#Timer_method_stop) to manually emit the signal.

