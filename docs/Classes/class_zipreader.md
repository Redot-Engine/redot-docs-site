<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/modules/zip/doc_classes/ZIPReader.xml. -->

<a id="class_ZIPReader"></a>

# ZIPReader

**Inherits:** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

Allows reading the content of a ZIP file.

<!-- classref-introduction-group -->

## Description

This class implements a reader that can extract the content of individual files inside a ZIP archive. See also [ZIPPacker](class_zippacker.md).

```
    # Read a single file from a ZIP archive.
    func read_zip_file():
        var reader = ZIPReader.new()
        var err = reader.open("user://archive.zip")
        if err != OK:
            return PackedByteArray()
        var res = reader.read_file("hello.txt")
        reader.close()
        return res

    # Extract all files from a ZIP archive, preserving the directories within.
    # This acts like the "Extract all" functionality from most archive managers.
    func extract_all_from_zip():
        var reader = ZIPReader.new()
        reader.open("res://archive.zip")

        # Destination directory for the extracted files (this folder must exist before extraction).
        # Not all ZIP archives put everything in a single root folder,
        # which means several files/folders may be created in `root_dir` after extraction.
        var root_dir = DirAccess.open("user://")

        var files = reader.get_files()
        for file_path in files:
            # If the current entry is a directory.
            if file_path.ends_with("/"):
                root_dir.make_dir_recursive(file_path)
                continue

            # Write file contents, creating folders automatically when needed.
            # Not all ZIP archives are strictly ordered, so we need to do this in case
            # the file entry comes before the folder entry.
            root_dir.make_dir_recursive(root_dir.get_current_dir().path_join(file_path).get_base_dir())
            var file = FileAccess.open(root_dir.get_current_dir().path_join(file_path), FileAccess.WRITE)
            var buffer = reader.read_file(file_path)
            file.store_buffer(buffer)
```

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</th>
      <th>[close](#class_ZIPReader_method_close)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[file_exists](#class_ZIPReader_method_file_exists)\ (\ path\: [String](class_string.md), case_sensitive\: [bool](class_bool.md) = true\ )</td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[get_compression_level](#class_ZIPReader_method_get_compression_level)\ (\ path\: [String](class_string.md), case_sensitive\: [bool](class_bool.md) = true\ )</td>
    </tr>
    <tr>
      <td>[PackedStringArray](class_packedstringarray.md)</td>
      <td>[get_files](#class_ZIPReader_method_get_files)\ (\ )</td>
    </tr>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[open](#class_ZIPReader_method_open)\ (\ path\: [String](class_string.md)\ )</td>
    </tr>
    <tr>
      <td>[PackedByteArray](class_packedbytearray.md)</td>
      <td>[read_file](#class_ZIPReader_method_read_file)\ (\ path\: [String](class_string.md), case_sensitive\: [bool](class_bool.md) = true\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_ZIPReader_method_close"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **close**\ (\ ) [ðŸ”—](#class_ZIPReader_method_close)

Closes the underlying resources used by this instance.

<hr class="classref-item-separator">

<a id="class_ZIPReader_method_file_exists"></a>

<!-- classref-method -->

[bool](class_bool.md) **file_exists**\ (\ path\: [String](class_string.md), case_sensitive\: [bool](class_bool.md) = true\ ) [ðŸ”—](#class_ZIPReader_method_file_exists)

Returns ``true`` if the file exists in the loaded zip archive.

Must be called after [open()](class_zipreader.md#class_ZIPReader_method_open).

<hr class="classref-item-separator">

<a id="class_ZIPReader_method_get_compression_level"></a>

<!-- classref-method -->

[int](class_int.md) **get_compression_level**\ (\ path\: [String](class_string.md), case_sensitive\: [bool](class_bool.md) = true\ ) [ðŸ”—](#class_ZIPReader_method_get_compression_level)

Returns the compression level of the file in the loaded zip archive. Returns ``-1`` if the file doesn't exist or any other error occurs. Must be called after [open()](class_zipreader.md#class_ZIPReader_method_open).

<hr class="classref-item-separator">

<a id="class_ZIPReader_method_get_files"></a>

<!-- classref-method -->

[PackedStringArray](class_packedstringarray.md) **get_files**\ (\ ) [ðŸ”—](#class_ZIPReader_method_get_files)

Returns the list of names of all files in the loaded archive.

Must be called after [open()](class_zipreader.md#class_ZIPReader_method_open).

<hr class="classref-item-separator">

<a id="class_ZIPReader_method_open"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **open**\ (\ path\: [String](class_string.md)\ ) [ðŸ”—](#class_ZIPReader_method_open)

Opens the zip archive at the given `path` and reads its file index.

<hr class="classref-item-separator">

<a id="class_ZIPReader_method_read_file"></a>

<!-- classref-method -->

[PackedByteArray](class_packedbytearray.md) **read_file**\ (\ path\: [String](class_string.md), case_sensitive\: [bool](class_bool.md) = true\ ) [ðŸ”—](#class_ZIPReader_method_read_file)

Loads the whole content of a file in the loaded zip archive into memory and returns it.

Must be called after [open()](class_zipreader.md#class_ZIPReader_method_open).

