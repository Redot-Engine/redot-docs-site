<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/AudioStreamWAV.xml. -->

<a id="class_AudioStreamWAV"></a>

# AudioStreamWAV

**Inherits:** [AudioStream](class_audiostream.md) **<** [Resource](class_resource.md) **<** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

Stores audio data loaded from WAV files.

<!-- classref-introduction-group -->

## Description

AudioStreamWAV stores sound samples loaded from WAV files. To play the stored sound, use an [AudioStreamPlayer](class_audiostreamplayer.md) (for non-positional audio) or [AudioStreamPlayer2D](class_audiostreamplayer2d.md)/[AudioStreamPlayer3D](class_audiostreamplayer3d.md) (for positional audio). The sound can be looped.

This class can also be used to store dynamically-generated PCM audio data. See also [AudioStreamGenerator](class_audiostreamgenerator.md) for procedural audio generation.

<!-- classref-introduction-group -->

## Tutorials

- [Runtime file loading and saving](../tutorials/io/runtime_file_loading_and_saving.md)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[PackedByteArray](class_packedbytearray.md)</th>
      <th>[data](#class_AudioStreamWAV_property_data)</th>
      <th>`PackedByteArray()`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Format](class_audiostreamwav.md#enum_AudioStreamWAV_Format)</td>
      <td>[format](#class_AudioStreamWAV_property_format)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[loop_begin](#class_AudioStreamWAV_property_loop_begin)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[loop_end](#class_AudioStreamWAV_property_loop_end)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[LoopMode](class_audiostreamwav.md#enum_AudioStreamWAV_LoopMode)</td>
      <td>[loop_mode](#class_AudioStreamWAV_property_loop_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[mix_rate](#class_AudioStreamWAV_property_mix_rate)</td>
      <td>`44100`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[stereo](#class_AudioStreamWAV_property_stereo)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[Dictionary](class_dictionary.md)</td>
      <td>[tags](#class_AudioStreamWAV_property_tags)</td>
      <td>`{}`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[AudioStreamWAV](class_audiostreamwav.md)</th>
      <th>[load_from_buffer](#class_AudioStreamWAV_method_load_from_buffer)\ (\ stream_data\: [PackedByteArray](class_packedbytearray.md), options\: [Dictionary](class_dictionary.md) = {}\ ) <span class="static">static</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[AudioStreamWAV](class_audiostreamwav.md)</td>
      <td>[load_from_file](#class_AudioStreamWAV_method_load_from_file)\ (\ path\: [String](class_string.md), options\: [Dictionary](class_dictionary.md) = {}\ ) <span class="static">static</span></td>
    </tr>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[save_to_wav](#class_AudioStreamWAV_method_save_to_wav)\ (\ path\: [String](class_string.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_AudioStreamWAV_Format"></a>

<!-- classref-enumeration -->

enum **Format**: [ðŸ”—](#enum_AudioStreamWAV_Format)

<a id="class_AudioStreamWAV_constant_FORMAT_8_BITS"></a>

<!-- classref-enumeration-constant -->

[Format](class_audiostreamwav.md#enum_AudioStreamWAV_Format) **FORMAT_8_BITS** = `0`

8-bit PCM audio codec.<a id="class_AudioStreamWAV_constant_FORMAT_16_BITS"></a>

<!-- classref-enumeration-constant -->

[Format](class_audiostreamwav.md#enum_AudioStreamWAV_Format) **FORMAT_16_BITS** = `1`

16-bit PCM audio codec.<a id="class_AudioStreamWAV_constant_FORMAT_IMA_ADPCM"></a>

<!-- classref-enumeration-constant -->

[Format](class_audiostreamwav.md#enum_AudioStreamWAV_Format) **FORMAT_IMA_ADPCM** = `2`

Audio is lossily compressed as IMA ADPCM.<a id="class_AudioStreamWAV_constant_FORMAT_QOA"></a>

<!-- classref-enumeration-constant -->

[Format](class_audiostreamwav.md#enum_AudioStreamWAV_Format) **FORMAT_QOA** = `3`

Audio is lossily compressed as [Quite OK Audio](https://qoaformat.org/).<hr class="classref-item-separator">

<a id="enum_AudioStreamWAV_LoopMode"></a>

<!-- classref-enumeration -->

enum **LoopMode**: [ðŸ”—](#enum_AudioStreamWAV_LoopMode)

<a id="class_AudioStreamWAV_constant_LOOP_DISABLED"></a>

<!-- classref-enumeration-constant -->

[LoopMode](class_audiostreamwav.md#enum_AudioStreamWAV_LoopMode) **LOOP_DISABLED** = `0`

Audio does not loop.<a id="class_AudioStreamWAV_constant_LOOP_FORWARD"></a>

<!-- classref-enumeration-constant -->

[LoopMode](class_audiostreamwav.md#enum_AudioStreamWAV_LoopMode) **LOOP_FORWARD** = `1`

Audio loops the data between [loop_begin](class_audiostreamwav.md#class_AudioStreamWAV_property_loop_begin) and [loop_end](class_audiostreamwav.md#class_AudioStreamWAV_property_loop_end), playing forward only.<a id="class_AudioStreamWAV_constant_LOOP_PINGPONG"></a>

<!-- classref-enumeration-constant -->

[LoopMode](class_audiostreamwav.md#enum_AudioStreamWAV_LoopMode) **LOOP_PINGPONG** = `2`

Audio loops the data between [loop_begin](class_audiostreamwav.md#class_AudioStreamWAV_property_loop_begin) and [loop_end](class_audiostreamwav.md#class_AudioStreamWAV_property_loop_end), playing back and forth.<a id="class_AudioStreamWAV_constant_LOOP_BACKWARD"></a>

<!-- classref-enumeration-constant -->

[LoopMode](class_audiostreamwav.md#enum_AudioStreamWAV_LoopMode) **LOOP_BACKWARD** = `3`

Audio loops the data between [loop_begin](class_audiostreamwav.md#class_AudioStreamWAV_property_loop_begin) and [loop_end](class_audiostreamwav.md#class_AudioStreamWAV_property_loop_end), playing backward only.<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_AudioStreamWAV_property_data"></a>

<!-- classref-property -->

[PackedByteArray](class_packedbytearray.md) **data** = `PackedByteArray()` [ðŸ”—](#class_AudioStreamWAV_property_data)

<!-- classref-property-setget -->

- `void` **set_data**\ (\ value\: [PackedByteArray](class_packedbytearray.md)\ )
- [PackedByteArray](class_packedbytearray.md) **get_data**\ (\ )

Contains the audio data in bytes.

\ **Note:** If [format](class_audiostreamwav.md#class_AudioStreamWAV_property_format) is set to [FORMAT_8_BITS](class_audiostreamwav.md#class_AudioStreamWAV_constant_FORMAT_8_BITS), this property expects signed 8-bit PCM data. To convert from unsigned 8-bit PCM, subtract 128 from each byte.

\ **Note:** If [format](class_audiostreamwav.md#class_AudioStreamWAV_property_format) is set to [FORMAT_QOA](class_audiostreamwav.md#class_AudioStreamWAV_constant_FORMAT_QOA), this property expects data from a full QOA file.

**Note:** The returned array is *copied* and any changes to it will not update the original property value. See [PackedByteArray](class_packedbytearray.md) for more details.

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_property_format"></a>

<!-- classref-property -->

[Format](class_audiostreamwav.md#enum_AudioStreamWAV_Format) **format** = `0` [ðŸ”—](#class_AudioStreamWAV_property_format)

<!-- classref-property-setget -->

- `void` **set_format**\ (\ value\: [Format](class_audiostreamwav.md#enum_AudioStreamWAV_Format)\ )
- [Format](class_audiostreamwav.md#enum_AudioStreamWAV_Format) **get_format**\ (\ )

Audio format.

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_property_loop_begin"></a>

<!-- classref-property -->

[int](class_int.md) **loop_begin** = `0` [ðŸ”—](#class_AudioStreamWAV_property_loop_begin)

<!-- classref-property-setget -->

- `void` **set_loop_begin**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_loop_begin**\ (\ )

The loop start point (in number of samples, relative to the beginning of the stream).

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_property_loop_end"></a>

<!-- classref-property -->

[int](class_int.md) **loop_end** = `0` [ðŸ”—](#class_AudioStreamWAV_property_loop_end)

<!-- classref-property-setget -->

- `void` **set_loop_end**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_loop_end**\ (\ )

The loop end point (in number of samples, relative to the beginning of the stream).

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_property_loop_mode"></a>

<!-- classref-property -->

[LoopMode](class_audiostreamwav.md#enum_AudioStreamWAV_LoopMode) **loop_mode** = `0` [ðŸ”—](#class_AudioStreamWAV_property_loop_mode)

<!-- classref-property-setget -->

- `void` **set_loop_mode**\ (\ value\: [LoopMode](class_audiostreamwav.md#enum_AudioStreamWAV_LoopMode)\ )
- [LoopMode](class_audiostreamwav.md#enum_AudioStreamWAV_LoopMode) **get_loop_mode**\ (\ )

The loop mode.

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_property_mix_rate"></a>

<!-- classref-property -->

[int](class_int.md) **mix_rate** = `44100` [ðŸ”—](#class_AudioStreamWAV_property_mix_rate)

<!-- classref-property-setget -->

- `void` **set_mix_rate**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_mix_rate**\ (\ )

The sample rate for mixing this audio. Higher values require more storage space, but result in better quality.

In games, common sample rates in use are ``11025``, ``16000``, ``22050``, ``32000``, ``44100``, and ``48000``.

According to the [Nyquist-Shannon sampling theorem](https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem), there is no quality difference to human hearing when going past 40,000 Hz (since most humans can only hear up to ~20,000 Hz, often less). If you are using lower-pitched sounds such as voices, lower sample rates such as ``32000`` or ``22050`` may be usable with no loss in quality.

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_property_stereo"></a>

<!-- classref-property -->

[bool](class_bool.md) **stereo** = `false` [ðŸ”—](#class_AudioStreamWAV_property_stereo)

<!-- classref-property-setget -->

- `void` **set_stereo**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **is_stereo**\ (\ )

If ``true``, audio is stereo.

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_property_tags"></a>

<!-- classref-property -->

[Dictionary](class_dictionary.md) **tags** = `{}` [ðŸ”—](#class_AudioStreamWAV_property_tags)

<!-- classref-property-setget -->

- `void` **set_tags**\ (\ value\: [Dictionary](class_dictionary.md)\ )
- [Dictionary](class_dictionary.md) **get_tags**\ (\ )

Contains user-defined tags if found in the WAV data.

Commonly used tags include ``title``, ``artist``, ``album``, ``tracknumber``, and ``date`` (``date`` does not have a standard date format).

\ **Note:** No tag is *guaranteed* to be present in every file, so make sure to account for the keys not always existing.

\ **Note:** Only WAV files using a ``LIST`` chunk with an identifier of ``INFO`` to encode the tags are currently supported.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_AudioStreamWAV_method_load_from_buffer"></a>

<!-- classref-method -->

[AudioStreamWAV](class_audiostreamwav.md) **load_from_buffer**\ (\ stream_data\: [PackedByteArray](class_packedbytearray.md), options\: [Dictionary](class_dictionary.md) = {}\ ) <span class="static">static</span> [ðŸ”—](#class_AudioStreamWAV_method_load_from_buffer)

Creates a new **AudioStreamWAV** instance from the given buffer. The buffer must contain WAV data.

The keys and values of `options` match the properties of [ResourceImporterWAV](class_resourceimporterwav.md). The usage of `options` is identical to [load_from_file()](class_audiostreamwav.md#class_AudioStreamWAV_method_load_from_file).

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_method_load_from_file"></a>

<!-- classref-method -->

[AudioStreamWAV](class_audiostreamwav.md) **load_from_file**\ (\ path\: [String](class_string.md), options\: [Dictionary](class_dictionary.md) = {}\ ) <span class="static">static</span> [ðŸ”—](#class_AudioStreamWAV_method_load_from_file)

Creates a new **AudioStreamWAV** instance from the given file path. The file must be in WAV format.

The keys and values of `options` match the properties of [ResourceImporterWAV](class_resourceimporterwav.md).

\ **Example:** Load the first file dropped as a WAV and play it:

```
    @onready var audio_player = $AudioStreamPlayer

    func _ready():
        get_window().files_dropped.connect(_on_files_dropped)

    func _on_files_dropped(files):
        if files[0].get_extension() == "wav":
            audio_player.stream = AudioStreamWAV.load_from_file(files[0], {
                    "force/max_rate": true,
                    "force/max_rate_hz": 11025
                })
            audio_player.play()
```

<hr class="classref-item-separator">

<a id="class_AudioStreamWAV_method_save_to_wav"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **save_to_wav**\ (\ path\: [String](class_string.md)\ ) [ðŸ”—](#class_AudioStreamWAV_method_save_to_wav)

Saves the AudioStreamWAV as a WAV file to `path`. Samples with IMA ADPCM or Quite OK Audio formats can't be saved.

\ **Note:** A ``.wav`` extension is automatically appended to `path` if it is missing.

