<!-- github_url: hide -->

<!-- keywords: sound, music, song -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/AudioStreamPlayer.xml. -->

<a id="class_AudioStreamPlayer"></a>

# AudioStreamPlayer

**Inherits:** [Node](class_node.md) **<** [Object](class_object.md)

A node for audio playback.

<!-- classref-introduction-group -->

## Description

The **AudioStreamPlayer** node plays an audio stream non-positionally. It is ideal for user interfaces, menus, or background music.

To use this node, [stream](class_audiostreamplayer.md#class_AudioStreamPlayer_property_stream) needs to be set to a valid [AudioStream](class_audiostream.md) resource. Playing more than one sound at the same time is also supported, see [max_polyphony](class_audiostreamplayer.md#class_AudioStreamPlayer_property_max_polyphony).

If you need to play audio at a specific position, use [AudioStreamPlayer2D](class_audiostreamplayer2d.md) or [AudioStreamPlayer3D](class_audiostreamplayer3d.md) instead.

<!-- classref-introduction-group -->

## Tutorials

- [Audio streams](../tutorials/audio/audio_streams.md)

- [2D Dodge The Creeps Demo](https://godotengine.org/asset-library/asset/2712)

- [Audio Device Changer Demo](https://godotengine.org/asset-library/asset/2758)

- [Audio Generator Demo](https://godotengine.org/asset-library/asset/2759)

- [Audio Microphone Record Demo](https://godotengine.org/asset-library/asset/2760)

- [Audio Spectrum Visualizer Demo](https://godotengine.org/asset-library/asset/2762)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[bool](class_bool.md)</th>
      <th>[autoplay](#class_AudioStreamPlayer_property_autoplay)</th>
      <th>`false`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[StringName](class_stringname.md)</td>
      <td>[bus](#class_AudioStreamPlayer_property_bus)</td>
      <td>`&"Master"`</td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[max_polyphony](#class_AudioStreamPlayer_property_max_polyphony)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[MixTarget](class_audiostreamplayer.md#enum_AudioStreamPlayer_MixTarget)</td>
      <td>[mix_target](#class_AudioStreamPlayer_property_mix_target)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[pitch_scale](#class_AudioStreamPlayer_property_pitch_scale)</td>
      <td>`1.0`</td>
    </tr>
    <tr>
      <td>[PlaybackType](class_audioserver.md#enum_AudioServer_PlaybackType)</td>
      <td>[playback_type](#class_AudioStreamPlayer_property_playback_type)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[playing](#class_AudioStreamPlayer_property_playing)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[AudioStream](class_audiostream.md)</td>
      <td>[stream](#class_AudioStreamPlayer_property_stream)</td>
      <td></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[stream_paused](#class_AudioStreamPlayer_property_stream_paused)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[volume_db](#class_AudioStreamPlayer_property_volume_db)</td>
      <td>`0.0`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[volume_linear](#class_AudioStreamPlayer_property_volume_linear)</td>
      <td></td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[float](class_float.md)</th>
      <th>[get_playback_position](#class_AudioStreamPlayer_method_get_playback_position)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[AudioStreamPlayback](class_audiostreamplayback.md)</td>
      <td>[get_stream_playback](#class_AudioStreamPlayer_method_get_stream_playback)\ (\ )</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[has_stream_playback](#class_AudioStreamPlayer_method_has_stream_playback)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[play](#class_AudioStreamPlayer_method_play)\ (\ from_position\: [float](class_float.md) = 0.0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[seek](#class_AudioStreamPlayer_method_seek)\ (\ to_position\: [float](class_float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[stop](#class_AudioStreamPlayer_method_stop)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Signals

<a id="class_AudioStreamPlayer_signal_finished"></a>

<!-- classref-signal -->

**finished**\ (\ ) [ðŸ”—](#class_AudioStreamPlayer_signal_finished)

Emitted when a sound finishes playing without interruptions. This signal is *not* emitted when calling [stop()](class_audiostreamplayer.md#class_AudioStreamPlayer_method_stop), or when exiting the tree while sounds are playing.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_AudioStreamPlayer_MixTarget"></a>

<!-- classref-enumeration -->

enum **MixTarget**: [ðŸ”—](#enum_AudioStreamPlayer_MixTarget)

<a id="class_AudioStreamPlayer_constant_MIX_TARGET_STEREO"></a>

<!-- classref-enumeration-constant -->

[MixTarget](class_audiostreamplayer.md#enum_AudioStreamPlayer_MixTarget) **MIX_TARGET_STEREO** = `0`

The audio will be played only on the first channel. This is the default.<a id="class_AudioStreamPlayer_constant_MIX_TARGET_SURROUND"></a>

<!-- classref-enumeration-constant -->

[MixTarget](class_audiostreamplayer.md#enum_AudioStreamPlayer_MixTarget) **MIX_TARGET_SURROUND** = `1`

The audio will be played on all surround channels.<a id="class_AudioStreamPlayer_constant_MIX_TARGET_CENTER"></a>

<!-- classref-enumeration-constant -->

[MixTarget](class_audiostreamplayer.md#enum_AudioStreamPlayer_MixTarget) **MIX_TARGET_CENTER** = `2`

The audio will be played on the second channel, which is usually the center.<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_AudioStreamPlayer_property_autoplay"></a>

<!-- classref-property -->

[bool](class_bool.md) **autoplay** = `false` [ðŸ”—](#class_AudioStreamPlayer_property_autoplay)

<!-- classref-property-setget -->

- `void` **set_autoplay**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **is_autoplay_enabled**\ (\ )

If ``true``, this node calls [play()](class_audiostreamplayer.md#class_AudioStreamPlayer_method_play) when entering the tree.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_bus"></a>

<!-- classref-property -->

[StringName](class_stringname.md) **bus** = `&"Master"` [ðŸ”—](#class_AudioStreamPlayer_property_bus)

<!-- classref-property-setget -->

- `void` **set_bus**\ (\ value\: [StringName](class_stringname.md)\ )
- [StringName](class_stringname.md) **get_bus**\ (\ )

The target bus name. All sounds from this node will be playing on this bus.

\ **Note:** At runtime, if no bus with the given name exists, all sounds will fall back on ``"Master"``. See also [AudioServer.get_bus_name()](class_audioserver.md#class_AudioServer_method_get_bus_name).

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_max_polyphony"></a>

<!-- classref-property -->

[int](class_int.md) **max_polyphony** = `1` [ðŸ”—](#class_AudioStreamPlayer_property_max_polyphony)

<!-- classref-property-setget -->

- `void` **set_max_polyphony**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_max_polyphony**\ (\ )

The maximum number of sounds this node can play at the same time. Calling [play()](class_audiostreamplayer.md#class_AudioStreamPlayer_method_play) after this value is reached will cut off the oldest sounds.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_mix_target"></a>

<!-- classref-property -->

[MixTarget](class_audiostreamplayer.md#enum_AudioStreamPlayer_MixTarget) **mix_target** = `0` [ðŸ”—](#class_AudioStreamPlayer_property_mix_target)

<!-- classref-property-setget -->

- `void` **set_mix_target**\ (\ value\: [MixTarget](class_audiostreamplayer.md#enum_AudioStreamPlayer_MixTarget)\ )
- [MixTarget](class_audiostreamplayer.md#enum_AudioStreamPlayer_MixTarget) **get_mix_target**\ (\ )

The mix target channels. Has no effect when two speakers or less are detected (see [SpeakerMode](class_audioserver.md#enum_AudioServer_SpeakerMode)).

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_pitch_scale"></a>

<!-- classref-property -->

[float](class_float.md) **pitch_scale** = `1.0` [ðŸ”—](#class_AudioStreamPlayer_property_pitch_scale)

<!-- classref-property-setget -->

- `void` **set_pitch_scale**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_pitch_scale**\ (\ )

The audio's pitch and tempo, as a multiplier of the [stream](class_audiostreamplayer.md#class_AudioStreamPlayer_property_stream)'s sample rate. A value of ``2.0`` doubles the audio's pitch, while a value of ``0.5`` halves the pitch.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_playback_type"></a>

<!-- classref-property -->

[PlaybackType](class_audioserver.md#enum_AudioServer_PlaybackType) **playback_type** = `0` [ðŸ”—](#class_AudioStreamPlayer_property_playback_type)

<!-- classref-property-setget -->

- `void` **set_playback_type**\ (\ value\: [PlaybackType](class_audioserver.md#enum_AudioServer_PlaybackType)\ )
- [PlaybackType](class_audioserver.md#enum_AudioServer_PlaybackType) **get_playback_type**\ (\ )

**Experimental:** This property may be changed or removed in future versions.

The playback type of the stream player. If set other than to the default value, it will force that playback type.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_playing"></a>

<!-- classref-property -->

[bool](class_bool.md) **playing** = `false` [ðŸ”—](#class_AudioStreamPlayer_property_playing)

<!-- classref-property-setget -->

- `void` **set_playing**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **is_playing**\ (\ )

If ``true``, this node is playing sounds. Setting this property has the same effect as [play()](class_audiostreamplayer.md#class_AudioStreamPlayer_method_play) and [stop()](class_audiostreamplayer.md#class_AudioStreamPlayer_method_stop).

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_stream"></a>

<!-- classref-property -->

[AudioStream](class_audiostream.md) **stream** [ðŸ”—](#class_AudioStreamPlayer_property_stream)

<!-- classref-property-setget -->

- `void` **set_stream**\ (\ value\: [AudioStream](class_audiostream.md)\ )
- [AudioStream](class_audiostream.md) **get_stream**\ (\ )

The [AudioStream](class_audiostream.md) resource to be played. Setting this property stops all currently playing sounds. If left empty, the **AudioStreamPlayer** does not work.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_stream_paused"></a>

<!-- classref-property -->

[bool](class_bool.md) **stream_paused** = `false` [ðŸ”—](#class_AudioStreamPlayer_property_stream_paused)

<!-- classref-property-setget -->

- `void` **set_stream_paused**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **get_stream_paused**\ (\ )

If ``true``, the sounds are paused. Setting [stream_paused](class_audiostreamplayer.md#class_AudioStreamPlayer_property_stream_paused) to ``false`` resumes all sounds.

\ **Note:** This property is automatically changed when exiting or entering the tree, or this node is paused (see [Node.process_mode](class_node.md#class_Node_property_process_mode)).

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_volume_db"></a>

<!-- classref-property -->

[float](class_float.md) **volume_db** = `0.0` [ðŸ”—](#class_AudioStreamPlayer_property_volume_db)

<!-- classref-property-setget -->

- `void` **set_volume_db**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_volume_db**\ (\ )

Volume of sound, in decibels. This is an offset of the [stream](class_audiostreamplayer.md#class_AudioStreamPlayer_property_stream)'s volume.

\ **Note:** To convert between decibel and linear energy (like most volume sliders do), use [volume_linear](class_audiostreamplayer.md#class_AudioStreamPlayer_property_volume_linear), or [@GlobalScope.db_to_linear()](class_@globalscope.md#class_@GlobalScope_method_db_to_linear) and [@GlobalScope.linear_to_db()](class_@globalscope.md#class_@GlobalScope_method_linear_to_db).

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_property_volume_linear"></a>

<!-- classref-property -->

[float](class_float.md) **volume_linear** [ðŸ”—](#class_AudioStreamPlayer_property_volume_linear)

<!-- classref-property-setget -->

- `void` **set_volume_linear**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_volume_linear**\ (\ )

Volume of sound, as a linear value.

\ **Note:** This member modifies [volume_db](class_audiostreamplayer.md#class_AudioStreamPlayer_property_volume_db) for convenience. The returned value is equivalent to the result of [@GlobalScope.db_to_linear()](class_@globalscope.md#class_@GlobalScope_method_db_to_linear) on [volume_db](class_audiostreamplayer.md#class_AudioStreamPlayer_property_volume_db). Setting this member is equivalent to setting [volume_db](class_audiostreamplayer.md#class_AudioStreamPlayer_property_volume_db) to the result of [@GlobalScope.linear_to_db()](class_@globalscope.md#class_@GlobalScope_method_linear_to_db) on a value.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_AudioStreamPlayer_method_get_playback_position"></a>

<!-- classref-method -->

[float](class_float.md) **get_playback_position**\ (\ ) [ðŸ”—](#class_AudioStreamPlayer_method_get_playback_position)

Returns the position in the [AudioStream](class_audiostream.md) of the latest sound, in seconds. Returns ``0.0`` if no sounds are playing.

\ **Note:** The position is not always accurate, as the [AudioServer](class_audioserver.md) does not mix audio every processed frame. To get more accurate results, add [AudioServer.get_time_since_last_mix()](class_audioserver.md#class_AudioServer_method_get_time_since_last_mix) to the returned position.

\ **Note:** This method always returns ``0.0`` if the [stream](class_audiostreamplayer.md#class_AudioStreamPlayer_property_stream) is an [AudioStreamInteractive](class_audiostreaminteractive.md), since it can have multiple clips playing at once.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_method_get_stream_playback"></a>

<!-- classref-method -->

[AudioStreamPlayback](class_audiostreamplayback.md) **get_stream_playback**\ (\ ) [ðŸ”—](#class_AudioStreamPlayer_method_get_stream_playback)

Returns the latest [AudioStreamPlayback](class_audiostreamplayback.md) of this node, usually the most recently created by [play()](class_audiostreamplayer.md#class_AudioStreamPlayer_method_play). If no sounds are playing, this method fails and returns an empty playback.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_method_has_stream_playback"></a>

<!-- classref-method -->

[bool](class_bool.md) **has_stream_playback**\ (\ ) [ðŸ”—](#class_AudioStreamPlayer_method_has_stream_playback)

Returns ``true`` if any sound is active, even if [stream_paused](class_audiostreamplayer.md#class_AudioStreamPlayer_property_stream_paused) is set to ``true``. See also [playing](class_audiostreamplayer.md#class_AudioStreamPlayer_property_playing) and [get_stream_playback()](class_audiostreamplayer.md#class_AudioStreamPlayer_method_get_stream_playback).

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_method_play"></a>

<!-- classref-method -->

`void` **play**\ (\ from_position\: [float](class_float.md) = 0.0\ ) [ðŸ”—](#class_AudioStreamPlayer_method_play)

Plays a sound from the beginning, or the given `from_position` in seconds.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_method_seek"></a>

<!-- classref-method -->

`void` **seek**\ (\ to_position\: [float](class_float.md)\ ) [ðŸ”—](#class_AudioStreamPlayer_method_seek)

Restarts all sounds to be played from the given `to_position`, in seconds. Does nothing if no sounds are playing.

<hr class="classref-item-separator">

<a id="class_AudioStreamPlayer_method_stop"></a>

<!-- classref-method -->

`void` **stop**\ (\ ) [ðŸ”—](#class_AudioStreamPlayer_method_stop)

Stops all sounds from this node.

