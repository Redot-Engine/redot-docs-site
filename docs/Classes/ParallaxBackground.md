<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/ParallaxBackground.xml. -->

<a id="ParallaxBackground"></a>

# ParallaxBackground

**Deprecated:** Use the [Parallax2D](Parallax2D.md) node instead.

**Inherits:** [CanvasLayer](CanvasLayer.md) **\<** [Node](Node.md) **\<** [Object](Object.md)

A node used to create a parallax scrolling background.

<!-- classref-introduction-group -->

## Description

A ParallaxBackground uses one or more [ParallaxLayer](ParallaxLayer.md) child nodes to create a parallax effect. Each [ParallaxLayer](ParallaxLayer.md) can move at a different speed using [ParallaxLayer.motion_offset](ParallaxLayer.md#ParallaxLayer_property_motion_offset). This creates an illusion of depth in a 2D game. If not used with a [Camera2D](Camera2D.md), you must manually calculate the [scroll_offset](ParallaxBackground.md#ParallaxBackground_property_scroll_offset).

\ **Note:** Each **ParallaxBackground** is drawn on one specific [Viewport](Viewport.md) and cannot be shared between multiple [Viewport](Viewport.md)\\ s, see [CanvasLayer.custom_viewport](CanvasLayer.md#CanvasLayer_property_custom_viewport). When using multiple [Viewport](Viewport.md)\\ s, for example in a split-screen game, you need create an individual **ParallaxBackground** for each [Viewport](Viewport.md) you want it to be drawn on.

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[int](int.md)</th>
      <th>layer</th>
      <th>`-100` (overrides [CanvasLayer.layer](CanvasLayer.md#CanvasLayer_property_layer))</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[scroll_base_offset](#ParallaxBackground_property_scroll_base_offset)</td>
      <td>`Vector2(0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[scroll_base_scale](#ParallaxBackground_property_scroll_base_scale)</td>
      <td>`Vector2(1, 1)`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[scroll_ignore_camera_zoom](#ParallaxBackground_property_scroll_ignore_camera_zoom)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[scroll_limit_begin](#ParallaxBackground_property_scroll_limit_begin)</td>
      <td>`Vector2(0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[scroll_limit_end](#ParallaxBackground_property_scroll_limit_end)</td>
      <td>`Vector2(0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[scroll_offset](#ParallaxBackground_property_scroll_offset)</td>
      <td>`Vector2(0, 0)`</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="ParallaxBackground_property_scroll_base_offset"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **scroll_base_offset** = `Vector2(0, 0)` [ðŸ”—](#ParallaxBackground_property_scroll_base_offset)

<!-- classref-property-setget -->

- `void` **set_scroll_base_offset**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_scroll_base_offset**\ (\ )

The base position offset for all [ParallaxLayer](ParallaxLayer.md) children.

<hr class="classref-item-separator"/>

<a id="ParallaxBackground_property_scroll_base_scale"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **scroll_base_scale** = `Vector2(1, 1)` [ðŸ”—](#ParallaxBackground_property_scroll_base_scale)

<!-- classref-property-setget -->

- `void` **set_scroll_base_scale**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_scroll_base_scale**\ (\ )

The base motion scale for all [ParallaxLayer](ParallaxLayer.md) children.

<hr class="classref-item-separator"/>

<a id="ParallaxBackground_property_scroll_ignore_camera_zoom"></a>

<!-- classref-property -->

[bool](bool.md) **scroll_ignore_camera_zoom** = `false` [ðŸ”—](#ParallaxBackground_property_scroll_ignore_camera_zoom)

<!-- classref-property-setget -->

- `void` **set_ignore_camera_zoom**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_ignore_camera_zoom**\ (\ )

If ``true``, elements in [ParallaxLayer](ParallaxLayer.md) child aren't affected by the zoom level of the camera.

<hr class="classref-item-separator"/>

<a id="ParallaxBackground_property_scroll_limit_begin"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **scroll_limit_begin** = `Vector2(0, 0)` [ðŸ”—](#ParallaxBackground_property_scroll_limit_begin)

<!-- classref-property-setget -->

- `void` **set_limit_begin**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_limit_begin**\ (\ )

Top-left limits for scrolling to begin. If the camera is outside of this limit, the background will stop scrolling. Must be lower than [scroll_limit_end](ParallaxBackground.md#ParallaxBackground_property_scroll_limit_end) to work.

<hr class="classref-item-separator"/>

<a id="ParallaxBackground_property_scroll_limit_end"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **scroll_limit_end** = `Vector2(0, 0)` [ðŸ”—](#ParallaxBackground_property_scroll_limit_end)

<!-- classref-property-setget -->

- `void` **set_limit_end**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_limit_end**\ (\ )

Bottom-right limits for scrolling to end. If the camera is outside of this limit, the background will stop scrolling. Must be higher than [scroll_limit_begin](ParallaxBackground.md#ParallaxBackground_property_scroll_limit_begin) to work.

<hr class="classref-item-separator"/>

<a id="ParallaxBackground_property_scroll_offset"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **scroll_offset** = `Vector2(0, 0)` [ðŸ”—](#ParallaxBackground_property_scroll_offset)

<!-- classref-property-setget -->

- `void` **set_scroll_offset**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_scroll_offset**\ (\ )

The ParallaxBackground's scroll value. Calculated automatically when using a [Camera2D](Camera2D.md), but can be used to manually manage scrolling when no camera is present.

