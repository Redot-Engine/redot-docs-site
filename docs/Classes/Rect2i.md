<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Rect2i.xml. -->

<a id="Rect2i"></a>

# Rect2i

A 2D axis-aligned bounding box using integer coordinates.

<!-- classref-introduction-group -->

## Description

The **Rect2i** built-in [Variant](Variant.md) type represents an axis-aligned rectangle in a 2D space, using integer coordinates. It is defined by its [position](Rect2i.md#Rect2i_property_position) and [size](Rect2i.md#Rect2i_property_size), which are [Vector2i](Vector2i.md). Because it does not rotate, it is frequently used for fast overlap tests (see [intersects()](Rect2i.md#Rect2i_method_intersects)).

For floating-point coordinates, see [Rect2](Rect2.md).

\ **Note:** Negative values for [size](Rect2i.md#Rect2i_property_size) are not supported. With negative size, most **Rect2i** methods do not work correctly. Use [abs()](Rect2i.md#Rect2i_method_abs) to get an equivalent **Rect2i** with a non-negative size.

\ **Note:** In a boolean context, a **Rect2i** evaluates to ``false`` if both [position](Rect2i.md#Rect2i_property_position) and [size](Rect2i.md#Rect2i_property_size) are zero (equal to [Vector2i.ZERO](Vector2i.md#Vector2i_constant_ZERO)). Otherwise, it always evaluates to ``true``.

<div class="note">
There are notable differences when using this API with C#. See the C# differences documentation for more information.

</div>

<!-- classref-introduction-group -->

## Tutorials

- [Math documentation index](../tutorials/math/index.md)

- [Vector math](../tutorials/math/vector_math.md)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[Vector2i](Vector2i.md)</th>
      <th>[end](#Rect2i_property_end)</th>
      <th>`Vector2i(0, 0)`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector2i](Vector2i.md)</td>
      <td>[position](#Rect2i_property_position)</td>
      <td>`Vector2i(0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector2i](Vector2i.md)</td>
      <td>[size](#Rect2i_property_size)</td>
      <td>`Vector2i(0, 0)`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Constructors

<table>
  <thead>
    <tr>
      <th>[Rect2i](Rect2i.md)</th>
      <th>[Rect2i](#Rect2i_constructor_Rect2i)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[Rect2i](#Rect2i_constructor_Rect2i)\ (\ from\: [Rect2i](Rect2i.md)\ )</td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[Rect2i](#Rect2i_constructor_Rect2i)\ (\ from\: [Rect2](Rect2.md)\ )</td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[Rect2i](#Rect2i_constructor_Rect2i)\ (\ position\: [Vector2i](Vector2i.md), size\: [Vector2i](Vector2i.md)\ )</td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[Rect2i](#Rect2i_constructor_Rect2i)\ (\ x\: [int](int.md), y\: [int](int.md), width\: [int](int.md), height\: [int](int.md)\ )</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Rect2i](Rect2i.md)</th>
      <th>[abs](#Rect2i_method_abs)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[encloses](#Rect2i_method_encloses)\ (\ b\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[expand](#Rect2i_method_expand)\ (\ to\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_area](#Rect2i_method_get_area)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2i](Vector2i.md)</td>
      <td>[get_center](#Rect2i_method_get_center)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[grow](#Rect2i_method_grow)\ (\ amount\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[grow_individual](#Rect2i_method_grow_individual)\ (\ left\: [int](int.md), top\: [int](int.md), right\: [int](int.md), bottom\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[grow_side](#Rect2i_method_grow_side)\ (\ side\: [int](int.md), amount\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_area](#Rect2i_method_has_area)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_point](#Rect2i_method_has_point)\ (\ point\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[intersection](#Rect2i_method_intersection)\ (\ b\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[intersects](#Rect2i_method_intersects)\ (\ b\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[merge](#Rect2i_method_merge)\ (\ b\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span></td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Operators

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[operator !=](#Rect2i_operator_neq_Rect2i)\ (\ right\: [Rect2i](Rect2i.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator ==](#Rect2i_operator_eq_Rect2i)\ (\ right\: [Rect2i](Rect2i.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="Rect2i_property_end"></a>

<!-- classref-property -->

[Vector2i](Vector2i.md) **end** = `Vector2i(0, 0)` [ðŸ”—](#Rect2i_property_end)

The ending point. This is usually the bottom-right corner of the rectangle, and is equivalent to ``position + size``. Setting this point affects the [size](Rect2i.md#Rect2i_property_size).

<hr class="classref-item-separator"/>

<a id="Rect2i_property_position"></a>

<!-- classref-property -->

[Vector2i](Vector2i.md) **position** = `Vector2i(0, 0)` [ðŸ”—](#Rect2i_property_position)

The origin point. This is usually the top-left corner of the rectangle.

<hr class="classref-item-separator"/>

<a id="Rect2i_property_size"></a>

<!-- classref-property -->

[Vector2i](Vector2i.md) **size** = `Vector2i(0, 0)` [ðŸ”—](#Rect2i_property_size)

The rectangle's width and height, starting from [position](Rect2i.md#Rect2i_property_position). Setting this value also affects the [end](Rect2i.md#Rect2i_property_end) point.

\ **Note:** It's recommended setting the width and height to non-negative values, as most methods in Redot assume that the [position](Rect2i.md#Rect2i_property_position) is the top-left corner, and the [end](Rect2i.md#Rect2i_property_end) is the bottom-right corner. To get an equivalent rectangle with non-negative size, use [abs()](Rect2i.md#Rect2i_method_abs).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Constructor Descriptions

<a id="Rect2i_constructor_Rect2i"></a>

<!-- classref-constructor -->

[Rect2i](Rect2i.md) **Rect2i**\ (\ ) [ðŸ”—](#Rect2i_constructor_Rect2i)

Constructs a **Rect2i** with its [position](Rect2i.md#Rect2i_property_position) and [size](Rect2i.md#Rect2i_property_size) set to [Vector2i.ZERO](Vector2i.md#Vector2i_constant_ZERO).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Rect2i](Rect2i.md) **Rect2i**\ (\ from\: [Rect2i](Rect2i.md)\ )

Constructs a **Rect2i** as a copy of the given **Rect2i**.

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Rect2i](Rect2i.md) **Rect2i**\ (\ from\: [Rect2](Rect2.md)\ )

Constructs a **Rect2i** from a [Rect2](Rect2.md). The floating-point coordinates are truncated.

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Rect2i](Rect2i.md) **Rect2i**\ (\ position\: [Vector2i](Vector2i.md), size\: [Vector2i](Vector2i.md)\ )

Constructs a **Rect2i** by `position` and `size`.

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Rect2i](Rect2i.md) **Rect2i**\ (\ x\: [int](int.md), y\: [int](int.md), width\: [int](int.md), height\: [int](int.md)\ )

Constructs a **Rect2i** by setting its [position](Rect2i.md#Rect2i_property_position) to (`x`, `y`), and its [size](Rect2i.md#Rect2i_property_size) to (`width`, `height`).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Rect2i_method_abs"></a>

<!-- classref-method -->

[Rect2i](Rect2i.md) **abs**\ (\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_abs)

Returns a **Rect2i** equivalent to this rectangle, with its width and height modified to be non-negative values, and with its [position](Rect2i.md#Rect2i_property_position) being the top-left corner of the rectangle.




```gdscript
    var rect = Rect2i(25, 25, -100, -50)
    var absolute = rect.abs() # absolute is Rect2i(-75, -25, 100, 50)
```


```csharp
    var rect = new Rect2I(25, 25, -100, -50);
    var absolute = rect.Abs(); // absolute is Rect2I(-75, -25, 100, 50)
```




\ **Note:** It's recommended to use this method when [size](Rect2i.md#Rect2i_property_size) is negative, as most other methods in Redot assume that the [position](Rect2i.md#Rect2i_property_position) is the top-left corner, and the [end](Rect2i.md#Rect2i_property_end) is the bottom-right corner.

<hr class="classref-item-separator"/>

<a id="Rect2i_method_encloses"></a>

<!-- classref-method -->

[bool](bool.md) **encloses**\ (\ b\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_encloses)

Returns ``true`` if this **Rect2i** completely encloses another one.

<hr class="classref-item-separator"/>

<a id="Rect2i_method_expand"></a>

<!-- classref-method -->

[Rect2i](Rect2i.md) **expand**\ (\ to\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_expand)

Returns a copy of this rectangle expanded to align the edges with the given `to` point, if necessary.




```gdscript
    var rect = Rect2i(0, 0, 5, 2)

    rect = rect.expand(Vector2i(10, 0)) # rect is Rect2i(0, 0, 10, 2)
    rect = rect.expand(Vector2i(-5, 5)) # rect is Rect2i(-5, 0, 15, 5)
```


```csharp
    var rect = new Rect2I(0, 0, 5, 2);

    rect = rect.Expand(new Vector2I(10, 0)); // rect is Rect2I(0, 0, 10, 2)
    rect = rect.Expand(new Vector2I(-5, 5)); // rect is Rect2I(-5, 0, 15, 5)
```




<hr class="classref-item-separator"/>

<a id="Rect2i_method_get_area"></a>

<!-- classref-method -->

[int](int.md) **get_area**\ (\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_get_area)

Returns the rectangle's area. This is equivalent to ``size.x * size.y``. See also [has_area()](Rect2i.md#Rect2i_method_has_area).

<hr class="classref-item-separator"/>

<a id="Rect2i_method_get_center"></a>

<!-- classref-method -->

[Vector2i](Vector2i.md) **get_center**\ (\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_get_center)

Returns the center point of the rectangle. This is the same as ``position + (size / 2)``.

\ **Note:** If the [size](Rect2i.md#Rect2i_property_size) is odd, the result will be rounded towards [position](Rect2i.md#Rect2i_property_position).

<hr class="classref-item-separator"/>

<a id="Rect2i_method_grow"></a>

<!-- classref-method -->

[Rect2i](Rect2i.md) **grow**\ (\ amount\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_grow)

Returns a copy of this rectangle extended on all sides by the given `amount`. A negative `amount` shrinks the rectangle instead. See also [grow_individual()](Rect2i.md#Rect2i_method_grow_individual) and [grow_side()](Rect2i.md#Rect2i_method_grow_side).




```gdscript
    var a = Rect2i(4, 4, 8, 8).grow(4) # a is Rect2i(0, 0, 16, 16)
    var b = Rect2i(0, 0, 8, 4).grow(2) # b is Rect2i(-2, -2, 12, 8)
```


```csharp
    var a = new Rect2I(4, 4, 8, 8).Grow(4); // a is Rect2I(0, 0, 16, 16)
    var b = new Rect2I(0, 0, 8, 4).Grow(2); // b is Rect2I(-2, -2, 12, 8)
```




<hr class="classref-item-separator"/>

<a id="Rect2i_method_grow_individual"></a>

<!-- classref-method -->

[Rect2i](Rect2i.md) **grow_individual**\ (\ left\: [int](int.md), top\: [int](int.md), right\: [int](int.md), bottom\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_grow_individual)

Returns a copy of this rectangle with its `left`, `top`, `right`, and `bottom` sides extended by the given amounts. Negative values shrink the sides, instead. See also [grow()](Rect2i.md#Rect2i_method_grow) and [grow_side()](Rect2i.md#Rect2i_method_grow_side).

<hr class="classref-item-separator"/>

<a id="Rect2i_method_grow_side"></a>

<!-- classref-method -->

[Rect2i](Rect2i.md) **grow_side**\ (\ side\: [int](int.md), amount\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_grow_side)

Returns a copy of this rectangle with its `side` extended by the given `amount` (see [Side](@GlobalScope.md#enum_@GlobalScope_Side) constants). A negative `amount` shrinks the rectangle, instead. See also [grow()](Rect2i.md#Rect2i_method_grow) and [grow_individual()](Rect2i.md#Rect2i_method_grow_individual).

<hr class="classref-item-separator"/>

<a id="Rect2i_method_has_area"></a>

<!-- classref-method -->

[bool](bool.md) **has_area**\ (\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_has_area)

Returns ``true`` if this rectangle has positive width and height. See also [get_area()](Rect2i.md#Rect2i_method_get_area).

<hr class="classref-item-separator"/>

<a id="Rect2i_method_has_point"></a>

<!-- classref-method -->

[bool](bool.md) **has_point**\ (\ point\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_has_point)

Returns ``true`` if the rectangle contains the given `point`. By convention, points on the right and bottom edges are **not** included.

\ **Note:** This method is not reliable for **Rect2i** with a *negative* [size](Rect2i.md#Rect2i_property_size). Use [abs()](Rect2i.md#Rect2i_method_abs) first to get a valid rectangle.

<hr class="classref-item-separator"/>

<a id="Rect2i_method_intersection"></a>

<!-- classref-method -->

[Rect2i](Rect2i.md) **intersection**\ (\ b\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_intersection)

Returns the intersection between this rectangle and `b`. If the rectangles do not intersect, returns an empty **Rect2i**.




```gdscript
    var a = Rect2i(0, 0, 5, 10)
    var b = Rect2i(2, 0, 8, 4)

    var c = a.intersection(b) # c is Rect2i(2, 0, 3, 4)
```


```csharp
    var a = new Rect2I(0, 0, 5, 10);
    var b = new Rect2I(2, 0, 8, 4);

    var c = rect1.Intersection(rect2); // c is Rect2I(2, 0, 3, 4)
```




\ **Note:** If you only need to know whether two rectangles are overlapping, use [intersects()](Rect2i.md#Rect2i_method_intersects), instead.

<hr class="classref-item-separator"/>

<a id="Rect2i_method_intersects"></a>

<!-- classref-method -->

[bool](bool.md) **intersects**\ (\ b\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_intersects)

Returns ``true`` if this rectangle overlaps with the `b` rectangle. The edges of both rectangles are excluded.

<hr class="classref-item-separator"/>

<a id="Rect2i_method_merge"></a>

<!-- classref-method -->

[Rect2i](Rect2i.md) **merge**\ (\ b\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span> [ðŸ”—](#Rect2i_method_merge)

Returns a **Rect2i** that encloses both this rectangle and `b` around the edges. See also [encloses()](Rect2i.md#Rect2i_method_encloses).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Operator Descriptions

<a id="Rect2i_operator_neq_Rect2i"></a>

<!-- classref-operator -->

[bool](bool.md) **operator !=**\ (\ right\: [Rect2i](Rect2i.md)\ ) [ðŸ”—](#Rect2i_operator_neq_Rect2i)

Returns ``true`` if the [position](Rect2i.md#Rect2i_property_position) or [size](Rect2i.md#Rect2i_property_size) of both rectangles are not equal.

<hr class="classref-item-separator"/>

<a id="Rect2i_operator_eq_Rect2i"></a>

<!-- classref-operator -->

[bool](bool.md) **operator ==**\ (\ right\: [Rect2i](Rect2i.md)\ ) [ðŸ”—](#Rect2i_operator_eq_Rect2i)

Returns ``true`` if both [position](Rect2i.md#Rect2i_property_position) and [size](Rect2i.md#Rect2i_property_size) of the rectangles are equal, respectively.

