<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Crypto.xml. -->

<a id="class_Crypto"></a>

# Crypto

**Inherits:** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

Provides access to advanced cryptographic functionalities.

<!-- classref-introduction-group -->

## Description

The Crypto class provides access to advanced cryptographic functionalities.

Currently, this includes asymmetric key encryption/decryption, signing/verification, and generating cryptographically secure random bytes, RSA keys, HMAC digests, and self-signed [X509Certificate](class_x509certificate.md)\ s.




```gdscript
    var crypto = Crypto.new()

    # Generate new RSA key.
    var key = crypto.generate_rsa(4096)

    # Generate new self-signed certificate with the given key.
    var cert = crypto.generate_self_signed_certificate(key, "CN=mydomain.com,O=My Game Company,C=IT")

    # Save key and certificate in the user folder.
    key.save("user://generated.key")
    cert.save("user://generated.crt")

    # Encryption
    var data = "Some data"
    var encrypted = crypto.encrypt(key, data.to_utf8_buffer())

    # Decryption
    var decrypted = crypto.decrypt(key, encrypted)

    # Signing
    var signature = crypto.sign(HashingContext.HASH_SHA256, data.sha256_buffer(), key)

    # Verifying
    var verified = crypto.verify(HashingContext.HASH_SHA256, data.sha256_buffer(), signature, key)

    # Checks
    assert(verified)
    assert(data.to_utf8_buffer() == decrypted)
```

```csharp
    using Godot;
    using System.Diagnostics;

    Crypto crypto = new Crypto();

    // Generate new RSA key.
    CryptoKey key = crypto.GenerateRsa(4096);

    // Generate new self-signed certificate with the given key.
    X509Certificate cert = crypto.GenerateSelfSignedCertificate(key, "CN=mydomain.com,O=My Game Company,C=IT");

    // Save key and certificate in the user folder.
    key.Save("user://generated.key");
    cert.Save("user://generated.crt");

    // Encryption
    string data = "Some data";
    byte[] encrypted = crypto.Encrypt(key, data.ToUtf8Buffer());

    // Decryption
    byte[] decrypted = crypto.Decrypt(key, encrypted);

    // Signing
    byte[] signature = crypto.Sign(HashingContext.HashType.Sha256, Data.Sha256Buffer(), key);

    // Verifying
    bool verified = crypto.Verify(HashingContext.HashType.Sha256, Data.Sha256Buffer(), signature, key);

    // Checks
    Debug.Assert(verified);
    Debug.Assert(data.ToUtf8Buffer() == decrypted);
```



<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[bool](class_bool.md)</th>
      <th>[constant_time_compare](#class_Crypto_method_constant_time_compare)\ (\ trusted\: [PackedByteArray](class_packedbytearray.md), received\: [PackedByteArray](class_packedbytearray.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[PackedByteArray](class_packedbytearray.md)</td>
      <td>[decrypt](#class_Crypto_method_decrypt)\ (\ key\: [CryptoKey](class_cryptokey.md), ciphertext\: [PackedByteArray](class_packedbytearray.md)\ )</td>
    </tr>
    <tr>
      <td>[PackedByteArray](class_packedbytearray.md)</td>
      <td>[encrypt](#class_Crypto_method_encrypt)\ (\ key\: [CryptoKey](class_cryptokey.md), plaintext\: [PackedByteArray](class_packedbytearray.md)\ )</td>
    </tr>
    <tr>
      <td>[PackedByteArray](class_packedbytearray.md)</td>
      <td>[generate_random_bytes](#class_Crypto_method_generate_random_bytes)\ (\ size\: [int](class_int.md)\ )</td>
    </tr>
    <tr>
      <td>[CryptoKey](class_cryptokey.md)</td>
      <td>[generate_rsa](#class_Crypto_method_generate_rsa)\ (\ size\: [int](class_int.md)\ )</td>
    </tr>
    <tr>
      <td>[X509Certificate](class_x509certificate.md)</td>
      <td>[generate_self_signed_certificate](#class_Crypto_method_generate_self_signed_certificate)\ (\ key\: [CryptoKey](class_cryptokey.md), issuer_name\: [String](class_string.md) = "CN=myserver,O=myorganisation,C=IT", not_before\: [String](class_string.md) = "20140101000000", not_after\: [String](class_string.md) = "20340101000000"\ )</td>
    </tr>
    <tr>
      <td>[PackedByteArray](class_packedbytearray.md)</td>
      <td>[hmac_digest](#class_Crypto_method_hmac_digest)\ (\ hash_type\: [HashType](class_hashingcontext.md#enum_HashingContext_HashType), key\: [PackedByteArray](class_packedbytearray.md), msg\: [PackedByteArray](class_packedbytearray.md)\ )</td>
    </tr>
    <tr>
      <td>[PackedByteArray](class_packedbytearray.md)</td>
      <td>[sign](#class_Crypto_method_sign)\ (\ hash_type\: [HashType](class_hashingcontext.md#enum_HashingContext_HashType), hash\: [PackedByteArray](class_packedbytearray.md), key\: [CryptoKey](class_cryptokey.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[verify](#class_Crypto_method_verify)\ (\ hash_type\: [HashType](class_hashingcontext.md#enum_HashingContext_HashType), hash\: [PackedByteArray](class_packedbytearray.md), signature\: [PackedByteArray](class_packedbytearray.md), key\: [CryptoKey](class_cryptokey.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_Crypto_method_constant_time_compare"></a>

<!-- classref-method -->

[bool](class_bool.md) **constant_time_compare**\ (\ trusted\: [PackedByteArray](class_packedbytearray.md), received\: [PackedByteArray](class_packedbytearray.md)\ ) [ðŸ”—](#class_Crypto_method_constant_time_compare)

Compares two [PackedByteArray](class_packedbytearray.md)\ s for equality without leaking timing information in order to prevent timing attacks.

See [this blog post](https://paragonie.com/blog/2015/11/preventing-timing-attacks-on-string-comparison-with-double-hmac-strategy) for more information.

<hr class="classref-item-separator">

<a id="class_Crypto_method_decrypt"></a>

<!-- classref-method -->

[PackedByteArray](class_packedbytearray.md) **decrypt**\ (\ key\: [CryptoKey](class_cryptokey.md), ciphertext\: [PackedByteArray](class_packedbytearray.md)\ ) [ðŸ”—](#class_Crypto_method_decrypt)

Decrypt the given `ciphertext` with the provided private `key`.

\ **Note:** The maximum size of accepted ciphertext is limited by the key size.

<hr class="classref-item-separator">

<a id="class_Crypto_method_encrypt"></a>

<!-- classref-method -->

[PackedByteArray](class_packedbytearray.md) **encrypt**\ (\ key\: [CryptoKey](class_cryptokey.md), plaintext\: [PackedByteArray](class_packedbytearray.md)\ ) [ðŸ”—](#class_Crypto_method_encrypt)

Encrypt the given `plaintext` with the provided public `key`.

\ **Note:** The maximum size of accepted plaintext is limited by the key size.

<hr class="classref-item-separator">

<a id="class_Crypto_method_generate_random_bytes"></a>

<!-- classref-method -->

[PackedByteArray](class_packedbytearray.md) **generate_random_bytes**\ (\ size\: [int](class_int.md)\ ) [ðŸ”—](#class_Crypto_method_generate_random_bytes)

Generates a [PackedByteArray](class_packedbytearray.md) of cryptographically secure random bytes with given `size`.

<hr class="classref-item-separator">

<a id="class_Crypto_method_generate_rsa"></a>

<!-- classref-method -->

[CryptoKey](class_cryptokey.md) **generate_rsa**\ (\ size\: [int](class_int.md)\ ) [ðŸ”—](#class_Crypto_method_generate_rsa)

Generates an RSA [CryptoKey](class_cryptokey.md) that can be used for creating self-signed certificates and passed to [StreamPeerTLS.accept_stream()](class_streampeertls.md#class_StreamPeerTLS_method_accept_stream).

<hr class="classref-item-separator">

<a id="class_Crypto_method_generate_self_signed_certificate"></a>

<!-- classref-method -->

[X509Certificate](class_x509certificate.md) **generate_self_signed_certificate**\ (\ key\: [CryptoKey](class_cryptokey.md), issuer_name\: [String](class_string.md) = "CN=myserver,O=myorganisation,C=IT", not_before\: [String](class_string.md) = "20140101000000", not_after\: [String](class_string.md) = "20340101000000"\ ) [ðŸ”—](#class_Crypto_method_generate_self_signed_certificate)

Generates a self-signed [X509Certificate](class_x509certificate.md) from the given [CryptoKey](class_cryptokey.md) and `issuer_name`. The certificate validity will be defined by `not_before` and `not_after` (first valid date and last valid date). The `issuer_name` must contain at least "CN=" (common name, i.e. the domain name), "O=" (organization, i.e. your company name), "C=" (country, i.e. 2 lettered ISO-3166 code of the country the organization is based in).

A small example to generate an RSA key and an X509 self-signed certificate.




```gdscript
    var crypto = Crypto.new()
    # Generate 4096 bits RSA key.
    var key = crypto.generate_rsa(4096)
    # Generate self-signed certificate using the given key.
    var cert = crypto.generate_self_signed_certificate(key, "CN=example.com,O=A Game Company,C=IT")
```

```csharp
    var crypto = new Crypto();
    // Generate 4096 bits RSA key.
    CryptoKey key = crypto.GenerateRsa(4096);
    // Generate self-signed certificate using the given key.
    X509Certificate cert = crypto.GenerateSelfSignedCertificate(key, "CN=mydomain.com,O=My Game Company,C=IT");
```



<hr class="classref-item-separator">

<a id="class_Crypto_method_hmac_digest"></a>

<!-- classref-method -->

[PackedByteArray](class_packedbytearray.md) **hmac_digest**\ (\ hash_type\: [HashType](class_hashingcontext.md#enum_HashingContext_HashType), key\: [PackedByteArray](class_packedbytearray.md), msg\: [PackedByteArray](class_packedbytearray.md)\ ) [ðŸ”—](#class_Crypto_method_hmac_digest)

Generates an [HMAC](https://en.wikipedia.org/wiki/HMAC) digest of `msg` using `key`. The `hash_type` parameter is the hashing algorithm that is used for the inner and outer hashes.

Currently, only [HashingContext.HASH_SHA256](class_hashingcontext.md#class_HashingContext_constant_HASH_SHA256) and [HashingContext.HASH_SHA1](class_hashingcontext.md#class_HashingContext_constant_HASH_SHA1) are supported.

<hr class="classref-item-separator">

<a id="class_Crypto_method_sign"></a>

<!-- classref-method -->

[PackedByteArray](class_packedbytearray.md) **sign**\ (\ hash_type\: [HashType](class_hashingcontext.md#enum_HashingContext_HashType), hash\: [PackedByteArray](class_packedbytearray.md), key\: [CryptoKey](class_cryptokey.md)\ ) [ðŸ”—](#class_Crypto_method_sign)

Sign a given `hash` of type `hash_type` with the provided private `key`.

<hr class="classref-item-separator">

<a id="class_Crypto_method_verify"></a>

<!-- classref-method -->

[bool](class_bool.md) **verify**\ (\ hash_type\: [HashType](class_hashingcontext.md#enum_HashingContext_HashType), hash\: [PackedByteArray](class_packedbytearray.md), signature\: [PackedByteArray](class_packedbytearray.md), key\: [CryptoKey](class_cryptokey.md)\ ) [ðŸ”—](#class_Crypto_method_verify)

Verify that a given `signature` for `hash` of type `hash_type` against the provided public `key`.

