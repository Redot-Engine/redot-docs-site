<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/CanvasLayer.xml. -->

<a id="CanvasLayer"></a>

# CanvasLayer

**Inherits:** [Node](Node.md) **\<** [Object](Object.md)

**Inherited By:** [ParallaxBackground](ParallaxBackground.md)

A node used for independent rendering of objects within a 2D scene.

<!-- classref-introduction-group -->

## Description

[CanvasItem](CanvasItem.md)-derived nodes that are direct or indirect children of a **CanvasLayer** will be drawn in that layer. The layer is a numeric index that defines the draw order. The default 2D scene renders with index ``0``, so a **CanvasLayer** with index ``-1`` will be drawn below, and a **CanvasLayer** with index ``1`` will be drawn above. This order will hold regardless of the [CanvasItem.z_index](CanvasItem.md#CanvasItem_property_z_index) of the nodes within each layer.

\ **CanvasLayer**\\ s can be hidden and they can also optionally follow the viewport. This makes them useful for HUDs like health bar overlays (on layers ``1`` and higher) or backgrounds (on layers ``-1`` and lower).

\ **Note:** Embedded [Window](Window.md)\\ s are placed on layer ``1024``. [CanvasItem](CanvasItem.md)\\ s on layers ``1025`` and higher appear in front of embedded windows.

\ **Note:** Each **CanvasLayer** is drawn on one specific [Viewport](Viewport.md) and cannot be shared between multiple [Viewport](Viewport.md)\\ s, see [custom_viewport](CanvasLayer.md#CanvasLayer_property_custom_viewport). When using multiple [Viewport](Viewport.md)\\ s, for example in a split-screen game, you need to create an individual **CanvasLayer** for each [Viewport](Viewport.md) you want it to be drawn on.

<!-- classref-introduction-group -->

## Tutorials

- [Viewport and canvas transforms](../tutorials/2d/2d_transforms.md)

- [Canvas layers](../tutorials/2d/canvas_layers.md)

- [2D Dodge The Creeps Demo](https://godotengine.org/asset-library/asset/2712)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[Node](Node.md)</th>
      <th>[custom_viewport](#CanvasLayer_property_custom_viewport)</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[follow_viewport_enabled](#CanvasLayer_property_follow_viewport_enabled)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[follow_viewport_scale](#CanvasLayer_property_follow_viewport_scale)</td>
      <td>`1.0`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[layer](#CanvasLayer_property_layer)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[offset](#CanvasLayer_property_offset)</td>
      <td>`Vector2(0, 0)`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[rotation](#CanvasLayer_property_rotation)</td>
      <td>`0.0`</td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[scale](#CanvasLayer_property_scale)</td>
      <td>`Vector2(1, 1)`</td>
    </tr>
    <tr>
      <td>[Transform2D](Transform2D.md)</td>
      <td>[transform](#CanvasLayer_property_transform)</td>
      <td>`Transform2D(1, 0, 0, 1, 0, 0)`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[visible](#CanvasLayer_property_visible)</td>
      <td>`true`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[RID](RID.md)</th>
      <th>[get_canvas](#CanvasLayer_method_get_canvas)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Transform2D](Transform2D.md)</td>
      <td>[get_final_transform](#CanvasLayer_method_get_final_transform)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[hide](#CanvasLayer_method_hide)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[show](#CanvasLayer_method_show)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Signals

<a id="CanvasLayer_signal_visibility_changed"></a>

<!-- classref-signal -->

**visibility_changed**\ (\ ) [ðŸ”—](#CanvasLayer_signal_visibility_changed)

Emitted when visibility of the layer is changed. See [visible](CanvasLayer.md#CanvasLayer_property_visible).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="CanvasLayer_property_custom_viewport"></a>

<!-- classref-property -->

[Node](Node.md) **custom_viewport** [ðŸ”—](#CanvasLayer_property_custom_viewport)

<!-- classref-property-setget -->

- `void` **set_custom_viewport**\ (\ value\: [Node](Node.md)\ )
- [Node](Node.md) **get_custom_viewport**\ (\ )

The custom [Viewport](Viewport.md) node assigned to the **CanvasLayer**. If ``null``, uses the default viewport instead.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_property_follow_viewport_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **follow_viewport_enabled** = `false` [ðŸ”—](#CanvasLayer_property_follow_viewport_enabled)

<!-- classref-property-setget -->

- `void` **set_follow_viewport**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_following_viewport**\ (\ )

If enabled, the **CanvasLayer** maintains its position in world space. If disabled, the **CanvasLayer** stays in a fixed position on the screen.

Together with [follow_viewport_scale](CanvasLayer.md#CanvasLayer_property_follow_viewport_scale), this can be used for a pseudo-3D effect.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_property_follow_viewport_scale"></a>

<!-- classref-property -->

[float](float.md) **follow_viewport_scale** = `1.0` [ðŸ”—](#CanvasLayer_property_follow_viewport_scale)

<!-- classref-property-setget -->

- `void` **set_follow_viewport_scale**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_follow_viewport_scale**\ (\ )

Scales the layer when using [follow_viewport_enabled](CanvasLayer.md#CanvasLayer_property_follow_viewport_enabled). Layers moving into the foreground should have increasing scales, while layers moving into the background should have decreasing scales.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_property_layer"></a>

<!-- classref-property -->

[int](int.md) **layer** = `1` [ðŸ”—](#CanvasLayer_property_layer)

<!-- classref-property-setget -->

- `void` **set_layer**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_layer**\ (\ )

Layer index for draw order. Lower values are drawn behind higher values.

\ **Note:** If multiple CanvasLayers have the same layer index, [CanvasItem](CanvasItem.md) children of one CanvasLayer are drawn behind the [CanvasItem](CanvasItem.md) children of the other CanvasLayer. Which CanvasLayer is drawn in front is non-deterministic.

\ **Note:** The layer index should be between [RenderingServer.CANVAS_LAYER_MIN](RenderingServer.md#RenderingServer_constant_CANVAS_LAYER_MIN) and [RenderingServer.CANVAS_LAYER_MAX](RenderingServer.md#RenderingServer_constant_CANVAS_LAYER_MAX) (inclusive). Any other value will wrap around.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_property_offset"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **offset** = `Vector2(0, 0)` [ðŸ”—](#CanvasLayer_property_offset)

<!-- classref-property-setget -->

- `void` **set_offset**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_offset**\ (\ )

The layer's base offset.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_property_rotation"></a>

<!-- classref-property -->

[float](float.md) **rotation** = `0.0` [ðŸ”—](#CanvasLayer_property_rotation)

<!-- classref-property-setget -->

- `void` **set_rotation**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_rotation**\ (\ )

The layer's rotation in radians.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_property_scale"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **scale** = `Vector2(1, 1)` [ðŸ”—](#CanvasLayer_property_scale)

<!-- classref-property-setget -->

- `void` **set_scale**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_scale**\ (\ )

The layer's scale.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_property_transform"></a>

<!-- classref-property -->

[Transform2D](Transform2D.md) **transform** = `Transform2D(1, 0, 0, 1, 0, 0)` [ðŸ”—](#CanvasLayer_property_transform)

<!-- classref-property-setget -->

- `void` **set_transform**\ (\ value\: [Transform2D](Transform2D.md)\ )
- [Transform2D](Transform2D.md) **get_transform**\ (\ )

The layer's transform.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_property_visible"></a>

<!-- classref-property -->

[bool](bool.md) **visible** = `true` [ðŸ”—](#CanvasLayer_property_visible)

<!-- classref-property-setget -->

- `void` **set_visible**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_visible**\ (\ )

If ``false``, any [CanvasItem](CanvasItem.md) under this **CanvasLayer** will be hidden.

Unlike [CanvasItem.visible](CanvasItem.md#CanvasItem_property_visible), visibility of a **CanvasLayer** isn't propagated to underlying layers.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="CanvasLayer_method_get_canvas"></a>

<!-- classref-method -->

[RID](RID.md) **get_canvas**\ (\ ) <span class="const">const</span> [ðŸ”—](#CanvasLayer_method_get_canvas)

Returns the RID of the canvas used by this layer.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_method_get_final_transform"></a>

<!-- classref-method -->

[Transform2D](Transform2D.md) **get_final_transform**\ (\ ) <span class="const">const</span> [ðŸ”—](#CanvasLayer_method_get_final_transform)

Returns the transform from the **CanvasLayer**\\ s coordinate system to the [Viewport](Viewport.md)\\ s coordinate system.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_method_hide"></a>

<!-- classref-method -->

`void` **hide**\ (\ ) [ðŸ”—](#CanvasLayer_method_hide)

Hides any [CanvasItem](CanvasItem.md) under this **CanvasLayer**. This is equivalent to setting [visible](CanvasLayer.md#CanvasLayer_property_visible) to ``false``.

<hr class="classref-item-separator"/>

<a id="CanvasLayer_method_show"></a>

<!-- classref-method -->

`void` **show**\ (\ ) [ðŸ”—](#CanvasLayer_method_show)

Shows any [CanvasItem](CanvasItem.md) under this **CanvasLayer**. This is equivalent to setting [visible](CanvasLayer.md#CanvasLayer_property_visible) to ``true``.

