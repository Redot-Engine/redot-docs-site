<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/HMACContext.xml. -->

<a id="HMACContext"></a>

# HMACContext

**Inherits:** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

Used to create an HMAC for a message using a key.

<!-- classref-introduction-group -->

## Description

The HMACContext class is useful for advanced HMAC use cases, such as streaming the message as it supports creating the message over time rather than providing it all at once.




```gdscript
    extends Node
    var ctx = HMACContext.new()

    func _ready():
        var key = "supersecret".to_utf8_buffer()
        var err = ctx.start(HashingContext.HASH_SHA256, key)
        assert(err == OK)
        var msg1 = "this is ".to_utf8_buffer()
        var msg2 = "super duper secret".to_utf8_buffer()
        err = ctx.update(msg1)
        assert(err == OK)
        err = ctx.update(msg2)
        assert(err == OK)
        var hmac = ctx.finish()
        print(hmac.hex_encode())
```


```csharp
    using Godot;
    using System.Diagnostics;

    public partial class MyNode : Node
    {
        private HmacContext _ctx = new HmacContext();

        public override void _Ready()
        {
            byte[] key = "supersecret".ToUtf8Buffer();
            Error err = _ctx.Start(HashingContext.HashType.Sha256, key);
            Debug.Assert(err == Error.Ok);
            byte[] msg1 = "this is ".ToUtf8Buffer();
            byte[] msg2 = "super duper secret".ToUtf8Buffer();
            err = _ctx.Update(msg1);
            Debug.Assert(err == Error.Ok);
            err = _ctx.Update(msg2);
            Debug.Assert(err == Error.Ok);
            byte[] hmac = _ctx.Finish();
            GD.Print(hmac.HexEncode());
        }
    }
```




<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[PackedByteArray](PackedByteArray.md)</th>
      <th>[finish](#HMACContext_method_finish)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Error](@GlobalScope.md#enum_@GlobalScope_Error)</td>
      <td>[start](#HMACContext_method_start)\ (\ hash_type\: [HashType](HashingContext.md#enum_HashingContext_HashType), key\: [PackedByteArray](PackedByteArray.md)\ )</td>
    </tr>
    <tr>
      <td>[Error](@GlobalScope.md#enum_@GlobalScope_Error)</td>
      <td>[update](#HMACContext_method_update)\ (\ data\: [PackedByteArray](PackedByteArray.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="HMACContext_method_finish"></a>

<!-- classref-method -->

[PackedByteArray](PackedByteArray.md) **finish**\ (\ ) [ðŸ”—](#HMACContext_method_finish)

Returns the resulting HMAC. If the HMAC failed, an empty [PackedByteArray](PackedByteArray.md) is returned.

<hr class="classref-item-separator"/>

<a id="HMACContext_method_start"></a>

<!-- classref-method -->

[Error](@GlobalScope.md#enum_@GlobalScope_Error) **start**\ (\ hash_type\: [HashType](HashingContext.md#enum_HashingContext_HashType), key\: [PackedByteArray](PackedByteArray.md)\ ) [ðŸ”—](#HMACContext_method_start)

Initializes the HMACContext. This method cannot be called again on the same HMACContext until [finish()](HMACContext.md#HMACContext_method_finish) has been called.

<hr class="classref-item-separator"/>

<a id="HMACContext_method_update"></a>

<!-- classref-method -->

[Error](@GlobalScope.md#enum_@GlobalScope_Error) **update**\ (\ data\: [PackedByteArray](PackedByteArray.md)\ ) [ðŸ”—](#HMACContext_method_update)

Updates the message to be HMACed. This can be called multiple times before [finish()](HMACContext.md#HMACContext_method_finish) is called to append `data` to the message, but cannot be called until [start()](HMACContext.md#HMACContext_method_start) has been called.

