<!-- github_url: hide -->

<!-- keywords: spatial -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Node3D.xml. -->

<a id="class_Node3D"></a>

# Node3D

**Inherits:** [Node](class_node.md) **<** [Object](class_object.md)

**Inherited By:** [AudioListener3D](class_audiolistener3d.md), [AudioStreamPlayer3D](class_audiostreamplayer3d.md), [BoneAttachment3D](class_boneattachment3d.md), [Camera3D](class_camera3d.md), [CollisionObject3D](class_collisionobject3d.md), [CollisionPolygon3D](class_collisionpolygon3d.md), [CollisionShape3D](class_collisionshape3d.md), [GridMap](class_gridmap.md), [ImporterMeshInstance3D](class_importermeshinstance3d.md), [Joint3D](class_joint3d.md), [LightmapProbe](class_lightmapprobe.md), [Marker3D](class_marker3d.md), [NavigationLink3D](class_navigationlink3d.md), [NavigationObstacle3D](class_navigationobstacle3d.md), [NavigationRegion3D](class_navigationregion3d.md), [OpenXRCompositionLayer](class_openxrcompositionlayer.md), [OpenXRHand](class_openxrhand.md), [OpenXRRenderModel](class_openxrrendermodel.md), [OpenXRRenderModelManager](class_openxrrendermodelmanager.md), [Path3D](class_path3d.md), [PathFollow3D](class_pathfollow3d.md), [RayCast3D](class_raycast3d.md), [RemoteTransform3D](class_remotetransform3d.md), [ShapeCast3D](class_shapecast3d.md), [Skeleton3D](class_skeleton3d.md), [SkeletonModifier3D](class_skeletonmodifier3d.md), [SpringArm3D](class_springarm3d.md), [SpringBoneCollision3D](class_springbonecollision3d.md), [VehicleWheel3D](class_vehiclewheel3d.md), [VisualInstance3D](class_visualinstance3d.md), [XRFaceModifier3D](class_xrfacemodifier3d.md), [XRNode3D](class_xrnode3d.md), [XROrigin3D](class_xrorigin3d.md)

Base object in 3D space, inherited by all 3D nodes.

<!-- classref-introduction-group -->

## Description

The **Node3D** node is the base representation of a node in 3D space. All other 3D nodes inherit from this class.

Affine operations (translation, rotation, scale) are calculated in the coordinate system relative to the parent, unless the **Node3D**'s [top_level](class_node3d.md#class_Node3D_property_top_level) is ``true``. In this coordinate system, affine operations correspond to direct affine operations on the **Node3D**'s [transform](class_node3d.md#class_Node3D_property_transform). The term *parent space* refers to this coordinate system. The coordinate system that is attached to the **Node3D** itself is referred to as object-local coordinate system, or *local space*.

\ **Note:** Unless otherwise specified, all methods that need angle parameters must receive angles in *radians*. To convert degrees to radians, use [@GlobalScope.deg_to_rad()](class_@globalscope.md#class_@GlobalScope_method_deg_to_rad).

\ **Note:** In Godot 3 and older, **Node3D** was named *Spatial*.

<!-- classref-introduction-group -->

## Tutorials

- [Introduction to 3D](../tutorials/3d/introduction_to_3d.md)

- [All 3D Demos](https://github.com/Redot-Engine/redot-demo-projects/tree/master/3d)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[Basis](class_basis.md)</th>
      <th>[basis](#class_Node3D_property_basis)</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Basis](class_basis.md)</td>
      <td>[global_basis](#class_Node3D_property_global_basis)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[global_position](#class_Node3D_property_global_position)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[global_rotation](#class_Node3D_property_global_rotation)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[global_rotation_degrees](#class_Node3D_property_global_rotation_degrees)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Transform3D](class_transform3d.md)</td>
      <td>[global_transform](#class_Node3D_property_global_transform)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[position](#class_Node3D_property_position)</td>
      <td>`Vector3(0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[Quaternion](class_quaternion.md)</td>
      <td>[quaternion](#class_Node3D_property_quaternion)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[rotation](#class_Node3D_property_rotation)</td>
      <td>`Vector3(0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[rotation_degrees](#class_Node3D_property_rotation_degrees)</td>
      <td></td>
    </tr>
    <tr>
      <td>[RotationEditMode](class_node3d.md#enum_Node3D_RotationEditMode)</td>
      <td>[rotation_edit_mode](#class_Node3D_property_rotation_edit_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[EulerOrder](class_@globalscope.md#enum_@GlobalScope_EulerOrder)</td>
      <td>[rotation_order](#class_Node3D_property_rotation_order)</td>
      <td>`2`</td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[scale](#class_Node3D_property_scale)</td>
      <td>`Vector3(1, 1, 1)`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[top_level](#class_Node3D_property_top_level)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[Transform3D](class_transform3d.md)</td>
      <td>[transform](#class_Node3D_property_transform)</td>
      <td>`Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[NodePath](class_nodepath.md)</td>
      <td>[visibility_parent](#class_Node3D_property_visibility_parent)</td>
      <td>`NodePath("")`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[visible](#class_Node3D_property_visible)</td>
      <td>`true`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>`void`</th>
      <th>[add_gizmo](#class_Node3D_method_add_gizmo)\ (\ gizmo\: [Node3DGizmo](class_node3dgizmo.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`void`</td>
      <td>[clear_gizmos](#class_Node3D_method_clear_gizmos)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[clear_subgizmo_selection](#class_Node3D_method_clear_subgizmo_selection)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[force_update_transform](#class_Node3D_method_force_update_transform)\ (\ )</td>
    </tr>
    <tr>
      <td>[Array](class_array.md)\[[Node3DGizmo](class_node3dgizmo.md)\]</td>
      <td>[get_gizmos](#class_Node3D_method_get_gizmos)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](class_transform3d.md)</td>
      <td>[get_global_transform_interpolated](#class_Node3D_method_get_global_transform_interpolated)\ (\ )</td>
    </tr>
    <tr>
      <td>[Node3D](class_node3d.md)</td>
      <td>[get_parent_node_3d](#class_Node3D_method_get_parent_node_3d)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[World3D](class_world3d.md)</td>
      <td>[get_world_3d](#class_Node3D_method_get_world_3d)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[global_rotate](#class_Node3D_method_global_rotate)\ (\ axis\: [Vector3](class_vector3.md), angle\: [float](class_float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[global_scale](#class_Node3D_method_global_scale)\ (\ scale\: [Vector3](class_vector3.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[global_translate](#class_Node3D_method_global_translate)\ (\ offset\: [Vector3](class_vector3.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[hide](#class_Node3D_method_hide)\ (\ )</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_local_transform_notification_enabled](#class_Node3D_method_is_local_transform_notification_enabled)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_scale_disabled](#class_Node3D_method_is_scale_disabled)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_transform_notification_enabled](#class_Node3D_method_is_transform_notification_enabled)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_visible_in_tree](#class_Node3D_method_is_visible_in_tree)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[look_at](#class_Node3D_method_look_at)\ (\ target\: [Vector3](class_vector3.md), up\: [Vector3](class_vector3.md) = Vector3(0, 1, 0), use_model_front\: [bool](class_bool.md) = false\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[look_at_from_position](#class_Node3D_method_look_at_from_position)\ (\ position\: [Vector3](class_vector3.md), target\: [Vector3](class_vector3.md), up\: [Vector3](class_vector3.md) = Vector3(0, 1, 0), use_model_front\: [bool](class_bool.md) = false\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[orthonormalize](#class_Node3D_method_orthonormalize)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[rotate](#class_Node3D_method_rotate)\ (\ axis\: [Vector3](class_vector3.md), angle\: [float](class_float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[rotate_object_local](#class_Node3D_method_rotate_object_local)\ (\ axis\: [Vector3](class_vector3.md), angle\: [float](class_float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[rotate_x](#class_Node3D_method_rotate_x)\ (\ angle\: [float](class_float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[rotate_y](#class_Node3D_method_rotate_y)\ (\ angle\: [float](class_float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[rotate_z](#class_Node3D_method_rotate_z)\ (\ angle\: [float](class_float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[scale_object_local](#class_Node3D_method_scale_object_local)\ (\ scale\: [Vector3](class_vector3.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_disable_scale](#class_Node3D_method_set_disable_scale)\ (\ disable\: [bool](class_bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_identity](#class_Node3D_method_set_identity)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_ignore_transform_notification](#class_Node3D_method_set_ignore_transform_notification)\ (\ enabled\: [bool](class_bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_notify_local_transform](#class_Node3D_method_set_notify_local_transform)\ (\ enable\: [bool](class_bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_notify_transform](#class_Node3D_method_set_notify_transform)\ (\ enable\: [bool](class_bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_subgizmo_selection](#class_Node3D_method_set_subgizmo_selection)\ (\ gizmo\: [Node3DGizmo](class_node3dgizmo.md), id\: [int](class_int.md), transform\: [Transform3D](class_transform3d.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[show](#class_Node3D_method_show)\ (\ )</td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[to_global](#class_Node3D_method_to_global)\ (\ local_point\: [Vector3](class_vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[to_local](#class_Node3D_method_to_local)\ (\ global_point\: [Vector3](class_vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[translate](#class_Node3D_method_translate)\ (\ offset\: [Vector3](class_vector3.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[translate_object_local](#class_Node3D_method_translate_object_local)\ (\ offset\: [Vector3](class_vector3.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[update_gizmos](#class_Node3D_method_update_gizmos)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Signals

<a id="class_Node3D_signal_visibility_changed"></a>

<!-- classref-signal -->

**visibility_changed**\ (\ ) [ðŸ”—](#class_Node3D_signal_visibility_changed)

Emitted when this node's visibility changes (see [visible](class_node3d.md#class_Node3D_property_visible) and [is_visible_in_tree()](class_node3d.md#class_Node3D_method_is_visible_in_tree)).

This signal is emitted *after* the related [NOTIFICATION_VISIBILITY_CHANGED](class_node3d.md#class_Node3D_constant_NOTIFICATION_VISIBILITY_CHANGED) notification.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_Node3D_RotationEditMode"></a>

<!-- classref-enumeration -->

enum **RotationEditMode**: [ðŸ”—](#enum_Node3D_RotationEditMode)

<a id="class_Node3D_constant_ROTATION_EDIT_MODE_EULER"></a>

<!-- classref-enumeration-constant -->

[RotationEditMode](class_node3d.md#enum_Node3D_RotationEditMode) **ROTATION_EDIT_MODE_EULER** = `0`

The rotation is edited using a [Vector3](class_vector3.md) in [Euler angles](https://en.wikipedia.org/wiki/Euler_angles).<a id="class_Node3D_constant_ROTATION_EDIT_MODE_QUATERNION"></a>

<!-- classref-enumeration-constant -->

[RotationEditMode](class_node3d.md#enum_Node3D_RotationEditMode) **ROTATION_EDIT_MODE_QUATERNION** = `1`

The rotation is edited using a [Quaternion](class_quaternion.md).<a id="class_Node3D_constant_ROTATION_EDIT_MODE_BASIS"></a>

<!-- classref-enumeration-constant -->

[RotationEditMode](class_node3d.md#enum_Node3D_RotationEditMode) **ROTATION_EDIT_MODE_BASIS** = `2`

The rotation is edited using a [Basis](class_basis.md). In this mode, the raw [basis](class_node3d.md#class_Node3D_property_basis)'s axes can be freely modified, but the [scale](class_node3d.md#class_Node3D_property_scale) property is not available.<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Constants

<a id="class_Node3D_constant_NOTIFICATION_TRANSFORM_CHANGED"></a>

<!-- classref-constant -->

**NOTIFICATION_TRANSFORM_CHANGED** = `2000` [ðŸ”—](#class_Node3D_constant_NOTIFICATION_TRANSFORM_CHANGED)

Notification received when this node's [global_transform](class_node3d.md#class_Node3D_property_global_transform) changes, if [is_transform_notification_enabled()](class_node3d.md#class_Node3D_method_is_transform_notification_enabled) is ``true``. See also [set_notify_transform()](class_node3d.md#class_Node3D_method_set_notify_transform).

\ **Note:** Most 3D nodes such as [VisualInstance3D](class_visualinstance3d.md) or [CollisionObject3D](class_collisionobject3d.md) automatically enable this to function correctly.

\ **Note:** In the editor, nodes will propagate this notification to their children if a gizmo is attached (see [add_gizmo()](class_node3d.md#class_Node3D_method_add_gizmo)).

<a id="class_Node3D_constant_NOTIFICATION_ENTER_WORLD"></a>

<!-- classref-constant -->

**NOTIFICATION_ENTER_WORLD** = `41` [ðŸ”—](#class_Node3D_constant_NOTIFICATION_ENTER_WORLD)

Notification received when this node is registered to a new [World3D](class_world3d.md) (see [get_world_3d()](class_node3d.md#class_Node3D_method_get_world_3d)).

<a id="class_Node3D_constant_NOTIFICATION_EXIT_WORLD"></a>

<!-- classref-constant -->

**NOTIFICATION_EXIT_WORLD** = `42` [ðŸ”—](#class_Node3D_constant_NOTIFICATION_EXIT_WORLD)

Notification received when this node is unregistered from the current [World3D](class_world3d.md) (see [get_world_3d()](class_node3d.md#class_Node3D_method_get_world_3d)).

<a id="class_Node3D_constant_NOTIFICATION_VISIBILITY_CHANGED"></a>

<!-- classref-constant -->

**NOTIFICATION_VISIBILITY_CHANGED** = `43` [ðŸ”—](#class_Node3D_constant_NOTIFICATION_VISIBILITY_CHANGED)

Notification received when this node's visibility changes (see [visible](class_node3d.md#class_Node3D_property_visible) and [is_visible_in_tree()](class_node3d.md#class_Node3D_method_is_visible_in_tree)).

This notification is received *before* the related [visibility_changed](class_node3d.md#class_Node3D_signal_visibility_changed) signal.

<a id="class_Node3D_constant_NOTIFICATION_LOCAL_TRANSFORM_CHANGED"></a>

<!-- classref-constant -->

**NOTIFICATION_LOCAL_TRANSFORM_CHANGED** = `44` [ðŸ”—](#class_Node3D_constant_NOTIFICATION_LOCAL_TRANSFORM_CHANGED)

Notification received when this node's [transform](class_node3d.md#class_Node3D_property_transform) changes, if [is_local_transform_notification_enabled()](class_node3d.md#class_Node3D_method_is_local_transform_notification_enabled) is ``true``. This is not received when a parent **Node3D**'s [transform](class_node3d.md#class_Node3D_property_transform) changes. See also [set_notify_local_transform()](class_node3d.md#class_Node3D_method_set_notify_local_transform).

\ **Note:** Some 3D nodes such as [CSGShape3D](class_csgshape3d.md) or [CollisionShape3D](class_collisionshape3d.md) automatically enable this to function correctly.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_Node3D_property_basis"></a>

<!-- classref-property -->

[Basis](class_basis.md) **basis** [ðŸ”—](#class_Node3D_property_basis)

<!-- classref-property-setget -->

- `void` **set_basis**\ (\ value\: [Basis](class_basis.md)\ )
- [Basis](class_basis.md) **get_basis**\ (\ )

Basis of the [transform](class_node3d.md#class_Node3D_property_transform) property. Represents the rotation, scale, and shear of this node in parent space (relative to the parent node).

<hr class="classref-item-separator">

<a id="class_Node3D_property_global_basis"></a>

<!-- classref-property -->

[Basis](class_basis.md) **global_basis** [ðŸ”—](#class_Node3D_property_global_basis)

<!-- classref-property-setget -->

- `void` **set_global_basis**\ (\ value\: [Basis](class_basis.md)\ )
- [Basis](class_basis.md) **get_global_basis**\ (\ )

Basis of the [global_transform](class_node3d.md#class_Node3D_property_global_transform) property. Represents the rotation, scale, and shear of this node in global space (relative to the world).

\ **Note:** If the node is not inside the tree, getting this property fails and returns [Basis.IDENTITY](class_basis.md#class_Basis_constant_IDENTITY).

<hr class="classref-item-separator">

<a id="class_Node3D_property_global_position"></a>

<!-- classref-property -->

[Vector3](class_vector3.md) **global_position** [ðŸ”—](#class_Node3D_property_global_position)

<!-- classref-property-setget -->

- `void` **set_global_position**\ (\ value\: [Vector3](class_vector3.md)\ )
- [Vector3](class_vector3.md) **get_global_position**\ (\ )

Global position (translation) of this node in global space (relative to the world). This is equivalent to the [global_transform](class_node3d.md#class_Node3D_property_global_transform)'s [Transform3D.origin](class_transform3d.md#class_Transform3D_property_origin).

\ **Note:** If the node is not inside the tree, getting this property fails and returns [Vector3.ZERO](class_vector3.md#class_Vector3_constant_ZERO).

<hr class="classref-item-separator">

<a id="class_Node3D_property_global_rotation"></a>

<!-- classref-property -->

[Vector3](class_vector3.md) **global_rotation** [ðŸ”—](#class_Node3D_property_global_rotation)

<!-- classref-property-setget -->

- `void` **set_global_rotation**\ (\ value\: [Vector3](class_vector3.md)\ )
- [Vector3](class_vector3.md) **get_global_rotation**\ (\ )

Global rotation of this node as [Euler angles](https://en.wikipedia.org/wiki/Euler_angles), in radians and in global space (relative to the world). This value is obtained from [global_basis](class_node3d.md#class_Node3D_property_global_basis)'s rotation.

- The [Vector3.x](class_vector3.md#class_Vector3_property_x) is the angle around the global X axis (pitch);

- The [Vector3.y](class_vector3.md#class_Vector3_property_y) is the angle around the global Y axis (yaw);

- The [Vector3.z](class_vector3.md#class_Vector3_property_z) is the angle around the global Z axis (roll).

\ **Note:** Unlike [rotation](class_node3d.md#class_Node3D_property_rotation), this property always follows the YXZ convention ([@GlobalScope.EULER_ORDER_YXZ](class_@globalscope.md#class_@GlobalScope_constant_EULER_ORDER_YXZ)).

\ **Note:** If the node is not inside the tree, getting this property fails and returns [Vector3.ZERO](class_vector3.md#class_Vector3_constant_ZERO).

<hr class="classref-item-separator">

<a id="class_Node3D_property_global_rotation_degrees"></a>

<!-- classref-property -->

[Vector3](class_vector3.md) **global_rotation_degrees** [ðŸ”—](#class_Node3D_property_global_rotation_degrees)

<!-- classref-property-setget -->

- `void` **set_global_rotation_degrees**\ (\ value\: [Vector3](class_vector3.md)\ )
- [Vector3](class_vector3.md) **get_global_rotation_degrees**\ (\ )

The [global_rotation](class_node3d.md#class_Node3D_property_global_rotation) of this node, in degrees instead of radians.

\ **Note:** If the node is not inside the tree, getting this property fails and returns [Vector3.ZERO](class_vector3.md#class_Vector3_constant_ZERO).

<hr class="classref-item-separator">

<a id="class_Node3D_property_global_transform"></a>

<!-- classref-property -->

[Transform3D](class_transform3d.md) **global_transform** [ðŸ”—](#class_Node3D_property_global_transform)

<!-- classref-property-setget -->

- `void` **set_global_transform**\ (\ value\: [Transform3D](class_transform3d.md)\ )
- [Transform3D](class_transform3d.md) **get_global_transform**\ (\ )

The transformation of this node, in global space (relative to the world). Contains and represents this node's [global_position](class_node3d.md#class_Node3D_property_global_position), [global_rotation](class_node3d.md#class_Node3D_property_global_rotation), and global scale.

\ **Note:** If the node is not inside the tree, getting this property fails and returns [Transform3D.IDENTITY](class_transform3d.md#class_Transform3D_constant_IDENTITY).

<hr class="classref-item-separator">

<a id="class_Node3D_property_position"></a>

<!-- classref-property -->

[Vector3](class_vector3.md) **position** = `Vector3(0, 0, 0)` [ðŸ”—](#class_Node3D_property_position)

<!-- classref-property-setget -->

- `void` **set_position**\ (\ value\: [Vector3](class_vector3.md)\ )
- [Vector3](class_vector3.md) **get_position**\ (\ )

Position (translation) of this node in parent space (relative to the parent node). This is equivalent to the [transform](class_node3d.md#class_Node3D_property_transform)'s [Transform3D.origin](class_transform3d.md#class_Transform3D_property_origin).

<hr class="classref-item-separator">

<a id="class_Node3D_property_quaternion"></a>

<!-- classref-property -->

[Quaternion](class_quaternion.md) **quaternion** [ðŸ”—](#class_Node3D_property_quaternion)

<!-- classref-property-setget -->

- `void` **set_quaternion**\ (\ value\: [Quaternion](class_quaternion.md)\ )
- [Quaternion](class_quaternion.md) **get_quaternion**\ (\ )

Rotation of this node represented as a [Quaternion](class_quaternion.md) in parent space (relative to the parent node). This value is obtained from [basis](class_node3d.md#class_Node3D_property_basis)'s rotation.

\ **Note:** Quaternions are much more suitable for 3D math but are less intuitive. Setting this property can be useful for interpolation (see [Quaternion.slerp()](class_quaternion.md#class_Quaternion_method_slerp)).

<hr class="classref-item-separator">

<a id="class_Node3D_property_rotation"></a>

<!-- classref-property -->

[Vector3](class_vector3.md) **rotation** = `Vector3(0, 0, 0)` [ðŸ”—](#class_Node3D_property_rotation)

<!-- classref-property-setget -->

- `void` **set_rotation**\ (\ value\: [Vector3](class_vector3.md)\ )
- [Vector3](class_vector3.md) **get_rotation**\ (\ )

Rotation of this node as [Euler angles](https://en.wikipedia.org/wiki/Euler_angles), in radians and in parent space (relative to the parent node). This value is obtained from [basis](class_node3d.md#class_Node3D_property_basis)'s rotation.

- The [Vector3.x](class_vector3.md#class_Vector3_property_x) is the angle around the local X axis (pitch);

- The [Vector3.y](class_vector3.md#class_Vector3_property_y) is the angle around the local Y axis (yaw);

- The [Vector3.z](class_vector3.md#class_Vector3_property_z) is the angle around the local Z axis (roll).

The order of each consecutive rotation can be changed with [rotation_order](class_node3d.md#class_Node3D_property_rotation_order) (see [EulerOrder](class_@globalscope.md#enum_@GlobalScope_EulerOrder) constants). By default, the YXZ convention is used ([@GlobalScope.EULER_ORDER_YXZ](class_@globalscope.md#class_@GlobalScope_constant_EULER_ORDER_YXZ)).

\ **Note:** This property is edited in degrees in the inspector. If you want to use degrees in a script, use [rotation_degrees](class_node3d.md#class_Node3D_property_rotation_degrees).

<hr class="classref-item-separator">

<a id="class_Node3D_property_rotation_degrees"></a>

<!-- classref-property -->

[Vector3](class_vector3.md) **rotation_degrees** [ðŸ”—](#class_Node3D_property_rotation_degrees)

<!-- classref-property-setget -->

- `void` **set_rotation_degrees**\ (\ value\: [Vector3](class_vector3.md)\ )
- [Vector3](class_vector3.md) **get_rotation_degrees**\ (\ )

The [rotation](class_node3d.md#class_Node3D_property_rotation) of this node, in degrees instead of radians.

\ **Note:** This is **not** the property available in the Inspector dock.

<hr class="classref-item-separator">

<a id="class_Node3D_property_rotation_edit_mode"></a>

<!-- classref-property -->

[RotationEditMode](class_node3d.md#enum_Node3D_RotationEditMode) **rotation_edit_mode** = `0` [ðŸ”—](#class_Node3D_property_rotation_edit_mode)

<!-- classref-property-setget -->

- `void` **set_rotation_edit_mode**\ (\ value\: [RotationEditMode](class_node3d.md#enum_Node3D_RotationEditMode)\ )
- [RotationEditMode](class_node3d.md#enum_Node3D_RotationEditMode) **get_rotation_edit_mode**\ (\ )

How this node's rotation and scale are displayed in the Inspector dock.

<hr class="classref-item-separator">

<a id="class_Node3D_property_rotation_order"></a>

<!-- classref-property -->

[EulerOrder](class_@globalscope.md#enum_@GlobalScope_EulerOrder) **rotation_order** = `2` [ðŸ”—](#class_Node3D_property_rotation_order)

<!-- classref-property-setget -->

- `void` **set_rotation_order**\ (\ value\: [EulerOrder](class_@globalscope.md#enum_@GlobalScope_EulerOrder)\ )
- [EulerOrder](class_@globalscope.md#enum_@GlobalScope_EulerOrder) **get_rotation_order**\ (\ )

The axis rotation order of the [rotation](class_node3d.md#class_Node3D_property_rotation) property. The final orientation is calculated by rotating around the local X, Y, and Z axis in this order.

<hr class="classref-item-separator">

<a id="class_Node3D_property_scale"></a>

<!-- classref-property -->

[Vector3](class_vector3.md) **scale** = `Vector3(1, 1, 1)` [ðŸ”—](#class_Node3D_property_scale)

<!-- classref-property-setget -->

- `void` **set_scale**\ (\ value\: [Vector3](class_vector3.md)\ )
- [Vector3](class_vector3.md) **get_scale**\ (\ )

Scale of this node in local space (relative to this node). This value is obtained from [basis](class_node3d.md#class_Node3D_property_basis)'s scale.

\ **Note:** The behavior of some 3D node types is not affected by this property. These include [Light3D](class_light3d.md), [Camera3D](class_camera3d.md), [AudioStreamPlayer3D](class_audiostreamplayer3d.md), and more.

\ **Warning:** The scale's components must either be all positive or all negative, and **not** exactly ``0.0``. Otherwise, it won't be possible to obtain the scale from the [basis](class_node3d.md#class_Node3D_property_basis). This may cause the intended scale to be lost when reloaded from disk, and potentially other unstable behavior.

<hr class="classref-item-separator">

<a id="class_Node3D_property_top_level"></a>

<!-- classref-property -->

[bool](class_bool.md) **top_level** = `false` [ðŸ”—](#class_Node3D_property_top_level)

<!-- classref-property-setget -->

- `void` **set_as_top_level**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **is_set_as_top_level**\ (\ )

If ``true``, the node does not inherit its transformations from its parent. As such, node transformations will only be in global space, which also means that [global_transform](class_node3d.md#class_Node3D_property_global_transform) and [transform](class_node3d.md#class_Node3D_property_transform) will be identical.

<hr class="classref-item-separator">

<a id="class_Node3D_property_transform"></a>

<!-- classref-property -->

[Transform3D](class_transform3d.md) **transform** = `Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)` [ðŸ”—](#class_Node3D_property_transform)

<!-- classref-property-setget -->

- `void` **set_transform**\ (\ value\: [Transform3D](class_transform3d.md)\ )
- [Transform3D](class_transform3d.md) **get_transform**\ (\ )

The local transformation of this node, in parent space (relative to the parent node). Contains and represents this node's [position](class_node3d.md#class_Node3D_property_position), [rotation](class_node3d.md#class_Node3D_property_rotation), and [scale](class_node3d.md#class_Node3D_property_scale).

<hr class="classref-item-separator">

<a id="class_Node3D_property_visibility_parent"></a>

<!-- classref-property -->

[NodePath](class_nodepath.md) **visibility_parent** = `NodePath("")` [ðŸ”—](#class_Node3D_property_visibility_parent)

<!-- classref-property-setget -->

- `void` **set_visibility_parent**\ (\ value\: [NodePath](class_nodepath.md)\ )
- [NodePath](class_nodepath.md) **get_visibility_parent**\ (\ )

Path to the visibility range parent for this node and its descendants. The visibility parent must be a [GeometryInstance3D](class_geometryinstance3d.md).

Any visual instance will only be visible if the visibility parent (and all of its visibility ancestors) is hidden by being closer to the camera than its own [GeometryInstance3D.visibility_range_begin](class_geometryinstance3d.md#class_GeometryInstance3D_property_visibility_range_begin). Nodes hidden via the [visible](class_node3d.md#class_Node3D_property_visible) property are essentially removed from the visibility dependency tree, so dependent instances will not take the hidden node or its descendants into account.

<hr class="classref-item-separator">

<a id="class_Node3D_property_visible"></a>

<!-- classref-property -->

[bool](class_bool.md) **visible** = `true` [ðŸ”—](#class_Node3D_property_visible)

<!-- classref-property-setget -->

- `void` **set_visible**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **is_visible**\ (\ )

If ``true``, this node can be visible. The node is only rendered when all of its ancestors are visible, as well. That means [is_visible_in_tree()](class_node3d.md#class_Node3D_method_is_visible_in_tree) must return ``true``.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_Node3D_method_add_gizmo"></a>

<!-- classref-method -->

`void` **add_gizmo**\ (\ gizmo\: [Node3DGizmo](class_node3dgizmo.md)\ ) [ðŸ”—](#class_Node3D_method_add_gizmo)

Attaches the given `gizmo` to this node. Only works in the editor.

\ **Note:** `gizmo` should be an [EditorNode3DGizmo](class_editornode3dgizmo.md). The argument type is [Node3DGizmo](class_node3dgizmo.md) to avoid depending on editor classes in **Node3D**.

<hr class="classref-item-separator">

<a id="class_Node3D_method_clear_gizmos"></a>

<!-- classref-method -->

`void` **clear_gizmos**\ (\ ) [ðŸ”—](#class_Node3D_method_clear_gizmos)

Clears all [EditorNode3DGizmo](class_editornode3dgizmo.md) objects attached to this node. Only works in the editor.

<hr class="classref-item-separator">

<a id="class_Node3D_method_clear_subgizmo_selection"></a>

<!-- classref-method -->

`void` **clear_subgizmo_selection**\ (\ ) [ðŸ”—](#class_Node3D_method_clear_subgizmo_selection)

Deselects all subgizmos for this node. Useful to call when the selected subgizmo may no longer exist after a property change. Only works in the editor.

<hr class="classref-item-separator">

<a id="class_Node3D_method_force_update_transform"></a>

<!-- classref-method -->

`void` **force_update_transform**\ (\ ) [ðŸ”—](#class_Node3D_method_force_update_transform)

Forces the node's [global_transform](class_node3d.md#class_Node3D_property_global_transform) to update, by sending [NOTIFICATION_TRANSFORM_CHANGED](class_node3d.md#class_Node3D_constant_NOTIFICATION_TRANSFORM_CHANGED). Fails if the node is not inside the tree.

\ **Note:** For performance reasons, transform changes are usually accumulated and applied *once* at the end of the frame. The update propagates through **Node3D** children, as well. Therefore, use this method only when you need an up-to-date transform (such as during physics operations).

<hr class="classref-item-separator">

<a id="class_Node3D_method_get_gizmos"></a>

<!-- classref-method -->

[Array](class_array.md)\[[Node3DGizmo](class_node3dgizmo.md)\] **get_gizmos**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_get_gizmos)

Returns all the [EditorNode3DGizmo](class_editornode3dgizmo.md) objects attached to this node. Only works in the editor.

<hr class="classref-item-separator">

<a id="class_Node3D_method_get_global_transform_interpolated"></a>

<!-- classref-method -->

[Transform3D](class_transform3d.md) **get_global_transform_interpolated**\ (\ ) [ðŸ”—](#class_Node3D_method_get_global_transform_interpolated)

When using physics interpolation, there will be circumstances in which you want to know the interpolated (displayed) transform of a node rather than the standard transform (which may only be accurate to the most recent physics tick).

This is particularly important for frame-based operations that take place in [Node._process()](class_node.md#class_Node_private_method__process), rather than [Node._physics_process()](class_node.md#class_Node_private_method__physics_process). Examples include [Camera3D](class_camera3d.md)\ s focusing on a node, or finding where to fire lasers from on a frame rather than physics tick.

\ **Note:** This function creates an interpolation pump on the **Node3D** the first time it is called, which can respond to physics interpolation resets. If you get problems with "streaking" when initially following a **Node3D**, be sure to call [get_global_transform_interpolated()](class_node3d.md#class_Node3D_method_get_global_transform_interpolated) at least once *before* resetting the **Node3D** physics interpolation.

<hr class="classref-item-separator">

<a id="class_Node3D_method_get_parent_node_3d"></a>

<!-- classref-method -->

[Node3D](class_node3d.md) **get_parent_node_3d**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_get_parent_node_3d)

Returns the parent **Node3D** that directly affects this node's [global_transform](class_node3d.md#class_Node3D_property_global_transform). Returns ``null`` if no parent exists, the parent is not a **Node3D**, or [top_level](class_node3d.md#class_Node3D_property_top_level) is ``true``.

\ **Note:** This method is not always equivalent to [Node.get_parent()](class_node.md#class_Node_method_get_parent), which does not take [top_level](class_node3d.md#class_Node3D_property_top_level) into account.

<hr class="classref-item-separator">

<a id="class_Node3D_method_get_world_3d"></a>

<!-- classref-method -->

[World3D](class_world3d.md) **get_world_3d**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_get_world_3d)

Returns the [World3D](class_world3d.md) this node is registered to.

Usually, this is the same as the world used by this node's viewport (see [Node.get_viewport()](class_node.md#class_Node_method_get_viewport) and [Viewport.find_world_3d()](class_viewport.md#class_Viewport_method_find_world_3d)).

<hr class="classref-item-separator">

<a id="class_Node3D_method_global_rotate"></a>

<!-- classref-method -->

`void` **global_rotate**\ (\ axis\: [Vector3](class_vector3.md), angle\: [float](class_float.md)\ ) [ðŸ”—](#class_Node3D_method_global_rotate)

Rotates this node's [global_basis](class_node3d.md#class_Node3D_property_global_basis) around the global `axis` by the given `angle`, in radians. This operation is calculated in global space (relative to the world) and preserves the [global_position](class_node3d.md#class_Node3D_property_global_position).

<hr class="classref-item-separator">

<a id="class_Node3D_method_global_scale"></a>

<!-- classref-method -->

`void` **global_scale**\ (\ scale\: [Vector3](class_vector3.md)\ ) [ðŸ”—](#class_Node3D_method_global_scale)

Scales this node's [global_basis](class_node3d.md#class_Node3D_property_global_basis) by the given `scale` factor. This operation is calculated in global space (relative to the world) and preserves the [global_position](class_node3d.md#class_Node3D_property_global_position).

\ **Note:** This method is not to be confused with the [scale](class_node3d.md#class_Node3D_property_scale) property.

<hr class="classref-item-separator">

<a id="class_Node3D_method_global_translate"></a>

<!-- classref-method -->

`void` **global_translate**\ (\ offset\: [Vector3](class_vector3.md)\ ) [ðŸ”—](#class_Node3D_method_global_translate)

Adds the given translation `offset` to the node's [global_position](class_node3d.md#class_Node3D_property_global_position) in global space (relative to the world).

<hr class="classref-item-separator">

<a id="class_Node3D_method_hide"></a>

<!-- classref-method -->

`void` **hide**\ (\ ) [ðŸ”—](#class_Node3D_method_hide)

Prevents this node from being rendered. Equivalent to setting [visible](class_node3d.md#class_Node3D_property_visible) to ``false``. This is the opposite of [show()](class_node3d.md#class_Node3D_method_show).

<hr class="classref-item-separator">

<a id="class_Node3D_method_is_local_transform_notification_enabled"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_local_transform_notification_enabled**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_is_local_transform_notification_enabled)

Returns ``true`` if the node receives [NOTIFICATION_LOCAL_TRANSFORM_CHANGED](class_node3d.md#class_Node3D_constant_NOTIFICATION_LOCAL_TRANSFORM_CHANGED) whenever [transform](class_node3d.md#class_Node3D_property_transform) changes. This is enabled with [set_notify_local_transform()](class_node3d.md#class_Node3D_method_set_notify_local_transform).

<hr class="classref-item-separator">

<a id="class_Node3D_method_is_scale_disabled"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_scale_disabled**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_is_scale_disabled)

Returns ``true`` if this node's [global_transform](class_node3d.md#class_Node3D_property_global_transform) is automatically orthonormalized. This results in this node not appearing distorted, as if its global scale were set to [Vector3.ONE](class_vector3.md#class_Vector3_constant_ONE) (or its negative counterpart). See also [set_disable_scale()](class_node3d.md#class_Node3D_method_set_disable_scale) and [orthonormalize()](class_node3d.md#class_Node3D_method_orthonormalize).

\ **Note:** [transform](class_node3d.md#class_Node3D_property_transform) is not affected by this setting.

<hr class="classref-item-separator">

<a id="class_Node3D_method_is_transform_notification_enabled"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_transform_notification_enabled**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_is_transform_notification_enabled)

Returns ``true`` if the node receives [NOTIFICATION_TRANSFORM_CHANGED](class_node3d.md#class_Node3D_constant_NOTIFICATION_TRANSFORM_CHANGED) whenever [global_transform](class_node3d.md#class_Node3D_property_global_transform) changes. This is enabled with [set_notify_transform()](class_node3d.md#class_Node3D_method_set_notify_transform).

<hr class="classref-item-separator">

<a id="class_Node3D_method_is_visible_in_tree"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_visible_in_tree**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_is_visible_in_tree)

Returns ``true`` if this node is inside the scene tree and the [visible](class_node3d.md#class_Node3D_property_visible) property is ``true`` for this node and all of its **Node3D** ancestors *in sequence*. An ancestor of any other type (such as [Node](class_node.md) or [Node2D](class_node2d.md)) breaks the sequence. See also [Node.get_parent()](class_node.md#class_Node_method_get_parent).

\ **Note:** This method cannot take [VisualInstance3D.layers](class_visualinstance3d.md#class_VisualInstance3D_property_layers) into account, so even if this method returns ``true``, the node may not be rendered.

<hr class="classref-item-separator">

<a id="class_Node3D_method_look_at"></a>

<!-- classref-method -->

`void` **look_at**\ (\ target\: [Vector3](class_vector3.md), up\: [Vector3](class_vector3.md) = Vector3(0, 1, 0), use_model_front\: [bool](class_bool.md) = false\ ) [ðŸ”—](#class_Node3D_method_look_at)

Rotates the node so that the local forward axis (-Z, [Vector3.FORWARD](class_vector3.md#class_Vector3_constant_FORWARD)) points toward the `target` position. This operation is calculated in global space (relative to the world).

The local up axis (+Y) points as close to the `up` vector as possible while staying perpendicular to the local forward axis. The resulting transform is orthogonal, and the scale is preserved. Non-uniform scaling may not work correctly.

The `target` position cannot be the same as the node's position, the `up` vector cannot be [Vector3.ZERO](class_vector3.md#class_Vector3_constant_ZERO). Furthermore, the direction from the node's position to the `target` position cannot be parallel to the `up` vector, to avoid an unintended rotation around the local Z axis.

If `use_model_front` is ``true``, the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the `target` position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).

\ **Note:** This method fails if the node is not in the scene tree. If necessary, use [look_at_from_position()](class_node3d.md#class_Node3D_method_look_at_from_position) instead.

<hr class="classref-item-separator">

<a id="class_Node3D_method_look_at_from_position"></a>

<!-- classref-method -->

`void` **look_at_from_position**\ (\ position\: [Vector3](class_vector3.md), target\: [Vector3](class_vector3.md), up\: [Vector3](class_vector3.md) = Vector3(0, 1, 0), use_model_front\: [bool](class_bool.md) = false\ ) [ðŸ”—](#class_Node3D_method_look_at_from_position)

Moves the node to the specified `position`, then rotates the node to point toward the `target` position, similar to [look_at()](class_node3d.md#class_Node3D_method_look_at). This operation is calculated in global space (relative to the world).

<hr class="classref-item-separator">

<a id="class_Node3D_method_orthonormalize"></a>

<!-- classref-method -->

`void` **orthonormalize**\ (\ ) [ðŸ”—](#class_Node3D_method_orthonormalize)

Orthonormalizes this node's [basis](class_node3d.md#class_Node3D_property_basis). This method sets this node's [scale](class_node3d.md#class_Node3D_property_scale) to [Vector3.ONE](class_vector3.md#class_Vector3_constant_ONE) (or its negative counterpart), but preserves the [position](class_node3d.md#class_Node3D_property_position) and [rotation](class_node3d.md#class_Node3D_property_rotation). See also [Transform3D.orthonormalized()](class_transform3d.md#class_Transform3D_method_orthonormalized).

<hr class="classref-item-separator">

<a id="class_Node3D_method_rotate"></a>

<!-- classref-method -->

`void` **rotate**\ (\ axis\: [Vector3](class_vector3.md), angle\: [float](class_float.md)\ ) [ðŸ”—](#class_Node3D_method_rotate)

Rotates this node's [basis](class_node3d.md#class_Node3D_property_basis) around the `axis` by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the [position](class_node3d.md#class_Node3D_property_position).

<hr class="classref-item-separator">

<a id="class_Node3D_method_rotate_object_local"></a>

<!-- classref-method -->

`void` **rotate_object_local**\ (\ axis\: [Vector3](class_vector3.md), angle\: [float](class_float.md)\ ) [ðŸ”—](#class_Node3D_method_rotate_object_local)

Rotates this node's [basis](class_node3d.md#class_Node3D_property_basis) around the `axis` by the given `angle`, in radians. This operation is calculated in local space (relative to this node) and preserves the [position](class_node3d.md#class_Node3D_property_position).

<hr class="classref-item-separator">

<a id="class_Node3D_method_rotate_x"></a>

<!-- classref-method -->

`void` **rotate_x**\ (\ angle\: [float](class_float.md)\ ) [ðŸ”—](#class_Node3D_method_rotate_x)

Rotates this node's [basis](class_node3d.md#class_Node3D_property_basis) around the X axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the [position](class_node3d.md#class_Node3D_property_position).

<hr class="classref-item-separator">

<a id="class_Node3D_method_rotate_y"></a>

<!-- classref-method -->

`void` **rotate_y**\ (\ angle\: [float](class_float.md)\ ) [ðŸ”—](#class_Node3D_method_rotate_y)

Rotates this node's [basis](class_node3d.md#class_Node3D_property_basis) around the Y axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the [position](class_node3d.md#class_Node3D_property_position).

<hr class="classref-item-separator">

<a id="class_Node3D_method_rotate_z"></a>

<!-- classref-method -->

`void` **rotate_z**\ (\ angle\: [float](class_float.md)\ ) [ðŸ”—](#class_Node3D_method_rotate_z)

Rotates this node's [basis](class_node3d.md#class_Node3D_property_basis) around the Z axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the [position](class_node3d.md#class_Node3D_property_position).

<hr class="classref-item-separator">

<a id="class_Node3D_method_scale_object_local"></a>

<!-- classref-method -->

`void` **scale_object_local**\ (\ scale\: [Vector3](class_vector3.md)\ ) [ðŸ”—](#class_Node3D_method_scale_object_local)

Scales this node's [basis](class_node3d.md#class_Node3D_property_basis) by the given `scale` factor. This operation is calculated in local space (relative to this node) and preserves the [position](class_node3d.md#class_Node3D_property_position).

<hr class="classref-item-separator">

<a id="class_Node3D_method_set_disable_scale"></a>

<!-- classref-method -->

`void` **set_disable_scale**\ (\ disable\: [bool](class_bool.md)\ ) [ðŸ”—](#class_Node3D_method_set_disable_scale)

If ``true``, this node's [global_transform](class_node3d.md#class_Node3D_property_global_transform) is automatically orthonormalized. This results in this node not appearing distorted, as if its global scale were set to [Vector3.ONE](class_vector3.md#class_Vector3_constant_ONE) (or its negative counterpart). See also [is_scale_disabled()](class_node3d.md#class_Node3D_method_is_scale_disabled) and [orthonormalize()](class_node3d.md#class_Node3D_method_orthonormalize).

\ **Note:** [transform](class_node3d.md#class_Node3D_property_transform) is not affected by this setting.

<hr class="classref-item-separator">

<a id="class_Node3D_method_set_identity"></a>

<!-- classref-method -->

`void` **set_identity**\ (\ ) [ðŸ”—](#class_Node3D_method_set_identity)

Sets this node's [transform](class_node3d.md#class_Node3D_property_transform) to [Transform3D.IDENTITY](class_transform3d.md#class_Transform3D_constant_IDENTITY), which resets all transformations in parent space ([position](class_node3d.md#class_Node3D_property_position), [rotation](class_node3d.md#class_Node3D_property_rotation), and [scale](class_node3d.md#class_Node3D_property_scale)).

<hr class="classref-item-separator">

<a id="class_Node3D_method_set_ignore_transform_notification"></a>

<!-- classref-method -->

`void` **set_ignore_transform_notification**\ (\ enabled\: [bool](class_bool.md)\ ) [ðŸ”—](#class_Node3D_method_set_ignore_transform_notification)

If ``true``, the node will not receive [NOTIFICATION_TRANSFORM_CHANGED](class_node3d.md#class_Node3D_constant_NOTIFICATION_TRANSFORM_CHANGED) or [NOTIFICATION_LOCAL_TRANSFORM_CHANGED](class_node3d.md#class_Node3D_constant_NOTIFICATION_LOCAL_TRANSFORM_CHANGED).

It may useful to call this method when handling these notifications to prevent infinite recursion.

<hr class="classref-item-separator">

<a id="class_Node3D_method_set_notify_local_transform"></a>

<!-- classref-method -->

`void` **set_notify_local_transform**\ (\ enable\: [bool](class_bool.md)\ ) [ðŸ”—](#class_Node3D_method_set_notify_local_transform)

If ``true``, the node will receive [NOTIFICATION_LOCAL_TRANSFORM_CHANGED](class_node3d.md#class_Node3D_constant_NOTIFICATION_LOCAL_TRANSFORM_CHANGED) whenever [transform](class_node3d.md#class_Node3D_property_transform) changes.

\ **Note:** Some 3D nodes such as [CSGShape3D](class_csgshape3d.md) or [CollisionShape3D](class_collisionshape3d.md) automatically enable this to function correctly.

<hr class="classref-item-separator">

<a id="class_Node3D_method_set_notify_transform"></a>

<!-- classref-method -->

`void` **set_notify_transform**\ (\ enable\: [bool](class_bool.md)\ ) [ðŸ”—](#class_Node3D_method_set_notify_transform)

If ``true``, the node will receive [NOTIFICATION_TRANSFORM_CHANGED](class_node3d.md#class_Node3D_constant_NOTIFICATION_TRANSFORM_CHANGED) whenever [global_transform](class_node3d.md#class_Node3D_property_global_transform) changes.

\ **Note:** Most 3D nodes such as [VisualInstance3D](class_visualinstance3d.md) or [CollisionObject3D](class_collisionobject3d.md) automatically enable this to function correctly.

\ **Note:** In the editor, nodes will propagate this notification to their children if a gizmo is attached (see [add_gizmo()](class_node3d.md#class_Node3D_method_add_gizmo)).

<hr class="classref-item-separator">

<a id="class_Node3D_method_set_subgizmo_selection"></a>

<!-- classref-method -->

`void` **set_subgizmo_selection**\ (\ gizmo\: [Node3DGizmo](class_node3dgizmo.md), id\: [int](class_int.md), transform\: [Transform3D](class_transform3d.md)\ ) [ðŸ”—](#class_Node3D_method_set_subgizmo_selection)

Selects the `gizmo`'s subgizmo with the given `id` and sets its transform. Only works in the editor.

\ **Note:** The gizmo object would typically be an instance of [EditorNode3DGizmo](class_editornode3dgizmo.md), but the argument type is kept generic to avoid creating a dependency on editor classes in **Node3D**.

<hr class="classref-item-separator">

<a id="class_Node3D_method_show"></a>

<!-- classref-method -->

`void` **show**\ (\ ) [ðŸ”—](#class_Node3D_method_show)

Allows this node to be rendered. Equivalent to setting [visible](class_node3d.md#class_Node3D_property_visible) to ``true``. This is the opposite of [hide()](class_node3d.md#class_Node3D_method_hide).

<hr class="classref-item-separator">

<a id="class_Node3D_method_to_global"></a>

<!-- classref-method -->

[Vector3](class_vector3.md) **to_global**\ (\ local_point\: [Vector3](class_vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_to_global)

Returns the `local_point` converted from this node's local space to global space. This is the opposite of [to_local()](class_node3d.md#class_Node3D_method_to_local).

<hr class="classref-item-separator">

<a id="class_Node3D_method_to_local"></a>

<!-- classref-method -->

[Vector3](class_vector3.md) **to_local**\ (\ global_point\: [Vector3](class_vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Node3D_method_to_local)

Returns the `global_point` converted from global space to this node's local space. This is the opposite of [to_global()](class_node3d.md#class_Node3D_method_to_global).

<hr class="classref-item-separator">

<a id="class_Node3D_method_translate"></a>

<!-- classref-method -->

`void` **translate**\ (\ offset\: [Vector3](class_vector3.md)\ ) [ðŸ”—](#class_Node3D_method_translate)

Adds the given translation `offset` to the node's position, in local space (relative to this node).

\ **Note:** Prefer using [translate_object_local()](class_node3d.md#class_Node3D_method_translate_object_local), instead, as this method may be changed in a future release.

\ **Note:** Despite the naming convention, this operation is **not** calculated in parent space for compatibility reasons. To translate in parent space, add `offset` to the [position](class_node3d.md#class_Node3D_property_position) (``node_3d.position += offset``).

<hr class="classref-item-separator">

<a id="class_Node3D_method_translate_object_local"></a>

<!-- classref-method -->

`void` **translate_object_local**\ (\ offset\: [Vector3](class_vector3.md)\ ) [ðŸ”—](#class_Node3D_method_translate_object_local)

Adds the given translation `offset` to the node's position, in local space (relative to this node).

<hr class="classref-item-separator">

<a id="class_Node3D_method_update_gizmos"></a>

<!-- classref-method -->

`void` **update_gizmos**\ (\ ) [ðŸ”—](#class_Node3D_method_update_gizmos)

Updates all the [EditorNode3DGizmo](class_editornode3dgizmo.md) objects attached to this node. Only works in the editor.

