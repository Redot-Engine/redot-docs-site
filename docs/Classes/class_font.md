<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Font.xml. -->

<a id="class_Font"></a>

# Font

**Inherits:** [Resource](class_resource.md) **<** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

**Inherited By:** [FontFile](class_fontfile.md), [FontVariation](class_fontvariation.md), [SystemFont](class_systemfont.md)

Abstract base class for fonts and font variations.

<!-- classref-introduction-group -->

## Description

Abstract base class for different font types. It has methods for drawing text and font character introspection.

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[Array](class_array.md)\[[Font](class_font.md)\]</th>
      <th>[fallbacks](#class_Font_property_fallbacks)</th>
      <th>`[]`</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[float](class_float.md)</th>
      <th>[draw_char](#class_Font_method_draw_char)\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), char\: [int](class_int.md), font_size\: [int](class_int.md), modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[draw_char_outline](#class_Font_method_draw_char_outline)\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), char\: [int](class_int.md), font_size\: [int](class_int.md), size\: [int](class_int.md) = -1, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[draw_multiline_string](#class_Font_method_draw_multiline_string)\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, max_lines\: [int](class_int.md) = -1, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), brk_flags\: **BitField**\[[LineBreakFlag](class_textserver.md#enum_TextServer_LineBreakFlag)\] = 3, justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0, oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[draw_multiline_string_outline](#class_Font_method_draw_multiline_string_outline)\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, max_lines\: [int](class_int.md) = -1, size\: [int](class_int.md) = 1, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), brk_flags\: **BitField**\[[LineBreakFlag](class_textserver.md#enum_TextServer_LineBreakFlag)\] = 3, justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0, oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[draw_string](#class_Font_method_draw_string)\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0, oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[draw_string_outline](#class_Font_method_draw_string_outline)\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, size\: [int](class_int.md) = 1, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0, oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[RID](class_rid.md)</td>
      <td>[find_variation](#class_Font_method_find_variation)\ (\ variation_coordinates\: [Dictionary](class_dictionary.md), face_index\: [int](class_int.md) = 0, strength\: [float](class_float.md) = 0.0, transform\: [Transform2D](class_transform2d.md) = Transform2D(1, 0, 0, 1, 0, 0), spacing_top\: [int](class_int.md) = 0, spacing_bottom\: [int](class_int.md) = 0, spacing_space\: [int](class_int.md) = 0, spacing_glyph\: [int](class_int.md) = 0, baseline_offset\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_ascent](#class_Font_method_get_ascent)\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[get_char_size](#class_Font_method_get_char_size)\ (\ char\: [int](class_int.md), font_size\: [int](class_int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_descent](#class_Font_method_get_descent)\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[get_face_count](#class_Font_method_get_face_count)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](class_string.md)</td>
      <td>[get_font_name](#class_Font_method_get_font_name)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[get_font_stretch](#class_Font_method_get_font_stretch)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>**BitField**\[[FontStyle](class_textserver.md#enum_TextServer_FontStyle)\]</td>
      <td>[get_font_style](#class_Font_method_get_font_style)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](class_string.md)</td>
      <td>[get_font_style_name](#class_Font_method_get_font_style_name)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[get_font_weight](#class_Font_method_get_font_weight)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_height](#class_Font_method_get_height)\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[get_multiline_string_size](#class_Font_method_get_multiline_string_size)\ (\ text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, max_lines\: [int](class_int.md) = -1, brk_flags\: **BitField**\[[LineBreakFlag](class_textserver.md#enum_TextServer_LineBreakFlag)\] = 3, justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Dictionary](class_dictionary.md)</td>
      <td>[get_opentype_features](#class_Font_method_get_opentype_features)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Dictionary](class_dictionary.md)</td>
      <td>[get_ot_name_strings](#class_Font_method_get_ot_name_strings)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Array](class_array.md)\[[RID](class_rid.md)\]</td>
      <td>[get_rids](#class_Font_method_get_rids)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[get_spacing](#class_Font_method_get_spacing)\ (\ spacing\: [SpacingType](class_textserver.md#enum_TextServer_SpacingType)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[get_string_size](#class_Font_method_get_string_size)\ (\ text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](class_string.md)</td>
      <td>[get_supported_chars](#class_Font_method_get_supported_chars)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Dictionary](class_dictionary.md)</td>
      <td>[get_supported_feature_list](#class_Font_method_get_supported_feature_list)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Dictionary](class_dictionary.md)</td>
      <td>[get_supported_variation_list](#class_Font_method_get_supported_variation_list)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_underline_position](#class_Font_method_get_underline_position)\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_underline_thickness](#class_Font_method_get_underline_thickness)\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[has_char](#class_Font_method_has_char)\ (\ char\: [int](class_int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_language_supported](#class_Font_method_is_language_supported)\ (\ language\: [String](class_string.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_script_supported](#class_Font_method_is_script_supported)\ (\ script\: [String](class_string.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_cache_capacity](#class_Font_method_set_cache_capacity)\ (\ single_line\: [int](class_int.md), multi_line\: [int](class_int.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_Font_property_fallbacks"></a>

<!-- classref-property -->

[Array](class_array.md)\[[Font](class_font.md)\] **fallbacks** = `[]` [ðŸ”—](#class_Font_property_fallbacks)

<!-- classref-property-setget -->

- `void` **set_fallbacks**\ (\ value\: [Array](class_array.md)\[[Font](class_font.md)\]\ )
- [Array](class_array.md)\[[Font](class_font.md)\] **get_fallbacks**\ (\ )

Array of fallback **Font**\ s to use as a substitute if a glyph is not found in this current **Font**.

If this array is empty in a [FontVariation](class_fontvariation.md), the [FontVariation.base_font](class_fontvariation.md#class_FontVariation_property_base_font)'s fallbacks are used instead.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_Font_method_draw_char"></a>

<!-- classref-method -->

[float](class_float.md) **draw_char**\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), char\: [int](class_int.md), font_size\: [int](class_int.md), modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_draw_char)

Draw a single Unicode character `char` into a canvas item using the font, at a given position, with `modulate` color. `pos` specifies the baseline, not the top. To draw from the top, *ascent* must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.

\ **Note:** Do not use this function to draw strings character by character, use [draw_string()](class_font.md#class_Font_method_draw_string) or [TextLine](class_textline.md) instead.

<hr class="classref-item-separator">

<a id="class_Font_method_draw_char_outline"></a>

<!-- classref-method -->

[float](class_float.md) **draw_char_outline**\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), char\: [int](class_int.md), font_size\: [int](class_int.md), size\: [int](class_int.md) = -1, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_draw_char_outline)

Draw a single Unicode character `char` outline into a canvas item using the font, at a given position, with `modulate` color and `size` outline size. `pos` specifies the baseline, not the top. To draw from the top, *ascent* must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.

\ **Note:** Do not use this function to draw strings character by character, use [draw_string()](class_font.md#class_Font_method_draw_string) or [TextLine](class_textline.md) instead.

<hr class="classref-item-separator">

<a id="class_Font_method_draw_multiline_string"></a>

<!-- classref-method -->

`void` **draw_multiline_string**\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, max_lines\: [int](class_int.md) = -1, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), brk_flags\: **BitField**\[[LineBreakFlag](class_textserver.md#enum_TextServer_LineBreakFlag)\] = 3, justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0, oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_draw_multiline_string)

Breaks `text` into lines using rules specified by `brk_flags` and draws it into a canvas item using the font, at a given position, with `modulate` color, optionally clipping the width and aligning horizontally. `pos` specifies the baseline of the first line, not the top. To draw from the top, *ascent* must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.

See also [CanvasItem.draw_multiline_string()](class_canvasitem.md#class_CanvasItem_method_draw_multiline_string).

<hr class="classref-item-separator">

<a id="class_Font_method_draw_multiline_string_outline"></a>

<!-- classref-method -->

`void` **draw_multiline_string_outline**\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, max_lines\: [int](class_int.md) = -1, size\: [int](class_int.md) = 1, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), brk_flags\: **BitField**\[[LineBreakFlag](class_textserver.md#enum_TextServer_LineBreakFlag)\] = 3, justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0, oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_draw_multiline_string_outline)

Breaks `text` to the lines using rules specified by `brk_flags` and draws text outline into a canvas item using the font, at a given position, with `modulate` color and `size` outline size, optionally clipping the width and aligning horizontally. `pos` specifies the baseline of the first line, not the top. To draw from the top, *ascent* must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.

See also [CanvasItem.draw_multiline_string_outline()](class_canvasitem.md#class_CanvasItem_method_draw_multiline_string_outline).

<hr class="classref-item-separator">

<a id="class_Font_method_draw_string"></a>

<!-- classref-method -->

`void` **draw_string**\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0, oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_draw_string)

Draw `text` into a canvas item using the font, at a given position, with `modulate` color, optionally clipping the width and aligning horizontally. `pos` specifies the baseline, not the top. To draw from the top, *ascent* must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.

See also [CanvasItem.draw_string()](class_canvasitem.md#class_CanvasItem_method_draw_string).

<hr class="classref-item-separator">

<a id="class_Font_method_draw_string_outline"></a>

<!-- classref-method -->

`void` **draw_string_outline**\ (\ canvas_item\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, size\: [int](class_int.md) = 1, modulate\: [Color](class_color.md) = Color(1, 1, 1, 1), justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0, oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_draw_string_outline)

Draw `text` outline into a canvas item using the font, at a given position, with `modulate` color and `size` outline size, optionally clipping the width and aligning horizontally. `pos` specifies the baseline, not the top. To draw from the top, *ascent* must be added to the Y axis. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.

See also [CanvasItem.draw_string_outline()](class_canvasitem.md#class_CanvasItem_method_draw_string_outline).

<hr class="classref-item-separator">

<a id="class_Font_method_find_variation"></a>

<!-- classref-method -->

[RID](class_rid.md) **find_variation**\ (\ variation_coordinates\: [Dictionary](class_dictionary.md), face_index\: [int](class_int.md) = 0, strength\: [float](class_float.md) = 0.0, transform\: [Transform2D](class_transform2d.md) = Transform2D(1, 0, 0, 1, 0, 0), spacing_top\: [int](class_int.md) = 0, spacing_bottom\: [int](class_int.md) = 0, spacing_space\: [int](class_int.md) = 0, spacing_glyph\: [int](class_int.md) = 0, baseline_offset\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_find_variation)

Returns [TextServer](class_textserver.md) RID of the font cache for specific variation.

<hr class="classref-item-separator">

<a id="class_Font_method_get_ascent"></a>

<!-- classref-method -->

[float](class_float.md) **get_ascent**\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_ascent)

Returns the average font ascent (number of pixels above the baseline).

\ **Note:** Real ascent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the ascent of empty line).

<hr class="classref-item-separator">

<a id="class_Font_method_get_char_size"></a>

<!-- classref-method -->

[Vector2](class_vector2.md) **get_char_size**\ (\ char\: [int](class_int.md), font_size\: [int](class_int.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_char_size)

Returns the size of a character. Does not take kerning into account.

\ **Note:** Do not use this function to calculate width of the string character by character, use [get_string_size()](class_font.md#class_Font_method_get_string_size) or [TextLine](class_textline.md) instead. The height returned is the font height (see also [get_height()](class_font.md#class_Font_method_get_height)) and has no relation to the glyph height.

<hr class="classref-item-separator">

<a id="class_Font_method_get_descent"></a>

<!-- classref-method -->

[float](class_float.md) **get_descent**\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_descent)

Returns the average font descent (number of pixels below the baseline).

\ **Note:** Real descent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the descent of empty line).

<hr class="classref-item-separator">

<a id="class_Font_method_get_face_count"></a>

<!-- classref-method -->

[int](class_int.md) **get_face_count**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_face_count)

Returns number of faces in the TrueType / OpenType collection.

<hr class="classref-item-separator">

<a id="class_Font_method_get_font_name"></a>

<!-- classref-method -->

[String](class_string.md) **get_font_name**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_font_name)

Returns font family name.

<hr class="classref-item-separator">

<a id="class_Font_method_get_font_stretch"></a>

<!-- classref-method -->

[int](class_int.md) **get_font_stretch**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_font_stretch)

Returns font stretch amount, compared to a normal width. A percentage value between ``50%`` and ``200%``.

<hr class="classref-item-separator">

<a id="class_Font_method_get_font_style"></a>

<!-- classref-method -->

**BitField**\[[FontStyle](class_textserver.md#enum_TextServer_FontStyle)\] **get_font_style**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_font_style)

Returns font style flags.

<hr class="classref-item-separator">

<a id="class_Font_method_get_font_style_name"></a>

<!-- classref-method -->

[String](class_string.md) **get_font_style_name**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_font_style_name)

Returns font style name.

<hr class="classref-item-separator">

<a id="class_Font_method_get_font_weight"></a>

<!-- classref-method -->

[int](class_int.md) **get_font_weight**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_font_weight)

Returns weight (boldness) of the font. A value in the ``100...999`` range, normal font weight is ``400``, bold font weight is ``700``.

<hr class="classref-item-separator">

<a id="class_Font_method_get_height"></a>

<!-- classref-method -->

[float](class_float.md) **get_height**\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_height)

Returns the total average font height (ascent plus descent) in pixels.

\ **Note:** Real height of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the height of empty line).

<hr class="classref-item-separator">

<a id="class_Font_method_get_multiline_string_size"></a>

<!-- classref-method -->

[Vector2](class_vector2.md) **get_multiline_string_size**\ (\ text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, max_lines\: [int](class_int.md) = -1, brk_flags\: **BitField**\[[LineBreakFlag](class_textserver.md#enum_TextServer_LineBreakFlag)\] = 3, justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_multiline_string_size)

Returns the size of a bounding box of a string broken into the lines, taking kerning and advance into account.

See also [draw_multiline_string()](class_font.md#class_Font_method_draw_multiline_string).

<hr class="classref-item-separator">

<a id="class_Font_method_get_opentype_features"></a>

<!-- classref-method -->

[Dictionary](class_dictionary.md) **get_opentype_features**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_opentype_features)

Returns a set of OpenType feature tags. More info: [OpenType feature tags](https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags).

<hr class="classref-item-separator">

<a id="class_Font_method_get_ot_name_strings"></a>

<!-- classref-method -->

[Dictionary](class_dictionary.md) **get_ot_name_strings**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_ot_name_strings)

Returns [Dictionary](class_dictionary.md) with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).

<hr class="classref-item-separator">

<a id="class_Font_method_get_rids"></a>

<!-- classref-method -->

[Array](class_array.md)\[[RID](class_rid.md)\] **get_rids**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_rids)

Returns [Array](class_array.md) of valid **Font** [RID](class_rid.md)\ s, which can be passed to the [TextServer](class_textserver.md) methods.

<hr class="classref-item-separator">

<a id="class_Font_method_get_spacing"></a>

<!-- classref-method -->

[int](class_int.md) **get_spacing**\ (\ spacing\: [SpacingType](class_textserver.md#enum_TextServer_SpacingType)\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_spacing)

Returns the amount of spacing for the given `spacing` type.

<hr class="classref-item-separator">

<a id="class_Font_method_get_string_size"></a>

<!-- classref-method -->

[Vector2](class_vector2.md) **get_string_size**\ (\ text\: [String](class_string.md), alignment\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) = 0, width\: [float](class_float.md) = -1, font_size\: [int](class_int.md) = 16, justification_flags\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] = 3, direction\: [Direction](class_textserver.md#enum_TextServer_Direction) = 0, orientation\: [Orientation](class_textserver.md#enum_TextServer_Orientation) = 0\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_string_size)

Returns the size of a bounding box of a single-line string, taking kerning, advance and subpixel positioning into account. See also [get_multiline_string_size()](class_font.md#class_Font_method_get_multiline_string_size) and [draw_string()](class_font.md#class_Font_method_draw_string).

For example, to get the string size as displayed by a single-line Label, use:




```gdscript
    var string_size = $Label.get_theme_font("font").get_string_size($Label.text, HORIZONTAL_ALIGNMENT_LEFT, -1, $Label.get_theme_font_size("font_size"))
```

```csharp
    Label label = GetNode<Label>("Label");
    Vector2 stringSize = label.GetThemeFont("font").GetStringSize(label.Text, HorizontalAlignment.Left, -1, label.GetThemeFontSize("font_size"));
```



\ **Note:** Since kerning, advance and subpixel positioning are taken into account by [get_string_size()](class_font.md#class_Font_method_get_string_size), using separate [get_string_size()](class_font.md#class_Font_method_get_string_size) calls on substrings of a string then adding the results together will return a different result compared to using a single [get_string_size()](class_font.md#class_Font_method_get_string_size) call on the full string.

\ **Note:** Real height of the string is context-dependent and can be significantly different from the value returned by [get_height()](class_font.md#class_Font_method_get_height).

<hr class="classref-item-separator">

<a id="class_Font_method_get_supported_chars"></a>

<!-- classref-method -->

[String](class_string.md) **get_supported_chars**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_supported_chars)

Returns a string containing all the characters available in the font.

If a given character is included in more than one font data source, it appears only once in the returned string.

<hr class="classref-item-separator">

<a id="class_Font_method_get_supported_feature_list"></a>

<!-- classref-method -->

[Dictionary](class_dictionary.md) **get_supported_feature_list**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_supported_feature_list)

Returns list of OpenType features supported by font.

<hr class="classref-item-separator">

<a id="class_Font_method_get_supported_variation_list"></a>

<!-- classref-method -->

[Dictionary](class_dictionary.md) **get_supported_variation_list**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_supported_variation_list)

Returns list of supported [variation coordinates](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg), each coordinate is returned as ``tag: Vector3i(min_value,max_value,default_value)``.

Font variations allow for continuous change of glyph characteristics along some given design axis, such as weight, width or slant.

To print available variation axes of a variable font:

```
    var fv = FontVariation.new()
    fv.base_font = load("res://RobotoFlex.ttf")
    var variation_list = fv.get_supported_variation_list()
    for tag in variation_list:
        var name = TextServerManager.get_primary_interface().tag_to_name(tag)
        var values = variation_list[tag]
        print("variation axis: %s (%d)\n\tmin, max, default: %s" % [name, tag, values])
```

\ **Note:** To set and get variation coordinates of a [FontVariation](class_fontvariation.md), use [FontVariation.variation_opentype](class_fontvariation.md#class_FontVariation_property_variation_opentype).

<hr class="classref-item-separator">

<a id="class_Font_method_get_underline_position"></a>

<!-- classref-method -->

[float](class_float.md) **get_underline_position**\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_underline_position)

Returns average pixel offset of the underline below the baseline.

\ **Note:** Real underline position of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.

<hr class="classref-item-separator">

<a id="class_Font_method_get_underline_thickness"></a>

<!-- classref-method -->

[float](class_float.md) **get_underline_thickness**\ (\ font_size\: [int](class_int.md) = 16\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_get_underline_thickness)

Returns average thickness of the underline.

\ **Note:** Real underline thickness of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.

<hr class="classref-item-separator">

<a id="class_Font_method_has_char"></a>

<!-- classref-method -->

[bool](class_bool.md) **has_char**\ (\ char\: [int](class_int.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_has_char)

Returns ``true`` if a Unicode `char` is available in the font.

<hr class="classref-item-separator">

<a id="class_Font_method_is_language_supported"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_language_supported**\ (\ language\: [String](class_string.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_is_language_supported)

Returns ``true``, if font supports given language ([ISO 639](https://en.wikipedia.org/wiki/ISO_639-1) code).

<hr class="classref-item-separator">

<a id="class_Font_method_is_script_supported"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_script_supported**\ (\ script\: [String](class_string.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Font_method_is_script_supported)

Returns ``true``, if font supports given script ([ISO 15924](https://en.wikipedia.org/wiki/ISO_15924) code).

<hr class="classref-item-separator">

<a id="class_Font_method_set_cache_capacity"></a>

<!-- classref-method -->

`void` **set_cache_capacity**\ (\ single_line\: [int](class_int.md), multi_line\: [int](class_int.md)\ ) [ðŸ”—](#class_Font_method_set_cache_capacity)

Sets LRU cache capacity for ``draw_*`` methods.

