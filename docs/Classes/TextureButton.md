<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/TextureButton.xml. -->

<a id="TextureButton"></a>

# TextureButton

**Inherits:** [BaseButton](BaseButton.md) **\<** [Control](Control.md) **\<** [CanvasItem](CanvasItem.md) **\<** [Node](Node.md) **\<** [Object](Object.md)

Texture-based button. Supports Pressed, Hover, Disabled and Focused states.

<!-- classref-introduction-group -->

## Description

**TextureButton** has the same functionality as [Button](Button.md), except it uses sprites instead of Redot's [Theme](Theme.md) resource. It is faster to create, but it doesn't support localization like more complex [Control](Control.md)\\ s.

See also [BaseButton](BaseButton.md) which contains common properties and methods associated with this node.

\ **Note:** Setting a texture for the "normal" state ([texture_normal](TextureButton.md#TextureButton_property_texture_normal)) is recommended. If [texture_normal](TextureButton.md#TextureButton_property_texture_normal) is not set, the **TextureButton** will still receive input events and be clickable, but the user will not be able to see it unless they activate another one of its states with a texture assigned (e.g., hover over it to show [texture_hover](TextureButton.md#TextureButton_property_texture_hover)).

<!-- classref-introduction-group -->

## Tutorials

- [3D Voxel Demo](https://godotengine.org/asset-library/asset/2755)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[flip_h](#TextureButton_property_flip_h)</th>
      <th>`false`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[flip_v](#TextureButton_property_flip_v)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[ignore_texture_size](#TextureButton_property_ignore_texture_size)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[StretchMode](TextureButton.md#enum_TextureButton_StretchMode)</td>
      <td>[stretch_mode](#TextureButton_property_stretch_mode)</td>
      <td>`2`</td>
    </tr>
    <tr>
      <td>[BitMap](BitMap.md)</td>
      <td>[texture_click_mask](#TextureButton_property_texture_click_mask)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[texture_disabled](#TextureButton_property_texture_disabled)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[texture_focused](#TextureButton_property_texture_focused)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[texture_hover](#TextureButton_property_texture_hover)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[texture_normal](#TextureButton_property_texture_normal)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Texture2D](Texture2D.md)</td>
      <td>[texture_pressed](#TextureButton_property_texture_pressed)</td>
      <td></td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_TextureButton_StretchMode"></a>

<!-- classref-enumeration -->

enum **StretchMode**: [ðŸ”—](#enum_TextureButton_StretchMode)

<a id="TextureButton_constant_STRETCH_SCALE"></a>

<!-- classref-enumeration-constant -->

[StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **STRETCH_SCALE** = `0`

Scale to fit the node's bounding rectangle.<a id="TextureButton_constant_STRETCH_TILE"></a>

<!-- classref-enumeration-constant -->

[StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **STRETCH_TILE** = `1`

Tile inside the node's bounding rectangle.<a id="TextureButton_constant_STRETCH_KEEP"></a>

<!-- classref-enumeration-constant -->

[StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **STRETCH_KEEP** = `2`

The texture keeps its original size and stays in the bounding rectangle's top-left corner.<a id="TextureButton_constant_STRETCH_KEEP_CENTERED"></a>

<!-- classref-enumeration-constant -->

[StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **STRETCH_KEEP_CENTERED** = `3`

The texture keeps its original size and stays centered in the node's bounding rectangle.<a id="TextureButton_constant_STRETCH_KEEP_ASPECT"></a>

<!-- classref-enumeration-constant -->

[StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **STRETCH_KEEP_ASPECT** = `4`

Scale the texture to fit the node's bounding rectangle, but maintain the texture's aspect ratio.<a id="TextureButton_constant_STRETCH_KEEP_ASPECT_CENTERED"></a>

<!-- classref-enumeration-constant -->

[StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **STRETCH_KEEP_ASPECT_CENTERED** = `5`

Scale the texture to fit the node's bounding rectangle, center it, and maintain its aspect ratio.<a id="TextureButton_constant_STRETCH_KEEP_ASPECT_COVERED"></a>

<!-- classref-enumeration-constant -->

[StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **STRETCH_KEEP_ASPECT_COVERED** = `6`

Scale the texture so that the shorter side fits the bounding rectangle. The other side clips to the node's limits.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="TextureButton_property_flip_h"></a>

<!-- classref-property -->

[bool](bool.md) **flip_h** = `false` [ðŸ”—](#TextureButton_property_flip_h)

<!-- classref-property-setget -->

- `void` **set_flip_h**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_flipped_h**\ (\ )

If ``true``, texture is flipped horizontally.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_flip_v"></a>

<!-- classref-property -->

[bool](bool.md) **flip_v** = `false` [ðŸ”—](#TextureButton_property_flip_v)

<!-- classref-property-setget -->

- `void` **set_flip_v**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_flipped_v**\ (\ )

If ``true``, texture is flipped vertically.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_ignore_texture_size"></a>

<!-- classref-property -->

[bool](bool.md) **ignore_texture_size** = `false` [ðŸ”—](#TextureButton_property_ignore_texture_size)

<!-- classref-property-setget -->

- `void` **set_ignore_texture_size**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_ignore_texture_size**\ (\ )

If ``true``, the size of the texture won't be considered for minimum size calculation, so the **TextureButton** can be shrunk down past the texture size.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_stretch_mode"></a>

<!-- classref-property -->

[StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **stretch_mode** = `2` [ðŸ”—](#TextureButton_property_stretch_mode)

<!-- classref-property-setget -->

- `void` **set_stretch_mode**\ (\ value\: [StretchMode](TextureButton.md#enum_TextureButton_StretchMode)\ )
- [StretchMode](TextureButton.md#enum_TextureButton_StretchMode) **get_stretch_mode**\ (\ )

Controls the texture's behavior when you resize the node's bounding rectangle. See the [StretchMode](TextureButton.md#enum_TextureButton_StretchMode) constants for available options.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_texture_click_mask"></a>

<!-- classref-property -->

[BitMap](BitMap.md) **texture_click_mask** [ðŸ”—](#TextureButton_property_texture_click_mask)

<!-- classref-property-setget -->

- `void` **set_click_mask**\ (\ value\: [BitMap](BitMap.md)\ )
- [BitMap](BitMap.md) **get_click_mask**\ (\ )

Pure black and white [BitMap](BitMap.md) image to use for click detection. On the mask, white pixels represent the button's clickable area. Use it to create buttons with curved shapes.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_texture_disabled"></a>

<!-- classref-property -->

[Texture2D](Texture2D.md) **texture_disabled** [ðŸ”—](#TextureButton_property_texture_disabled)

<!-- classref-property-setget -->

- `void` **set_texture_disabled**\ (\ value\: [Texture2D](Texture2D.md)\ )
- [Texture2D](Texture2D.md) **get_texture_disabled**\ (\ )

Texture to display when the node is disabled. See [BaseButton.disabled](BaseButton.md#BaseButton_property_disabled). If not assigned, the **TextureButton** displays [texture_normal](TextureButton.md#TextureButton_property_texture_normal) instead.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_texture_focused"></a>

<!-- classref-property -->

[Texture2D](Texture2D.md) **texture_focused** [ðŸ”—](#TextureButton_property_texture_focused)

<!-- classref-property-setget -->

- `void` **set_texture_focused**\ (\ value\: [Texture2D](Texture2D.md)\ )
- [Texture2D](Texture2D.md) **get_texture_focused**\ (\ )

Texture to *overlay on the base texture* when the node has mouse or keyboard focus. Because [texture_focused](TextureButton.md#TextureButton_property_texture_focused) is displayed on top of the base texture, a partially transparent texture should be used to ensure the base texture remains visible. A texture that represents an outline or an underline works well for this purpose. To disable the focus visual effect, assign a fully transparent texture of any size. Note that disabling the focus visual effect will harm keyboard/controller navigation usability, so this is not recommended for accessibility reasons.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_texture_hover"></a>

<!-- classref-property -->

[Texture2D](Texture2D.md) **texture_hover** [ðŸ”—](#TextureButton_property_texture_hover)

<!-- classref-property-setget -->

- `void` **set_texture_hover**\ (\ value\: [Texture2D](Texture2D.md)\ )
- [Texture2D](Texture2D.md) **get_texture_hover**\ (\ )

Texture to display when the mouse hovers over the node. If not assigned, the **TextureButton** displays [texture_normal](TextureButton.md#TextureButton_property_texture_normal) instead when hovered over.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_texture_normal"></a>

<!-- classref-property -->

[Texture2D](Texture2D.md) **texture_normal** [ðŸ”—](#TextureButton_property_texture_normal)

<!-- classref-property-setget -->

- `void` **set_texture_normal**\ (\ value\: [Texture2D](Texture2D.md)\ )
- [Texture2D](Texture2D.md) **get_texture_normal**\ (\ )

Texture to display by default, when the node is **not** in the disabled, hover or pressed state. This texture is still displayed in the focused state, with [texture_focused](TextureButton.md#TextureButton_property_texture_focused) drawn on top.

<hr class="classref-item-separator"/>

<a id="TextureButton_property_texture_pressed"></a>

<!-- classref-property -->

[Texture2D](Texture2D.md) **texture_pressed** [ðŸ”—](#TextureButton_property_texture_pressed)

<!-- classref-property-setget -->

- `void` **set_texture_pressed**\ (\ value\: [Texture2D](Texture2D.md)\ )
- [Texture2D](Texture2D.md) **get_texture_pressed**\ (\ )

Texture to display on mouse down over the node, if the node has keyboard focus and the player presses the Enter key or if the player presses the [BaseButton.shortcut](BaseButton.md#BaseButton_property_shortcut) key. If not assigned, the **TextureButton** displays [texture_hover](TextureButton.md#TextureButton_property_texture_hover) instead when pressed.

