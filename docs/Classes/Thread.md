<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Thread.xml. -->

<a id="Thread"></a>

# Thread

**Inherits:** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

A unit of execution in a process.

<!-- classref-introduction-group -->

## Description

A unit of execution in a process. Can run methods on [Object](Object.md)\\ s simultaneously. The use of synchronization via [Mutex](Mutex.md) or [Semaphore](Semaphore.md) is advised if working with shared objects.

\ **Warning:**\\ 

To ensure proper cleanup without crashes or deadlocks, when a **Thread**'s reference count reaches zero and it is therefore destroyed, the following conditions must be met:

- It must not have any [Mutex](Mutex.md) objects locked.

- It must not be waiting on any [Semaphore](Semaphore.md) objects.

- [wait_to_finish()](Thread.md#Thread_method_wait_to_finish) should have been called on it.

<!-- classref-introduction-group -->

## Tutorials

- [Using multiple threads](../tutorials/performance/using_multiple_threads.md)

- [Thread-safe APIs](../tutorials/performance/thread_safe_apis.md)

- [3D Voxel Demo](https://godotengine.org/asset-library/asset/2755)

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[String](String.md)</th>
      <th>[get_id](#Thread_method_get_id)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_alive](#Thread_method_is_alive)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_started](#Thread_method_is_started)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_thread_safety_checks_enabled](#Thread_method_set_thread_safety_checks_enabled)\ (\ enabled\: [bool](bool.md)\ ) <span class="static">static</span></td>
    </tr>
    <tr>
      <td>[Error](@GlobalScope.md#enum_@GlobalScope_Error)</td>
      <td>[start](#Thread_method_start)\ (\ callable\: [Callable](Callable.md), priority\: [Priority](Thread.md#enum_Thread_Priority) = 1\ )</td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[wait_to_finish](#Thread_method_wait_to_finish)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_Thread_Priority"></a>

<!-- classref-enumeration -->

enum **Priority**: [ðŸ”—](#enum_Thread_Priority)

<a id="Thread_constant_PRIORITY_LOW"></a>

<!-- classref-enumeration-constant -->

[Priority](Thread.md#enum_Thread_Priority) **PRIORITY_LOW** = `0`

A thread running with lower priority than normally.<a id="Thread_constant_PRIORITY_NORMAL"></a>

<!-- classref-enumeration-constant -->

[Priority](Thread.md#enum_Thread_Priority) **PRIORITY_NORMAL** = `1`

A thread with a standard priority.<a id="Thread_constant_PRIORITY_HIGH"></a>

<!-- classref-enumeration-constant -->

[Priority](Thread.md#enum_Thread_Priority) **PRIORITY_HIGH** = `2`

A thread running with higher priority than normally.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Thread_method_get_id"></a>

<!-- classref-method -->

[String](String.md) **get_id**\ (\ ) <span class="const">const</span> [ðŸ”—](#Thread_method_get_id)

Returns the current **Thread**'s ID, uniquely identifying it among all threads. If the **Thread** has not started running or if [wait_to_finish()](Thread.md#Thread_method_wait_to_finish) has been called, this returns an empty string.

<hr class="classref-item-separator"/>

<a id="Thread_method_is_alive"></a>

<!-- classref-method -->

[bool](bool.md) **is_alive**\ (\ ) <span class="const">const</span> [ðŸ”—](#Thread_method_is_alive)

Returns ``true`` if this **Thread** is currently running the provided function. This is useful for determining if [wait_to_finish()](Thread.md#Thread_method_wait_to_finish) can be called without blocking the calling thread.

To check if a **Thread** is joinable, use [is_started()](Thread.md#Thread_method_is_started).

<hr class="classref-item-separator"/>

<a id="Thread_method_is_started"></a>

<!-- classref-method -->

[bool](bool.md) **is_started**\ (\ ) <span class="const">const</span> [ðŸ”—](#Thread_method_is_started)

Returns ``true`` if this **Thread** has been started. Once started, this will return ``true`` until it is joined using [wait_to_finish()](Thread.md#Thread_method_wait_to_finish). For checking if a **Thread** is still executing its task, use [is_alive()](Thread.md#Thread_method_is_alive).

<hr class="classref-item-separator"/>

<a id="Thread_method_set_thread_safety_checks_enabled"></a>

<!-- classref-method -->

`void` **set_thread_safety_checks_enabled**\ (\ enabled\: [bool](bool.md)\ ) <span class="static">static</span> [ðŸ”—](#Thread_method_set_thread_safety_checks_enabled)

Sets whether the thread safety checks the engine normally performs in methods of certain classes (e.g., [Node](Node.md)) should happen **on the current thread**.

The default, for every thread, is that they are enabled (as if called with `enabled` being ``true``).

Those checks are conservative. That means that they will only succeed in considering a call thread-safe (and therefore allow it to happen) if the engine can guarantee such safety.

Because of that, there may be cases where the user may want to disable them (`enabled` being ``false``) to make certain operations allowed again. By doing so, it becomes the user's responsibility to ensure thread safety (e.g., by using [Mutex](Mutex.md)) for those objects that are otherwise protected by the engine.

\ **Note:** This is an advanced usage of the engine. You are advised to use it only if you know what you are doing and there is no safer way.

\ **Note:** This is useful for scripts running on either arbitrary **Thread** objects or tasks submitted to the [WorkerThreadPool](WorkerThreadPool.md). It doesn't apply to code running during [Node](Node.md) group processing, where the checks will be always performed.

\ **Note:** Even in the case of having disabled the checks in a [WorkerThreadPool](WorkerThreadPool.md) task, there's no need to re-enable them at the end. The engine will do so.

<hr class="classref-item-separator"/>

<a id="Thread_method_start"></a>

<!-- classref-method -->

[Error](@GlobalScope.md#enum_@GlobalScope_Error) **start**\ (\ callable\: [Callable](Callable.md), priority\: [Priority](Thread.md#enum_Thread_Priority) = 1\ ) [ðŸ”—](#Thread_method_start)

Starts a new **Thread** that calls `callable`.

If the method takes some arguments, you can pass them using [Callable.bind()](Callable.md#Callable_method_bind).

The `priority` of the **Thread** can be changed by passing a value from the [Priority](Thread.md#enum_Thread_Priority) enum.

Returns [@GlobalScope.OK](@GlobalScope.md#@GlobalScope_constant_OK) on success, or [@GlobalScope.ERR_CANT_CREATE](@GlobalScope.md#@GlobalScope_constant_ERR_CANT_CREATE) on failure.

<hr class="classref-item-separator"/>

<a id="Thread_method_wait_to_finish"></a>

<!-- classref-method -->

[Variant](Variant.md) **wait_to_finish**\ (\ ) [ðŸ”—](#Thread_method_wait_to_finish)

Joins the **Thread** and waits for it to finish. Returns the output of the [Callable](Callable.md) passed to [start()](Thread.md#Thread_method_start).

Should either be used when you want to retrieve the value returned from the method called by the **Thread** or before freeing the instance that contains the **Thread**.

To determine if this can be called without blocking the calling thread, check if [is_alive()](Thread.md#Thread_method_is_alive) is ``false``.

