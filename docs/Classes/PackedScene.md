<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/PackedScene.xml. -->

<a id="PackedScene"></a>

# PackedScene

**Inherits:** [Resource](Resource.md) **\<** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

An abstraction of a serialized scene.

<!-- classref-introduction-group -->

## Description

A simplified interface to a scene file. Provides access to operations and checks that can be performed on the scene resource itself.

Can be used to save a node to a file. When saving, the node as well as all the nodes it owns get saved (see [Node.owner](Node.md#Node_property_owner) property).

\ **Note:** The node doesn't need to own itself.

\ **Example:** Load a saved scene:




```gdscript
    # Use load() instead of preload() if the path isn't known at compile-time.
    var scene = preload("res://scene.tscn").instantiate()
    # Add the node as a child of the node the script is attached to.
    add_child(scene)
```


```csharp
    // C# has no preload, so you have to always use ResourceLoader.Load<PackedScene>().
    var scene = ResourceLoader.Load<PackedScene>("res://scene.tscn").Instantiate();
    // Add the node as a child of the node the script is attached to.
    AddChild(scene);
```




\ **Example:** Save a node with different owners. The following example creates 3 objects: [Node2D](Node2D.md) (``node``), [RigidBody2D](RigidBody2D.md) (``body``) and [CollisionObject2D](CollisionObject2D.md) (``collision``). ``collision`` is a child of ``body`` which is a child of ``node``. Only ``body`` is owned by ``node`` and [pack()](PackedScene.md#PackedScene_method_pack) will therefore only save those two nodes, but not ``collision``.




```gdscript
    # Create the objects.
    var node = Node2D.new()
    var body = RigidBody2D.new()
    var collision = CollisionShape2D.new()

    # Create the object hierarchy.
    body.add_child(collision)
    node.add_child(body)

    # Change owner of `body`, but not of `collision`.
    body.owner = node
    var scene = PackedScene.new()

    # Only `node` and `body` are now packed.
    var result = scene.pack(node)
    if result == OK:
        var error = ResourceSaver.save(scene, "res://path/name.tscn")  # Or "user://..."
        if error != OK:
            push_error("An error occurred while saving the scene to disk.")
```


```csharp
    // Create the objects.
    var node = new Node2D();
    var body = new RigidBody2D();
    var collision = new CollisionShape2D();

    // Create the object hierarchy.
    body.AddChild(collision);
    node.AddChild(body);

    // Change owner of `body`, but not of `collision`.
    body.Owner = node;
    var scene = new PackedScene();

    // Only `node` and `body` are now packed.
    Error result = scene.Pack(node);
    if (result == Error.Ok)
    {
        Error error = ResourceSaver.Save(scene, "res://path/name.tscn"); // Or "user://..."
        if (error != Error.Ok)
        {
            GD.PushError("An error occurred while saving the scene to disk.");
        }
    }
```




<!-- classref-introduction-group -->

## Tutorials

- [2D Role Playing Game (RPG) Demo](https://godotengine.org/asset-library/asset/2729)

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[can_instantiate](#PackedScene_method_can_instantiate)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[SceneState](SceneState.md)</td>
      <td>[get_state](#PackedScene_method_get_state)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Node](Node.md)</td>
      <td>[instantiate](#PackedScene_method_instantiate)\ (\ edit_state\: [GenEditState](PackedScene.md#enum_PackedScene_GenEditState) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Error](@GlobalScope.md#enum_@GlobalScope_Error)</td>
      <td>[pack](#PackedScene_method_pack)\ (\ path\: [Node](Node.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_PackedScene_GenEditState"></a>

<!-- classref-enumeration -->

enum **GenEditState**: [ðŸ”—](#enum_PackedScene_GenEditState)

<a id="PackedScene_constant_GEN_EDIT_STATE_DISABLED"></a>

<!-- classref-enumeration-constant -->

[GenEditState](PackedScene.md#enum_PackedScene_GenEditState) **GEN_EDIT_STATE_DISABLED** = `0`

If passed to [instantiate()](PackedScene.md#PackedScene_method_instantiate), blocks edits to the scene state.<a id="PackedScene_constant_GEN_EDIT_STATE_INSTANCE"></a>

<!-- classref-enumeration-constant -->

[GenEditState](PackedScene.md#enum_PackedScene_GenEditState) **GEN_EDIT_STATE_INSTANCE** = `1`

If passed to [instantiate()](PackedScene.md#PackedScene_method_instantiate), provides local scene resources to the local scene.

\ **Note:** Only available in editor builds.<a id="PackedScene_constant_GEN_EDIT_STATE_MAIN"></a>

<!-- classref-enumeration-constant -->

[GenEditState](PackedScene.md#enum_PackedScene_GenEditState) **GEN_EDIT_STATE_MAIN** = `2`

If passed to [instantiate()](PackedScene.md#PackedScene_method_instantiate), provides local scene resources to the local scene. Only the main scene should receive the main edit state.

\ **Note:** Only available in editor builds.<a id="PackedScene_constant_GEN_EDIT_STATE_MAIN_INHERITED"></a>

<!-- classref-enumeration-constant -->

[GenEditState](PackedScene.md#enum_PackedScene_GenEditState) **GEN_EDIT_STATE_MAIN_INHERITED** = `3`

It's similar to [GEN_EDIT_STATE_MAIN](PackedScene.md#PackedScene_constant_GEN_EDIT_STATE_MAIN), but for the case where the scene is being instantiated to be the base of another one.

\ **Note:** Only available in editor builds.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="PackedScene_method_can_instantiate"></a>

<!-- classref-method -->

[bool](bool.md) **can_instantiate**\ (\ ) <span class="const">const</span> [ðŸ”—](#PackedScene_method_can_instantiate)

Returns ``true`` if the scene file has nodes.

<hr class="classref-item-separator"/>

<a id="PackedScene_method_get_state"></a>

<!-- classref-method -->

[SceneState](SceneState.md) **get_state**\ (\ ) <span class="const">const</span> [ðŸ”—](#PackedScene_method_get_state)

Returns the [SceneState](SceneState.md) representing the scene file contents.

<hr class="classref-item-separator"/>

<a id="PackedScene_method_instantiate"></a>

<!-- classref-method -->

[Node](Node.md) **instantiate**\ (\ edit_state\: [GenEditState](PackedScene.md#enum_PackedScene_GenEditState) = 0\ ) <span class="const">const</span> [ðŸ”—](#PackedScene_method_instantiate)

Instantiates the scene's node hierarchy. Triggers child scene instantiation(s). Triggers a [Node.NOTIFICATION_SCENE_INSTANTIATED](Node.md#Node_constant_NOTIFICATION_SCENE_INSTANTIATED) notification on the root node.

<hr class="classref-item-separator"/>

<a id="PackedScene_method_pack"></a>

<!-- classref-method -->

[Error](@GlobalScope.md#enum_@GlobalScope_Error) **pack**\ (\ path\: [Node](Node.md)\ ) [ðŸ”—](#PackedScene_method_pack)

Packs the `path` node, and all owned sub-nodes, into this **PackedScene**. Any existing data will be cleared. See [Node.owner](Node.md#Node_property_owner).

