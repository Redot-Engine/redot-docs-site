<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/UDPServer.xml. -->

<a id="UDPServer"></a>

# UDPServer

**Inherits:** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

Helper class to implement a UDP server.

<!-- classref-introduction-group -->

## Description

A simple server that opens a UDP socket and returns connected [PacketPeerUDP](PacketPeerUDP.md) upon receiving new packets. See also [PacketPeerUDP.connect_to_host()](PacketPeerUDP.md#PacketPeerUDP_method_connect_to_host).

After starting the server ([listen()](UDPServer.md#UDPServer_method_listen)), you will need to [poll()](UDPServer.md#UDPServer_method_poll) it at regular intervals (e.g. inside [Node._process()](Node.md#Node_private_method__process)) for it to process new packets, delivering them to the appropriate [PacketPeerUDP](PacketPeerUDP.md), and taking new connections.

Below a small example of how it can be used:




```gdscript
    # server_node.gd
    class_name ServerNode
    extends Node

    var server = UDPServer.new()
    var peers = []

    func _ready():
        server.listen(4242)

    func _process(delta):
        server.poll() # Important!
        if server.is_connection_available():
            var peer = server.take_connection()
            var packet = peer.get_packet()
            print("Accepted peer: %s:%s" % [peer.get_packet_ip(), peer.get_packet_port()])
            print("Received data: %s" % [packet.get_string_from_utf8()])
            # Reply so it knows we received the message.
            peer.put_packet(packet)
            # Keep a reference so we can keep contacting the remote peer.
            peers.append(peer)

        for i in range(0, peers.size()):
            pass # Do something with the connected peers.
```


```csharp
    // ServerNode.cs
    using Godot;
    using System.Collections.Generic;

    public partial class ServerNode : Node
    {
        private UdpServer _server = new UdpServer();
        private List<PacketPeerUdp> _peers  = new List<PacketPeerUdp>();

        public override void _Ready()
        {
            _server.Listen(4242);
        }

        public override void _Process(double delta)
        {
            _server.Poll(); // Important!
            if (_server.IsConnectionAvailable())
            {
                PacketPeerUdp peer = _server.TakeConnection();
                byte[] packet = peer.GetPacket();
                GD.Print($"Accepted Peer: {peer.GetPacketIP()}:{peer.GetPacketPort()}");
                GD.Print($"Received Data: {packet.GetStringFromUtf8()}");
                // Reply so it knows we received the message.
                peer.PutPacket(packet);
                // Keep a reference so we can keep contacting the remote peer.
                _peers.Add(peer);
            }
            foreach (var peer in _peers)
            {
                // Do something with the peers.
            }
        }
    }
```







```gdscript
    # client_node.gd
    class_name ClientNode
    extends Node

    var udp = PacketPeerUDP.new()
    var connected = false

    func _ready():
        udp.connect_to_host("127.0.0.1", 4242)

    func _process(delta):
        if !connected:
            # Try to contact server
            udp.put_packet("The answer is... 42!".to_utf8_buffer())
        if udp.get_available_packet_count() > 0:
            print("Connected: %s" % udp.get_packet().get_string_from_utf8())
            connected = true
```


```csharp
    // ClientNode.cs
    using Godot;

    public partial class ClientNode : Node
    {
        private PacketPeerUdp _udp = new PacketPeerUdp();
        private bool _connected = false;

        public override void _Ready()
        {
            _udp.ConnectToHost("127.0.0.1", 4242);
        }

        public override void _Process(double delta)
        {
            if (!_connected)
            {
                // Try to contact server
                _udp.PutPacket("The Answer Is..42!".ToUtf8Buffer());
            }
            if (_udp.GetAvailablePacketCount() > 0)
            {
                GD.Print($"Connected: {_udp.GetPacket().GetStringFromUtf8()}");
                _connected = true;
            }
        }
    }
```




<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[int](int.md)</th>
      <th>[max_pending_connections](#UDPServer_property_max_pending_connections)</th>
      <th>`16`</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[int](int.md)</th>
      <th>[get_local_port](#UDPServer_method_get_local_port)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_connection_available](#UDPServer_method_is_connection_available)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_listening](#UDPServer_method_is_listening)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Error](@GlobalScope.md#enum_@GlobalScope_Error)</td>
      <td>[listen](#UDPServer_method_listen)\ (\ port\: [int](int.md), bind_address\: [String](String.md) = "*"\ )</td>
    </tr>
    <tr>
      <td>[Error](@GlobalScope.md#enum_@GlobalScope_Error)</td>
      <td>[poll](#UDPServer_method_poll)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[stop](#UDPServer_method_stop)\ (\ )</td>
    </tr>
    <tr>
      <td>[PacketPeerUDP](PacketPeerUDP.md)</td>
      <td>[take_connection](#UDPServer_method_take_connection)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="UDPServer_property_max_pending_connections"></a>

<!-- classref-property -->

[int](int.md) **max_pending_connections** = `16` [ðŸ”—](#UDPServer_property_max_pending_connections)

<!-- classref-property-setget -->

- `void` **set_max_pending_connections**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_max_pending_connections**\ (\ )

Define the maximum number of pending connections, during [poll()](UDPServer.md#UDPServer_method_poll), any new pending connection exceeding that value will be automatically dropped. Setting this value to ``0`` effectively prevents any new pending connection to be accepted (e.g. when all your players have connected).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="UDPServer_method_get_local_port"></a>

<!-- classref-method -->

[int](int.md) **get_local_port**\ (\ ) <span class="const">const</span> [ðŸ”—](#UDPServer_method_get_local_port)

Returns the local port this server is listening to.

<hr class="classref-item-separator"/>

<a id="UDPServer_method_is_connection_available"></a>

<!-- classref-method -->

[bool](bool.md) **is_connection_available**\ (\ ) <span class="const">const</span> [ðŸ”—](#UDPServer_method_is_connection_available)

Returns ``true`` if a packet with a new address/port combination was received on the socket.

<hr class="classref-item-separator"/>

<a id="UDPServer_method_is_listening"></a>

<!-- classref-method -->

[bool](bool.md) **is_listening**\ (\ ) <span class="const">const</span> [ðŸ”—](#UDPServer_method_is_listening)

Returns ``true`` if the socket is open and listening on a port.

<hr class="classref-item-separator"/>

<a id="UDPServer_method_listen"></a>

<!-- classref-method -->

[Error](@GlobalScope.md#enum_@GlobalScope_Error) **listen**\ (\ port\: [int](int.md), bind_address\: [String](String.md) = "*"\ ) [ðŸ”—](#UDPServer_method_listen)

Starts the server by opening a UDP socket listening on the given `port`. You can optionally specify a `bind_address` to only listen for packets sent to that address. See also [PacketPeerUDP.bind()](PacketPeerUDP.md#PacketPeerUDP_method_bind).

<hr class="classref-item-separator"/>

<a id="UDPServer_method_poll"></a>

<!-- classref-method -->

[Error](@GlobalScope.md#enum_@GlobalScope_Error) **poll**\ (\ ) [ðŸ”—](#UDPServer_method_poll)

Call this method at regular intervals (e.g. inside [Node._process()](Node.md#Node_private_method__process)) to process new packets. Any packet from a known address/port pair will be delivered to the appropriate [PacketPeerUDP](PacketPeerUDP.md), while any packet received from an unknown address/port pair will be added as a pending connection (see [is_connection_available()](UDPServer.md#UDPServer_method_is_connection_available) and [take_connection()](UDPServer.md#UDPServer_method_take_connection)). The maximum number of pending connections is defined via [max_pending_connections](UDPServer.md#UDPServer_property_max_pending_connections).

<hr class="classref-item-separator"/>

<a id="UDPServer_method_stop"></a>

<!-- classref-method -->

`void` **stop**\ (\ ) [ðŸ”—](#UDPServer_method_stop)

Stops the server, closing the UDP socket if open. Will close all connected [PacketPeerUDP](PacketPeerUDP.md) accepted via [take_connection()](UDPServer.md#UDPServer_method_take_connection) (remote peers will not be notified).

<hr class="classref-item-separator"/>

<a id="UDPServer_method_take_connection"></a>

<!-- classref-method -->

[PacketPeerUDP](PacketPeerUDP.md) **take_connection**\ (\ ) [ðŸ”—](#UDPServer_method_take_connection)

Returns the first pending connection (connected to the appropriate address/port). Will return ``null`` if no new connection is available. See also [is_connection_available()](UDPServer.md#UDPServer_method_is_connection_available), [PacketPeerUDP.connect_to_host()](PacketPeerUDP.md#PacketPeerUDP_method_connect_to_host).

