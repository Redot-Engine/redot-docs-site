<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Rect2.xml. -->

<a id="class_Rect2"></a>

# Rect2

A 2D axis-aligned bounding box using floating-point coordinates.

<!-- classref-introduction-group -->

## Description

The **Rect2** built-in [Variant](class_variant.md) type represents an axis-aligned rectangle in a 2D space. It is defined by its [position](class_rect2.md#class_Rect2_property_position) and [size](class_rect2.md#class_Rect2_property_size), which are [Vector2](class_vector2.md). It is frequently used for fast overlap tests (see [intersects()](class_rect2.md#class_Rect2_method_intersects)). Although **Rect2** itself is axis-aligned, it can be combined with [Transform2D](class_transform2d.md) to represent a rotated or skewed rectangle.

For integer coordinates, use [Rect2i](class_rect2i.md). The 3D equivalent to **Rect2** is [AABB](class_aabb.md).

\ **Note:** Negative values for [size](class_rect2.md#class_Rect2_property_size) are not supported. With negative size, most **Rect2** methods do not work correctly. Use [abs()](class_rect2.md#class_Rect2_method_abs) to get an equivalent **Rect2** with a non-negative size.

\ **Note:** In a boolean context, a **Rect2** evaluates to ``false`` if both [position](class_rect2.md#class_Rect2_property_position) and [size](class_rect2.md#class_Rect2_property_size) are zero (equal to [Vector2.ZERO](class_vector2.md#class_Vector2_constant_ZERO)). Otherwise, it always evaluates to ``true``.

<div class="note">
There are notable differences when using this API with C#. See the C# differences documentation for more information.

</div>

<!-- classref-introduction-group -->

## Tutorials

- [Math documentation index](../tutorials/math/index.md)

- [Vector math](../tutorials/math/vector_math.md)

- [Advanced vector math](../tutorials/math/vectors_advanced.md)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[Vector2](class_vector2.md)</th>
      <th>[end](#class_Rect2_property_end)</th>
      <th>`Vector2(0, 0)`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[position](#class_Rect2_property_position)</td>
      <td>`Vector2(0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[size](#class_Rect2_property_size)</td>
      <td>`Vector2(0, 0)`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Constructors

<table>
  <thead>
    <tr>
      <th>[Rect2](class_rect2.md)</th>
      <th>[Rect2](#class_Rect2_constructor_Rect2)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[Rect2](#class_Rect2_constructor_Rect2)\ (\ from\: [Rect2](class_rect2.md)\ )</td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[Rect2](#class_Rect2_constructor_Rect2)\ (\ from\: [Rect2i](class_rect2i.md)\ )</td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[Rect2](#class_Rect2_constructor_Rect2)\ (\ position\: [Vector2](class_vector2.md), size\: [Vector2](class_vector2.md)\ )</td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[Rect2](#class_Rect2_constructor_Rect2)\ (\ x\: [float](class_float.md), y\: [float](class_float.md), width\: [float](class_float.md), height\: [float](class_float.md)\ )</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Rect2](class_rect2.md)</th>
      <th>[abs](#class_Rect2_method_abs)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[encloses](#class_Rect2_method_encloses)\ (\ b\: [Rect2](class_rect2.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[expand](#class_Rect2_method_expand)\ (\ to\: [Vector2](class_vector2.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_area](#class_Rect2_method_get_area)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[get_center](#class_Rect2_method_get_center)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[get_support](#class_Rect2_method_get_support)\ (\ direction\: [Vector2](class_vector2.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[grow](#class_Rect2_method_grow)\ (\ amount\: [float](class_float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[grow_individual](#class_Rect2_method_grow_individual)\ (\ left\: [float](class_float.md), top\: [float](class_float.md), right\: [float](class_float.md), bottom\: [float](class_float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[grow_side](#class_Rect2_method_grow_side)\ (\ side\: [int](class_int.md), amount\: [float](class_float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[has_area](#class_Rect2_method_has_area)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[has_point](#class_Rect2_method_has_point)\ (\ point\: [Vector2](class_vector2.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[intersection](#class_Rect2_method_intersection)\ (\ b\: [Rect2](class_rect2.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[intersects](#class_Rect2_method_intersects)\ (\ b\: [Rect2](class_rect2.md), include_borders\: [bool](class_bool.md) = false\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_equal_approx](#class_Rect2_method_is_equal_approx)\ (\ rect\: [Rect2](class_rect2.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_finite](#class_Rect2_method_is_finite)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[merge](#class_Rect2_method_merge)\ (\ b\: [Rect2](class_rect2.md)\ ) <span class="const">const</span></td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Operators

<table>
  <thead>
    <tr>
      <th>[bool](class_bool.md)</th>
      <th>[operator !=](#class_Rect2_operator_neq_Rect2)\ (\ right\: [Rect2](class_rect2.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[operator *](#class_Rect2_operator_mul_Transform2D)\ (\ right\: [Transform2D](class_transform2d.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[operator ==](#class_Rect2_operator_eq_Rect2)\ (\ right\: [Rect2](class_rect2.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_Rect2_property_end"></a>

<!-- classref-property -->

[Vector2](class_vector2.md) **end** = `Vector2(0, 0)` [ðŸ”—](#class_Rect2_property_end)

The ending point. This is usually the bottom-right corner of the rectangle, and is equivalent to ``position + size``. Setting this point affects the [size](class_rect2.md#class_Rect2_property_size).

<hr class="classref-item-separator">

<a id="class_Rect2_property_position"></a>

<!-- classref-property -->

[Vector2](class_vector2.md) **position** = `Vector2(0, 0)` [ðŸ”—](#class_Rect2_property_position)

The origin point. This is usually the top-left corner of the rectangle.

<hr class="classref-item-separator">

<a id="class_Rect2_property_size"></a>

<!-- classref-property -->

[Vector2](class_vector2.md) **size** = `Vector2(0, 0)` [ðŸ”—](#class_Rect2_property_size)

The rectangle's width and height, starting from [position](class_rect2.md#class_Rect2_property_position). Setting this value also affects the [end](class_rect2.md#class_Rect2_property_end) point.

\ **Note:** It's recommended setting the width and height to non-negative values, as most methods in Redot assume that the [position](class_rect2.md#class_Rect2_property_position) is the top-left corner, and the [end](class_rect2.md#class_Rect2_property_end) is the bottom-right corner. To get an equivalent rectangle with non-negative size, use [abs()](class_rect2.md#class_Rect2_method_abs).

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Constructor Descriptions

<a id="class_Rect2_constructor_Rect2"></a>

<!-- classref-constructor -->

[Rect2](class_rect2.md) **Rect2**\ (\ ) [ðŸ”—](#class_Rect2_constructor_Rect2)

Constructs a **Rect2** with its [position](class_rect2.md#class_Rect2_property_position) and [size](class_rect2.md#class_Rect2_property_size) set to [Vector2.ZERO](class_vector2.md#class_Vector2_constant_ZERO).

<hr class="classref-item-separator">

<!-- classref-constructor -->

[Rect2](class_rect2.md) **Rect2**\ (\ from\: [Rect2](class_rect2.md)\ )

Constructs a **Rect2** as a copy of the given **Rect2**.

<hr class="classref-item-separator">

<!-- classref-constructor -->

[Rect2](class_rect2.md) **Rect2**\ (\ from\: [Rect2i](class_rect2i.md)\ )

Constructs a **Rect2** from a [Rect2i](class_rect2i.md).

<hr class="classref-item-separator">

<!-- classref-constructor -->

[Rect2](class_rect2.md) **Rect2**\ (\ position\: [Vector2](class_vector2.md), size\: [Vector2](class_vector2.md)\ )

Constructs a **Rect2** by `position` and `size`.

<hr class="classref-item-separator">

<!-- classref-constructor -->

[Rect2](class_rect2.md) **Rect2**\ (\ x\: [float](class_float.md), y\: [float](class_float.md), width\: [float](class_float.md), height\: [float](class_float.md)\ )

Constructs a **Rect2** by setting its [position](class_rect2.md#class_Rect2_property_position) to (`x`, `y`), and its [size](class_rect2.md#class_Rect2_property_size) to (`width`, `height`).

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_Rect2_method_abs"></a>

<!-- classref-method -->

[Rect2](class_rect2.md) **abs**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_abs)

Returns a **Rect2** equivalent to this rectangle, with its width and height modified to be non-negative values, and with its [position](class_rect2.md#class_Rect2_property_position) being the top-left corner of the rectangle.




```gdscript
    var rect = Rect2(25, 25, -100, -50)
    var absolute = rect.abs() # absolute is Rect2(-75, -25, 100, 50)
```

```csharp
    var rect = new Rect2(25, 25, -100, -50);
    var absolute = rect.Abs(); // absolute is Rect2(-75, -25, 100, 50)
```



\ **Note:** It's recommended to use this method when [size](class_rect2.md#class_Rect2_property_size) is negative, as most other methods in Redot assume that the [position](class_rect2.md#class_Rect2_property_position) is the top-left corner, and the [end](class_rect2.md#class_Rect2_property_end) is the bottom-right corner.

<hr class="classref-item-separator">

<a id="class_Rect2_method_encloses"></a>

<!-- classref-method -->

[bool](class_bool.md) **encloses**\ (\ b\: [Rect2](class_rect2.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_encloses)

Returns ``true`` if this rectangle *completely* encloses the `b` rectangle.

<hr class="classref-item-separator">

<a id="class_Rect2_method_expand"></a>

<!-- classref-method -->

[Rect2](class_rect2.md) **expand**\ (\ to\: [Vector2](class_vector2.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_expand)

Returns a copy of this rectangle expanded to align the edges with the given `to` point, if necessary.




```gdscript
    var rect = Rect2(0, 0, 5, 2)

    rect = rect.expand(Vector2(10, 0)) # rect is Rect2(0, 0, 10, 2)
    rect = rect.expand(Vector2(-5, 5)) # rect is Rect2(-5, 0, 15, 5)
```

```csharp
    var rect = new Rect2(0, 0, 5, 2);

    rect = rect.Expand(new Vector2(10, 0)); // rect is Rect2(0, 0, 10, 2)
    rect = rect.Expand(new Vector2(-5, 5)); // rect is Rect2(-5, 0, 15, 5)
```



<hr class="classref-item-separator">

<a id="class_Rect2_method_get_area"></a>

<!-- classref-method -->

[float](class_float.md) **get_area**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_get_area)

Returns the rectangle's area. This is equivalent to ``size.x * size.y``. See also [has_area()](class_rect2.md#class_Rect2_method_has_area).

<hr class="classref-item-separator">

<a id="class_Rect2_method_get_center"></a>

<!-- classref-method -->

[Vector2](class_vector2.md) **get_center**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_get_center)

Returns the center point of the rectangle. This is the same as ``position + (size / 2.0)``.

<hr class="classref-item-separator">

<a id="class_Rect2_method_get_support"></a>

<!-- classref-method -->

[Vector2](class_vector2.md) **get_support**\ (\ direction\: [Vector2](class_vector2.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_get_support)

Returns the vertex's position of this rect that's the farthest in the given direction. This point is commonly known as the support point in collision detection algorithms.

<hr class="classref-item-separator">

<a id="class_Rect2_method_grow"></a>

<!-- classref-method -->

[Rect2](class_rect2.md) **grow**\ (\ amount\: [float](class_float.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_grow)

Returns a copy of this rectangle extended on all sides by the given `amount`. A negative `amount` shrinks the rectangle instead. See also [grow_individual()](class_rect2.md#class_Rect2_method_grow_individual) and [grow_side()](class_rect2.md#class_Rect2_method_grow_side).




```gdscript
    var a = Rect2(4, 4, 8, 8).grow(4) # a is Rect2(0, 0, 16, 16)
    var b = Rect2(0, 0, 8, 4).grow(2) # b is Rect2(-2, -2, 12, 8)
```

```csharp
    var a = new Rect2(4, 4, 8, 8).Grow(4); // a is Rect2(0, 0, 16, 16)
    var b = new Rect2(0, 0, 8, 4).Grow(2); // b is Rect2(-2, -2, 12, 8)
```



<hr class="classref-item-separator">

<a id="class_Rect2_method_grow_individual"></a>

<!-- classref-method -->

[Rect2](class_rect2.md) **grow_individual**\ (\ left\: [float](class_float.md), top\: [float](class_float.md), right\: [float](class_float.md), bottom\: [float](class_float.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_grow_individual)

Returns a copy of this rectangle with its `left`, `top`, `right`, and `bottom` sides extended by the given amounts. Negative values shrink the sides, instead. See also [grow()](class_rect2.md#class_Rect2_method_grow) and [grow_side()](class_rect2.md#class_Rect2_method_grow_side).

<hr class="classref-item-separator">

<a id="class_Rect2_method_grow_side"></a>

<!-- classref-method -->

[Rect2](class_rect2.md) **grow_side**\ (\ side\: [int](class_int.md), amount\: [float](class_float.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_grow_side)

Returns a copy of this rectangle with its `side` extended by the given `amount` (see [Side](class_@globalscope.md#enum_@GlobalScope_Side) constants). A negative `amount` shrinks the rectangle, instead. See also [grow()](class_rect2.md#class_Rect2_method_grow) and [grow_individual()](class_rect2.md#class_Rect2_method_grow_individual).

<hr class="classref-item-separator">

<a id="class_Rect2_method_has_area"></a>

<!-- classref-method -->

[bool](class_bool.md) **has_area**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_has_area)

Returns ``true`` if this rectangle has positive width and height. See also [get_area()](class_rect2.md#class_Rect2_method_get_area).

<hr class="classref-item-separator">

<a id="class_Rect2_method_has_point"></a>

<!-- classref-method -->

[bool](class_bool.md) **has_point**\ (\ point\: [Vector2](class_vector2.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_has_point)

Returns ``true`` if the rectangle contains the given `point`. By convention, points on the right and bottom edges are **not** included.

\ **Note:** This method is not reliable for **Rect2** with a *negative* [size](class_rect2.md#class_Rect2_property_size). Use [abs()](class_rect2.md#class_Rect2_method_abs) first to get a valid rectangle.

<hr class="classref-item-separator">

<a id="class_Rect2_method_intersection"></a>

<!-- classref-method -->

[Rect2](class_rect2.md) **intersection**\ (\ b\: [Rect2](class_rect2.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_intersection)

Returns the intersection between this rectangle and `b`. If the rectangles do not intersect, returns an empty **Rect2**.




```gdscript
    var rect1 = Rect2(0, 0, 5, 10)
    var rect2 = Rect2(2, 0, 8, 4)

    var a = rect1.intersection(rect2) # a is Rect2(2, 0, 3, 4)
```

```csharp
    var rect1 = new Rect2(0, 0, 5, 10);
    var rect2 = new Rect2(2, 0, 8, 4);

    var a = rect1.Intersection(rect2); // a is Rect2(2, 0, 3, 4)
```



\ **Note:** If you only need to know whether two rectangles are overlapping, use [intersects()](class_rect2.md#class_Rect2_method_intersects), instead.

<hr class="classref-item-separator">

<a id="class_Rect2_method_intersects"></a>

<!-- classref-method -->

[bool](class_bool.md) **intersects**\ (\ b\: [Rect2](class_rect2.md), include_borders\: [bool](class_bool.md) = false\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_intersects)

Returns ``true`` if this rectangle overlaps with the `b` rectangle. The edges of both rectangles are excluded, unless `include_borders` is ``true``.

<hr class="classref-item-separator">

<a id="class_Rect2_method_is_equal_approx"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_equal_approx**\ (\ rect\: [Rect2](class_rect2.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_is_equal_approx)

Returns ``true`` if this rectangle and `rect` are approximately equal, by calling [Vector2.is_equal_approx()](class_vector2.md#class_Vector2_method_is_equal_approx) on the [position](class_rect2.md#class_Rect2_property_position) and the [size](class_rect2.md#class_Rect2_property_size).

<hr class="classref-item-separator">

<a id="class_Rect2_method_is_finite"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_finite**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_is_finite)

Returns ``true`` if this rectangle's values are finite, by calling [Vector2.is_finite()](class_vector2.md#class_Vector2_method_is_finite) on the [position](class_rect2.md#class_Rect2_property_position) and the [size](class_rect2.md#class_Rect2_property_size).

<hr class="classref-item-separator">

<a id="class_Rect2_method_merge"></a>

<!-- classref-method -->

[Rect2](class_rect2.md) **merge**\ (\ b\: [Rect2](class_rect2.md)\ ) <span class="const">const</span> [ðŸ”—](#class_Rect2_method_merge)

Returns a **Rect2** that encloses both this rectangle and `b` around the edges. See also [encloses()](class_rect2.md#class_Rect2_method_encloses).

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Operator Descriptions

<a id="class_Rect2_operator_neq_Rect2"></a>

<!-- classref-operator -->

[bool](class_bool.md) **operator !=**\ (\ right\: [Rect2](class_rect2.md)\ ) [ðŸ”—](#class_Rect2_operator_neq_Rect2)

Returns ``true`` if the [position](class_rect2.md#class_Rect2_property_position) or [size](class_rect2.md#class_Rect2_property_size) of both rectangles are not equal.

\ **Note:** Due to floating-point precision errors, consider using [is_equal_approx()](class_rect2.md#class_Rect2_method_is_equal_approx) instead, which is more reliable.

<hr class="classref-item-separator">

<a id="class_Rect2_operator_mul_Transform2D"></a>

<!-- classref-operator -->

[Rect2](class_rect2.md) **operator ***\ (\ right\: [Transform2D](class_transform2d.md)\ ) [ðŸ”—](#class_Rect2_operator_mul_Transform2D)

Inversely transforms (multiplies) the **Rect2** by the given [Transform2D](class_transform2d.md) transformation matrix, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).

\ ``rect * transform`` is equivalent to ``transform.inverse() * rect``. See [Transform2D.inverse()](class_transform2d.md#class_Transform2D_method_inverse).

For transforming by inverse of an affine transformation (e.g. with scaling) ``transform.affine_inverse() * rect`` can be used instead. See [Transform2D.affine_inverse()](class_transform2d.md#class_Transform2D_method_affine_inverse).

<hr class="classref-item-separator">

<a id="class_Rect2_operator_eq_Rect2"></a>

<!-- classref-operator -->

[bool](class_bool.md) **operator ==**\ (\ right\: [Rect2](class_rect2.md)\ ) [ðŸ”—](#class_Rect2_operator_eq_Rect2)

Returns ``true`` if both [position](class_rect2.md#class_Rect2_property_position) and [size](class_rect2.md#class_Rect2_property_size) of the rectangles are exactly equal, respectively.

\ **Note:** Due to floating-point precision errors, consider using [is_equal_approx()](class_rect2.md#class_Rect2_method_is_equal_approx) instead, which is more reliable.

