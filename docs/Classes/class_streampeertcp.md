<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/StreamPeerTCP.xml. -->

<a id="class_StreamPeerTCP"></a>

# StreamPeerTCP

**Inherits:** [StreamPeer](class_streampeer.md) **<** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

A stream peer that handles TCP connections.

<!-- classref-introduction-group -->

## Description

A stream peer that handles TCP connections. This object can be used to connect to TCP servers, or also is returned by a TCP server.

\ **Note:** When exporting to Android, make sure to enable the ``INTERNET`` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</th>
      <th>[bind](#class_StreamPeerTCP_method_bind)\ (\ port\: [int](class_int.md), host\: [String](class_string.md) = "*"\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[connect_to_host](#class_StreamPeerTCP_method_connect_to_host)\ (\ host\: [String](class_string.md), port\: [int](class_int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[disconnect_from_host](#class_StreamPeerTCP_method_disconnect_from_host)\ (\ )</td>
    </tr>
    <tr>
      <td>[String](class_string.md)</td>
      <td>[get_connected_host](#class_StreamPeerTCP_method_get_connected_host)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[get_connected_port](#class_StreamPeerTCP_method_get_connected_port)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[get_local_port](#class_StreamPeerTCP_method_get_local_port)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Status](class_streampeertcp.md#enum_StreamPeerTCP_Status)</td>
      <td>[get_status](#class_StreamPeerTCP_method_get_status)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[poll](#class_StreamPeerTCP_method_poll)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_no_delay](#class_StreamPeerTCP_method_set_no_delay)\ (\ enabled\: [bool](class_bool.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_StreamPeerTCP_Status"></a>

<!-- classref-enumeration -->

enum **Status**: [ðŸ”—](#enum_StreamPeerTCP_Status)

<a id="class_StreamPeerTCP_constant_STATUS_NONE"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertcp.md#enum_StreamPeerTCP_Status) **STATUS_NONE** = `0`

The initial status of the **StreamPeerTCP**. This is also the status after disconnecting.<a id="class_StreamPeerTCP_constant_STATUS_CONNECTING"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertcp.md#enum_StreamPeerTCP_Status) **STATUS_CONNECTING** = `1`

A status representing a **StreamPeerTCP** that is connecting to a host.<a id="class_StreamPeerTCP_constant_STATUS_CONNECTED"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertcp.md#enum_StreamPeerTCP_Status) **STATUS_CONNECTED** = `2`

A status representing a **StreamPeerTCP** that is connected to a host.<a id="class_StreamPeerTCP_constant_STATUS_ERROR"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertcp.md#enum_StreamPeerTCP_Status) **STATUS_ERROR** = `3`

A status representing a **StreamPeerTCP** in error state.<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_StreamPeerTCP_method_bind"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **bind**\ (\ port\: [int](class_int.md), host\: [String](class_string.md) = "*"\ ) [ðŸ”—](#class_StreamPeerTCP_method_bind)

Opens the TCP socket, and binds it to the specified local address.

This method is generally not needed, and only used to force the subsequent call to [connect_to_host()](class_streampeertcp.md#class_StreamPeerTCP_method_connect_to_host) to use the specified `host` and `port` as source address. This can be desired in some NAT punchthrough techniques, or when forcing the source network interface.

<hr class="classref-item-separator">

<a id="class_StreamPeerTCP_method_connect_to_host"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **connect_to_host**\ (\ host\: [String](class_string.md), port\: [int](class_int.md)\ ) [ðŸ”—](#class_StreamPeerTCP_method_connect_to_host)

Connects to the specified ``host:port`` pair. A hostname will be resolved if valid. Returns [@GlobalScope.OK](class_@globalscope.md#class_@GlobalScope_constant_OK) on success.

<hr class="classref-item-separator">

<a id="class_StreamPeerTCP_method_disconnect_from_host"></a>

<!-- classref-method -->

`void` **disconnect_from_host**\ (\ ) [ðŸ”—](#class_StreamPeerTCP_method_disconnect_from_host)

Disconnects from host.

<hr class="classref-item-separator">

<a id="class_StreamPeerTCP_method_get_connected_host"></a>

<!-- classref-method -->

[String](class_string.md) **get_connected_host**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_StreamPeerTCP_method_get_connected_host)

Returns the IP of this peer.

<hr class="classref-item-separator">

<a id="class_StreamPeerTCP_method_get_connected_port"></a>

<!-- classref-method -->

[int](class_int.md) **get_connected_port**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_StreamPeerTCP_method_get_connected_port)

Returns the port of this peer.

<hr class="classref-item-separator">

<a id="class_StreamPeerTCP_method_get_local_port"></a>

<!-- classref-method -->

[int](class_int.md) **get_local_port**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_StreamPeerTCP_method_get_local_port)

Returns the local port to which this peer is bound.

<hr class="classref-item-separator">

<a id="class_StreamPeerTCP_method_get_status"></a>

<!-- classref-method -->

[Status](class_streampeertcp.md#enum_StreamPeerTCP_Status) **get_status**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_StreamPeerTCP_method_get_status)

Returns the status of the connection.

<hr class="classref-item-separator">

<a id="class_StreamPeerTCP_method_poll"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **poll**\ (\ ) [ðŸ”—](#class_StreamPeerTCP_method_poll)

Poll the socket, updating its state. See [get_status()](class_streampeertcp.md#class_StreamPeerTCP_method_get_status).

<hr class="classref-item-separator">

<a id="class_StreamPeerTCP_method_set_no_delay"></a>

<!-- classref-method -->

`void` **set_no_delay**\ (\ enabled\: [bool](class_bool.md)\ ) [ðŸ”—](#class_StreamPeerTCP_method_set_no_delay)

If `enabled` is ``true``, packets will be sent immediately. If `enabled` is ``false`` (the default), packet transfers will be delayed and combined using [Nagle's algorithm](https://en.wikipedia.org/wiki/Nagle%27s_algorithm).

\ **Note:** It's recommended to leave this disabled for applications that send large packets or need to transfer a lot of data, as enabling this can decrease the total available bandwidth.

