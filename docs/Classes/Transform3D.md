<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Transform3D.xml. -->

<a id="Transform3D"></a>

# Transform3D

A 3Ã—4 matrix representing a 3D transformation.

<!-- classref-introduction-group -->

## Description

The **Transform3D** built-in [Variant](Variant.md) type is a 3Ã—4 matrix representing a transformation in 3D space. It contains a [Basis](Basis.md), which on its own can represent rotation, scale, and shear. Additionally, combined with its own [origin](Transform3D.md#Transform3D_property_origin), the transform can also represent a translation.

For a general introduction, see the [Matrices and transforms](../tutorials/math/matrices_and_transforms.md) tutorial.

\ **Note:** Redot uses a [right-handed coordinate system](https://en.wikipedia.org/wiki/Right-hand_rule), which is a common standard. For directions, the convention for built-in types like [Camera3D](Camera3D.md) is for -Z to point forward (+X is right, +Y is up, and +Z is back). Other objects may use different direction conventions. For more information, see the [3D asset direction conventions](../tutorials/assets_pipeline/importing_3d_scenes/model_export_considerations.md#d-asset-direction-conventions) tutorial.

<div class="note">
There are notable differences when using this API with C#. See the C# differences documentation for more information.

</div>

<!-- classref-introduction-group -->

## Tutorials

- [Math documentation index](../tutorials/math/index.md)

- [Matrices and transforms](../tutorials/math/matrices_and_transforms.md)

- [Using 3D transforms](../tutorials/3d/using_transforms.md)

- [Matrix Transform Demo](https://godotengine.org/asset-library/asset/2787)

- [3D Platformer Demo](https://godotengine.org/asset-library/asset/2748)

- [2.5D Game Demo](https://godotengine.org/asset-library/asset/2783)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[Basis](Basis.md)</th>
      <th>[basis](#Transform3D_property_basis)</th>
      <th>`Basis(1, 0, 0, 0, 1, 0, 0, 0, 1)`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[origin](#Transform3D_property_origin)</td>
      <td>`Vector3(0, 0, 0)`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Constructors

<table>
  <thead>
    <tr>
      <th>[Transform3D](Transform3D.md)</th>
      <th>[Transform3D](#Transform3D_constructor_Transform3D)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[Transform3D](#Transform3D_constructor_Transform3D)\ (\ from\: [Transform3D](Transform3D.md)\ )</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[Transform3D](#Transform3D_constructor_Transform3D)\ (\ basis\: [Basis](Basis.md), origin\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[Transform3D](#Transform3D_constructor_Transform3D)\ (\ from\: [Projection](Projection.md)\ )</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[Transform3D](#Transform3D_constructor_Transform3D)\ (\ x_axis\: [Vector3](Vector3.md), y_axis\: [Vector3](Vector3.md), z_axis\: [Vector3](Vector3.md), origin\: [Vector3](Vector3.md)\ )</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Transform3D](Transform3D.md)</th>
      <th>[affine_inverse](#Transform3D_method_affine_inverse)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[interpolate_with](#Transform3D_method_interpolate_with)\ (\ xform\: [Transform3D](Transform3D.md), weight\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[inverse](#Transform3D_method_inverse)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_equal_approx](#Transform3D_method_is_equal_approx)\ (\ xform\: [Transform3D](Transform3D.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_finite](#Transform3D_method_is_finite)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[looking_at](#Transform3D_method_looking_at)\ (\ target\: [Vector3](Vector3.md), up\: [Vector3](Vector3.md) = Vector3(0, 1, 0), use_model_front\: [bool](bool.md) = false\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[orthonormalized](#Transform3D_method_orthonormalized)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[rotated](#Transform3D_method_rotated)\ (\ axis\: [Vector3](Vector3.md), angle\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[rotated_local](#Transform3D_method_rotated_local)\ (\ axis\: [Vector3](Vector3.md), angle\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[scaled](#Transform3D_method_scaled)\ (\ scale\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[scaled_local](#Transform3D_method_scaled_local)\ (\ scale\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[translated](#Transform3D_method_translated)\ (\ offset\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[translated_local](#Transform3D_method_translated_local)\ (\ offset\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Operators

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[operator !=](#Transform3D_operator_neq_Transform3D)\ (\ right\: [Transform3D](Transform3D.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[operator *](#Transform3D_operator_mul_AABB)\ (\ right\: [AABB](AABB.md)\ )</td>
    </tr>
    <tr>
      <td>[PackedVector3Array](PackedVector3Array.md)</td>
      <td>[operator *](#Transform3D_operator_mul_PackedVector3Array)\ (\ right\: [PackedVector3Array](PackedVector3Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Plane](Plane.md)</td>
      <td>[operator *](#Transform3D_operator_mul_Plane)\ (\ right\: [Plane](Plane.md)\ )</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[operator *](#Transform3D_operator_mul_Transform3D)\ (\ right\: [Transform3D](Transform3D.md)\ )</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[operator *](#Transform3D_operator_mul_Vector3)\ (\ right\: [Vector3](Vector3.md)\ )</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[operator *](#Transform3D_operator_mul_float)\ (\ right\: [float](float.md)\ )</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[operator *](#Transform3D_operator_mul_int)\ (\ right\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[operator /](#Transform3D_operator_div_float)\ (\ right\: [float](float.md)\ )</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[operator /](#Transform3D_operator_div_int)\ (\ right\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator ==](#Transform3D_operator_eq_Transform3D)\ (\ right\: [Transform3D](Transform3D.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Constants

<a id="Transform3D_constant_IDENTITY"></a>

<!-- classref-constant -->

**IDENTITY** = `Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)` [ðŸ”—](#Transform3D_constant_IDENTITY)

The identity **Transform3D**. This is a transform with no translation, no rotation, and a scale of [Vector3.ONE](Vector3.md#Vector3_constant_ONE). Its [basis](Transform3D.md#Transform3D_property_basis) is equal to [Basis.IDENTITY](Basis.md#Basis_constant_IDENTITY). This also means that:

- Its [Basis.x](Basis.md#Basis_property_x) points right ([Vector3.RIGHT](Vector3.md#Vector3_constant_RIGHT));

- Its [Basis.y](Basis.md#Basis_property_y) points up ([Vector3.UP](Vector3.md#Vector3_constant_UP));

- Its [Basis.z](Basis.md#Basis_property_z) points back ([Vector3.BACK](Vector3.md#Vector3_constant_BACK)).

```
    var transform = Transform3D.IDENTITY
    var basis = transform.basis
    print("| X | Y | Z | Origin")
    print("| %.f | %.f | %.f | %.f" % [basis.x.x, basis.y.x, basis.z.x, transform.origin.x])
    print("| %.f | %.f | %.f | %.f" % [basis.x.y, basis.y.y, basis.z.y, transform.origin.y])
    print("| %.f | %.f | %.f | %.f" % [basis.x.z, basis.y.z, basis.z.z, transform.origin.z])
    # Prints:
    # | X | Y | Z | Origin
    # | 1 | 0 | 0 | 0
    # | 0 | 1 | 0 | 0
    # | 0 | 0 | 1 | 0
```


If a [Vector3](Vector3.md), an [AABB](AABB.md), a [Plane](Plane.md), a [PackedVector3Array](PackedVector3Array.md), or another **Transform3D** is transformed (multiplied) by this constant, no transformation occurs.

\ **Note:** In GDScript, this constant is equivalent to creating a [Transform3D](Transform3D.md#Transform3D_constructor_Transform3D) without any arguments. It can be used to make your code clearer, and for consistency with C#.

<a id="Transform3D_constant_FLIP_X"></a>

<!-- classref-constant -->

**FLIP_X** = `Transform3D(-1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)` [ðŸ”—](#Transform3D_constant_FLIP_X)

**Transform3D** with mirroring applied perpendicular to the YZ plane. Its [basis](Transform3D.md#Transform3D_property_basis) is equal to [Basis.FLIP_X](Basis.md#Basis_constant_FLIP_X).

<a id="Transform3D_constant_FLIP_Y"></a>

<!-- classref-constant -->

**FLIP_Y** = `Transform3D(1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0)` [ðŸ”—](#Transform3D_constant_FLIP_Y)

**Transform3D** with mirroring applied perpendicular to the XZ plane. Its [basis](Transform3D.md#Transform3D_property_basis) is equal to [Basis.FLIP_Y](Basis.md#Basis_constant_FLIP_Y).

<a id="Transform3D_constant_FLIP_Z"></a>

<!-- classref-constant -->

**FLIP_Z** = `Transform3D(1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0)` [ðŸ”—](#Transform3D_constant_FLIP_Z)

**Transform3D** with mirroring applied perpendicular to the XY plane. Its [basis](Transform3D.md#Transform3D_property_basis) is equal to [Basis.FLIP_Z](Basis.md#Basis_constant_FLIP_Z).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="Transform3D_property_basis"></a>

<!-- classref-property -->

[Basis](Basis.md) **basis** = `Basis(1, 0, 0, 0, 1, 0, 0, 0, 1)` [ðŸ”—](#Transform3D_property_basis)

The [Basis](Basis.md) of this transform. It is composed by 3 axes ([Basis.x](Basis.md#Basis_property_x), [Basis.y](Basis.md#Basis_property_y), and [Basis.z](Basis.md#Basis_property_z)). Together, these represent the transform's rotation, scale, and shear.

<hr class="classref-item-separator"/>

<a id="Transform3D_property_origin"></a>

<!-- classref-property -->

[Vector3](Vector3.md) **origin** = `Vector3(0, 0, 0)` [ðŸ”—](#Transform3D_property_origin)

The translation offset of this transform. In 3D space, this can be seen as the position.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Constructor Descriptions

<a id="Transform3D_constructor_Transform3D"></a>

<!-- classref-constructor -->

[Transform3D](Transform3D.md) **Transform3D**\ (\ ) [ðŸ”—](#Transform3D_constructor_Transform3D)

Constructs a **Transform3D** identical to [IDENTITY](Transform3D.md#Transform3D_constant_IDENTITY).

\ **Note:** In C#, this constructs a **Transform3D** with its [origin](Transform3D.md#Transform3D_property_origin) and the components of its [basis](Transform3D.md#Transform3D_property_basis) set to [Vector3.ZERO](Vector3.md#Vector3_constant_ZERO).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Transform3D](Transform3D.md) **Transform3D**\ (\ from\: [Transform3D](Transform3D.md)\ )

Constructs a **Transform3D** as a copy of the given **Transform3D**.

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Transform3D](Transform3D.md) **Transform3D**\ (\ basis\: [Basis](Basis.md), origin\: [Vector3](Vector3.md)\ )

Constructs a **Transform3D** from a [Basis](Basis.md) and [Vector3](Vector3.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Transform3D](Transform3D.md) **Transform3D**\ (\ from\: [Projection](Projection.md)\ )

Constructs a **Transform3D** from a [Projection](Projection.md). Because **Transform3D** is a 3Ã—4 matrix and [Projection](Projection.md) is a 4Ã—4 matrix, this operation trims the last row of the projection matrix (``from.x.w``, ``from.y.w``, ``from.z.w``, and ``from.w.w`` are not included in the new transform).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Transform3D](Transform3D.md) **Transform3D**\ (\ x_axis\: [Vector3](Vector3.md), y_axis\: [Vector3](Vector3.md), z_axis\: [Vector3](Vector3.md), origin\: [Vector3](Vector3.md)\ )

Constructs a **Transform3D** from four [Vector3](Vector3.md) values (also called matrix columns).

The first three arguments are the [basis](Transform3D.md#Transform3D_property_basis)'s axes ([Basis.x](Basis.md#Basis_property_x), [Basis.y](Basis.md#Basis_property_y), and [Basis.z](Basis.md#Basis_property_z)).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Transform3D_method_affine_inverse"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **affine_inverse**\ (\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_affine_inverse)

Returns the inverted version of this transform. Unlike [inverse()](Transform3D.md#Transform3D_method_inverse), this method works with almost any [basis](Transform3D.md#Transform3D_property_basis), including non-uniform ones, but is slower. See also [Basis.inverse()](Basis.md#Basis_method_inverse).

\ **Note:** For this method to return correctly, the transform's [basis](Transform3D.md#Transform3D_property_basis) needs to have a determinant that is not exactly ``0.0`` (see [Basis.determinant()](Basis.md#Basis_method_determinant)).

<hr class="classref-item-separator"/>

<a id="Transform3D_method_interpolate_with"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **interpolate_with**\ (\ xform\: [Transform3D](Transform3D.md), weight\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_interpolate_with)

Returns the result of the linear interpolation between this transform and `xform` by the given `weight`.

The `weight` should be between ``0.0`` and ``1.0`` (inclusive). Values outside this range are allowed and can be used to perform *extrapolation* instead.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_inverse"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **inverse**\ (\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_inverse)

Returns the [inverted version of this transform](https://en.wikipedia.org/wiki/Invertible_matrix). See also [Basis.inverse()](Basis.md#Basis_method_inverse).

\ **Note:** For this method to return correctly, the transform's [basis](Transform3D.md#Transform3D_property_basis) needs to be *orthonormal* (see [orthonormalized()](Transform3D.md#Transform3D_method_orthonormalized)). That means the basis should only represent a rotation. If it does not, use [affine_inverse()](Transform3D.md#Transform3D_method_affine_inverse) instead.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_is_equal_approx"></a>

<!-- classref-method -->

[bool](bool.md) **is_equal_approx**\ (\ xform\: [Transform3D](Transform3D.md)\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_is_equal_approx)

Returns ``true`` if this transform and `xform` are approximately equal, by running [@GlobalScope.is_equal_approx()](@GlobalScope.md#@GlobalScope_method_is_equal_approx) on each component.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_is_finite"></a>

<!-- classref-method -->

[bool](bool.md) **is_finite**\ (\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_is_finite)

Returns ``true`` if this transform is finite, by calling [@GlobalScope.is_finite()](@GlobalScope.md#@GlobalScope_method_is_finite) on each component.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_looking_at"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **looking_at**\ (\ target\: [Vector3](Vector3.md), up\: [Vector3](Vector3.md) = Vector3(0, 1, 0), use_model_front\: [bool](bool.md) = false\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_looking_at)

Returns a copy of this transform rotated so that the forward axis (-Z) points towards the `target` position.

The up axis (+Y) points as close to the `up` vector as possible while staying perpendicular to the forward axis. The resulting transform is orthonormalized. The existing rotation, scale, and skew information from the original transform is discarded. The `target` and `up` vectors cannot be zero, cannot be parallel to each other, and are defined in global/parent space.

If `use_model_front` is ``true``, the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the `target` position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).

<hr class="classref-item-separator"/>

<a id="Transform3D_method_orthonormalized"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **orthonormalized**\ (\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_orthonormalized)

Returns a copy of this transform with its [basis](Transform3D.md#Transform3D_property_basis) orthonormalized. An orthonormal basis is both *orthogonal* (the axes are perpendicular to each other) and *normalized* (the axes have a length of ``1.0``), which also means it can only represent a rotation. See also [Basis.orthonormalized()](Basis.md#Basis_method_orthonormalized).

<hr class="classref-item-separator"/>

<a id="Transform3D_method_rotated"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **rotated**\ (\ axis\: [Vector3](Vector3.md), angle\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_rotated)

Returns a copy of this transform rotated around the given `axis` by the given `angle` (in radians).

The `axis` must be a normalized vector (see [Vector3.normalized()](Vector3.md#Vector3_method_normalized)). If `angle` is positive, the basis is rotated counter-clockwise around the axis.

This method is an optimized version of multiplying the given transform ``X`` with a corresponding rotation transform ``R`` from the left, i.e., ``R * X``.

This can be seen as transforming with respect to the global/parent frame.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_rotated_local"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **rotated_local**\ (\ axis\: [Vector3](Vector3.md), angle\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_rotated_local)

Returns a copy of this transform rotated around the given `axis` by the given `angle` (in radians).

The `axis` must be a normalized vector in the transform's local coordinate system. For example, to rotate around the local X-axis, use [Vector3.RIGHT](Vector3.md#Vector3_constant_RIGHT).

This method is an optimized version of multiplying the given transform ``X`` with a corresponding rotation transform ``R`` from the right, i.e., ``X * R``.

This can be seen as transforming with respect to the local frame.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_scaled"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **scaled**\ (\ scale\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_scaled)

Returns a copy of this transform scaled by the given `scale` factor.

This method is an optimized version of multiplying the given transform ``X`` with a corresponding scaling transform ``S`` from the left, i.e., ``S * X``.

This can be seen as transforming with respect to the global/parent frame.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_scaled_local"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **scaled_local**\ (\ scale\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_scaled_local)

Returns a copy of this transform scaled by the given `scale` factor.

This method is an optimized version of multiplying the given transform ``X`` with a corresponding scaling transform ``S`` from the right, i.e., ``X * S``.

This can be seen as transforming with respect to the local frame.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_translated"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **translated**\ (\ offset\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_translated)

Returns a copy of this transform translated by the given `offset`.

This method is an optimized version of multiplying the given transform ``X`` with a corresponding translation transform ``T`` from the left, i.e., ``T * X``.

This can be seen as transforming with respect to the global/parent frame.

<hr class="classref-item-separator"/>

<a id="Transform3D_method_translated_local"></a>

<!-- classref-method -->

[Transform3D](Transform3D.md) **translated_local**\ (\ offset\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#Transform3D_method_translated_local)

Returns a copy of this transform translated by the given `offset`.

This method is an optimized version of multiplying the given transform ``X`` with a corresponding translation transform ``T`` from the right, i.e., ``X * T``.

This can be seen as transforming with respect to the local frame.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Operator Descriptions

<a id="Transform3D_operator_neq_Transform3D"></a>

<!-- classref-operator -->

[bool](bool.md) **operator !=**\ (\ right\: [Transform3D](Transform3D.md)\ ) [ðŸ”—](#Transform3D_operator_neq_Transform3D)

Returns ``true`` if the components of both transforms are not equal.

\ **Note:** Due to floating-point precision errors, consider using [is_equal_approx()](Transform3D.md#Transform3D_method_is_equal_approx) instead, which is more reliable.

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_mul_AABB"></a>

<!-- classref-operator -->

[AABB](AABB.md) **operator ***\ (\ right\: [AABB](AABB.md)\ ) [ðŸ”—](#Transform3D_operator_mul_AABB)

Transforms (multiplies) the [AABB](AABB.md) by this transformation matrix.

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_mul_PackedVector3Array"></a>

<!-- classref-operator -->

[PackedVector3Array](PackedVector3Array.md) **operator ***\ (\ right\: [PackedVector3Array](PackedVector3Array.md)\ ) [ðŸ”—](#Transform3D_operator_mul_PackedVector3Array)

Transforms (multiplies) every [Vector3](Vector3.md) element of the given [PackedVector3Array](PackedVector3Array.md) by this transformation matrix.

On larger arrays, this operation is much faster than transforming each [Vector3](Vector3.md) individually.

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_mul_Plane"></a>

<!-- classref-operator -->

[Plane](Plane.md) **operator ***\ (\ right\: [Plane](Plane.md)\ ) [ðŸ”—](#Transform3D_operator_mul_Plane)

Transforms (multiplies) the [Plane](Plane.md) by this transformation matrix.

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_mul_Transform3D"></a>

<!-- classref-operator -->

[Transform3D](Transform3D.md) **operator ***\ (\ right\: [Transform3D](Transform3D.md)\ ) [ðŸ”—](#Transform3D_operator_mul_Transform3D)

Transforms (multiplies) this transform by the `right` transform.

This is the operation performed between parent and child [Node3D](Node3D.md)\\ s.

\ **Note:** If you need to only modify one attribute of this transform, consider using one of the following methods, instead:

- For translation, see [translated()](Transform3D.md#Transform3D_method_translated) or [translated_local()](Transform3D.md#Transform3D_method_translated_local).

- For rotation, see [rotated()](Transform3D.md#Transform3D_method_rotated) or [rotated_local()](Transform3D.md#Transform3D_method_rotated_local).

- For scale, see [scaled()](Transform3D.md#Transform3D_method_scaled) or [scaled_local()](Transform3D.md#Transform3D_method_scaled_local).

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_mul_Vector3"></a>

<!-- classref-operator -->

[Vector3](Vector3.md) **operator ***\ (\ right\: [Vector3](Vector3.md)\ ) [ðŸ”—](#Transform3D_operator_mul_Vector3)

Transforms (multiplies) the [Vector3](Vector3.md) by this transformation matrix.

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_mul_float"></a>

<!-- classref-operator -->

[Transform3D](Transform3D.md) **operator ***\ (\ right\: [float](float.md)\ ) [ðŸ”—](#Transform3D_operator_mul_float)

Multiplies all components of the **Transform3D** by the given [float](float.md), including the [origin](Transform3D.md#Transform3D_property_origin). This affects the transform's scale uniformly, scaling the [basis](Transform3D.md#Transform3D_property_basis).

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_mul_int"></a>

<!-- classref-operator -->

[Transform3D](Transform3D.md) **operator ***\ (\ right\: [int](int.md)\ ) [ðŸ”—](#Transform3D_operator_mul_int)

Multiplies all components of the **Transform3D** by the given [int](int.md), including the [origin](Transform3D.md#Transform3D_property_origin). This affects the transform's scale uniformly, scaling the [basis](Transform3D.md#Transform3D_property_basis).

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_div_float"></a>

<!-- classref-operator -->

[Transform3D](Transform3D.md) **operator /**\ (\ right\: [float](float.md)\ ) [ðŸ”—](#Transform3D_operator_div_float)

Divides all components of the **Transform3D** by the given [float](float.md), including the [origin](Transform3D.md#Transform3D_property_origin). This affects the transform's scale uniformly, scaling the [basis](Transform3D.md#Transform3D_property_basis).

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_div_int"></a>

<!-- classref-operator -->

[Transform3D](Transform3D.md) **operator /**\ (\ right\: [int](int.md)\ ) [ðŸ”—](#Transform3D_operator_div_int)

Divides all components of the **Transform3D** by the given [int](int.md), including the [origin](Transform3D.md#Transform3D_property_origin). This affects the transform's scale uniformly, scaling the [basis](Transform3D.md#Transform3D_property_basis).

<hr class="classref-item-separator"/>

<a id="Transform3D_operator_eq_Transform3D"></a>

<!-- classref-operator -->

[bool](bool.md) **operator ==**\ (\ right\: [Transform3D](Transform3D.md)\ ) [ðŸ”—](#Transform3D_operator_eq_Transform3D)

Returns ``true`` if the components of both transforms are exactly equal.

\ **Note:** Due to floating-point precision errors, consider using [is_equal_approx()](Transform3D.md#Transform3D_method_is_equal_approx) instead, which is more reliable.

