<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/TextLine.xml. -->

<a id="class_TextLine"></a>

# TextLine

**Inherits:** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

Holds a line of text.

<!-- classref-introduction-group -->

## Description

Abstraction over [TextServer](class_textserver.md) for handling a single line of text.

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment)</th>
      <th>[alignment](#class_TextLine_property_alignment)</th>
      <th>`0`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Direction](class_textserver.md#enum_TextServer_Direction)</td>
      <td>[direction](#class_TextLine_property_direction)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[String](class_string.md)</td>
      <td>[ellipsis_char](#class_TextLine_property_ellipsis_char)</td>
      <td>`"â€¦"`</td>
    </tr>
    <tr>
      <td>**BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\]</td>
      <td>[flags](#class_TextLine_property_flags)</td>
      <td>`3`</td>
    </tr>
    <tr>
      <td>[Orientation](class_textserver.md#enum_TextServer_Orientation)</td>
      <td>[orientation](#class_TextLine_property_orientation)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[preserve_control](#class_TextLine_property_preserve_control)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[preserve_invalid](#class_TextLine_property_preserve_invalid)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[OverrunBehavior](class_textserver.md#enum_TextServer_OverrunBehavior)</td>
      <td>[text_overrun_behavior](#class_TextLine_property_text_overrun_behavior)</td>
      <td>`3`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[width](#class_TextLine_property_width)</td>
      <td>`-1.0`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[bool](class_bool.md)</th>
      <th>[add_object](#class_TextLine_method_add_object)\ (\ key\: [Variant](class_variant.md), size\: [Vector2](class_vector2.md), inline_align\: [InlineAlignment](class_@globalscope.md#enum_@GlobalScope_InlineAlignment) = 5, length\: [int](class_int.md) = 1, baseline\: [float](class_float.md) = 0.0\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[add_string](#class_TextLine_method_add_string)\ (\ text\: [String](class_string.md), font\: [Font](class_font.md), font_size\: [int](class_int.md), language\: [String](class_string.md) = "", meta\: [Variant](class_variant.md) = null\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[clear](#class_TextLine_method_clear)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[draw](#class_TextLine_method_draw)\ (\ canvas\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), color\: [Color](class_color.md) = Color(1, 1, 1, 1), oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[draw_outline](#class_TextLine_method_draw_outline)\ (\ canvas\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), outline_size\: [int](class_int.md) = 1, color\: [Color](class_color.md) = Color(1, 1, 1, 1), oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Direction](class_textserver.md#enum_TextServer_Direction)</td>
      <td>[get_inferred_direction](#class_TextLine_method_get_inferred_direction)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_line_ascent](#class_TextLine_method_get_line_ascent)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_line_descent](#class_TextLine_method_get_line_descent)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_line_underline_position](#class_TextLine_method_get_line_underline_position)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_line_underline_thickness](#class_TextLine_method_get_line_underline_thickness)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[get_line_width](#class_TextLine_method_get_line_width)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Rect2](class_rect2.md)</td>
      <td>[get_object_rect](#class_TextLine_method_get_object_rect)\ (\ key\: [Variant](class_variant.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Array](class_array.md)</td>
      <td>[get_objects](#class_TextLine_method_get_objects)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[RID](class_rid.md)</td>
      <td>[get_rid](#class_TextLine_method_get_rid)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[get_size](#class_TextLine_method_get_size)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[hit_test](#class_TextLine_method_hit_test)\ (\ coords\: [float](class_float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[resize_object](#class_TextLine_method_resize_object)\ (\ key\: [Variant](class_variant.md), size\: [Vector2](class_vector2.md), inline_align\: [InlineAlignment](class_@globalscope.md#enum_@GlobalScope_InlineAlignment) = 5, baseline\: [float](class_float.md) = 0.0\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_bidi_override](#class_TextLine_method_set_bidi_override)\ (\ override\: [Array](class_array.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[tab_align](#class_TextLine_method_tab_align)\ (\ tab_stops\: [PackedFloat32Array](class_packedfloat32array.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_TextLine_property_alignment"></a>

<!-- classref-property -->

[HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) **alignment** = `0` [ðŸ”—](#class_TextLine_property_alignment)

<!-- classref-property-setget -->

- `void` **set_horizontal_alignment**\ (\ value\: [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment)\ )
- [HorizontalAlignment](class_@globalscope.md#enum_@GlobalScope_HorizontalAlignment) **get_horizontal_alignment**\ (\ )

Sets text alignment within the line as if the line was horizontal.

<hr class="classref-item-separator">

<a id="class_TextLine_property_direction"></a>

<!-- classref-property -->

[Direction](class_textserver.md#enum_TextServer_Direction) **direction** = `0` [ðŸ”—](#class_TextLine_property_direction)

<!-- classref-property-setget -->

- `void` **set_direction**\ (\ value\: [Direction](class_textserver.md#enum_TextServer_Direction)\ )
- [Direction](class_textserver.md#enum_TextServer_Direction) **get_direction**\ (\ )

Text writing direction.

<hr class="classref-item-separator">

<a id="class_TextLine_property_ellipsis_char"></a>

<!-- classref-property -->

[String](class_string.md) **ellipsis_char** = `"â€¦"` [ðŸ”—](#class_TextLine_property_ellipsis_char)

<!-- classref-property-setget -->

- `void` **set_ellipsis_char**\ (\ value\: [String](class_string.md)\ )
- [String](class_string.md) **get_ellipsis_char**\ (\ )

Ellipsis character used for text clipping.

<hr class="classref-item-separator">

<a id="class_TextLine_property_flags"></a>

<!-- classref-property -->

**BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] **flags** = `3` [ðŸ”—](#class_TextLine_property_flags)

<!-- classref-property-setget -->

- `void` **set_flags**\ (\ value\: **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\]\ )
- **BitField**\[[JustificationFlag](class_textserver.md#enum_TextServer_JustificationFlag)\] **get_flags**\ (\ )

Line alignment rules. For more info see [TextServer](class_textserver.md).

<hr class="classref-item-separator">

<a id="class_TextLine_property_orientation"></a>

<!-- classref-property -->

[Orientation](class_textserver.md#enum_TextServer_Orientation) **orientation** = `0` [ðŸ”—](#class_TextLine_property_orientation)

<!-- classref-property-setget -->

- `void` **set_orientation**\ (\ value\: [Orientation](class_textserver.md#enum_TextServer_Orientation)\ )
- [Orientation](class_textserver.md#enum_TextServer_Orientation) **get_orientation**\ (\ )

Text orientation.

<hr class="classref-item-separator">

<a id="class_TextLine_property_preserve_control"></a>

<!-- classref-property -->

[bool](class_bool.md) **preserve_control** = `false` [ðŸ”—](#class_TextLine_property_preserve_control)

<!-- classref-property-setget -->

- `void` **set_preserve_control**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **get_preserve_control**\ (\ )

If set to ``true`` text will display control characters.

<hr class="classref-item-separator">

<a id="class_TextLine_property_preserve_invalid"></a>

<!-- classref-property -->

[bool](class_bool.md) **preserve_invalid** = `true` [ðŸ”—](#class_TextLine_property_preserve_invalid)

<!-- classref-property-setget -->

- `void` **set_preserve_invalid**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **get_preserve_invalid**\ (\ )

If set to ``true`` text will display invalid characters.

<hr class="classref-item-separator">

<a id="class_TextLine_property_text_overrun_behavior"></a>

<!-- classref-property -->

[OverrunBehavior](class_textserver.md#enum_TextServer_OverrunBehavior) **text_overrun_behavior** = `3` [ðŸ”—](#class_TextLine_property_text_overrun_behavior)

<!-- classref-property-setget -->

- `void` **set_text_overrun_behavior**\ (\ value\: [OverrunBehavior](class_textserver.md#enum_TextServer_OverrunBehavior)\ )
- [OverrunBehavior](class_textserver.md#enum_TextServer_OverrunBehavior) **get_text_overrun_behavior**\ (\ )

The clipping behavior when the text exceeds the text line's set width.

<hr class="classref-item-separator">

<a id="class_TextLine_property_width"></a>

<!-- classref-property -->

[float](class_float.md) **width** = `-1.0` [ðŸ”—](#class_TextLine_property_width)

<!-- classref-property-setget -->

- `void` **set_width**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_width**\ (\ )

Text line width.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_TextLine_method_add_object"></a>

<!-- classref-method -->

[bool](class_bool.md) **add_object**\ (\ key\: [Variant](class_variant.md), size\: [Vector2](class_vector2.md), inline_align\: [InlineAlignment](class_@globalscope.md#enum_@GlobalScope_InlineAlignment) = 5, length\: [int](class_int.md) = 1, baseline\: [float](class_float.md) = 0.0\ ) [ðŸ”—](#class_TextLine_method_add_object)

Adds inline object to the text buffer, `key` must be unique. In the text, object is represented as `length` object replacement characters.

<hr class="classref-item-separator">

<a id="class_TextLine_method_add_string"></a>

<!-- classref-method -->

[bool](class_bool.md) **add_string**\ (\ text\: [String](class_string.md), font\: [Font](class_font.md), font_size\: [int](class_int.md), language\: [String](class_string.md) = "", meta\: [Variant](class_variant.md) = null\ ) [ðŸ”—](#class_TextLine_method_add_string)

Adds text span and font to draw it.

<hr class="classref-item-separator">

<a id="class_TextLine_method_clear"></a>

<!-- classref-method -->

`void` **clear**\ (\ ) [ðŸ”—](#class_TextLine_method_clear)

Clears text line (removes text and inline objects).

<hr class="classref-item-separator">

<a id="class_TextLine_method_draw"></a>

<!-- classref-method -->

`void` **draw**\ (\ canvas\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), color\: [Color](class_color.md) = Color(1, 1, 1, 1), oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_draw)

Draw text into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.

<hr class="classref-item-separator">

<a id="class_TextLine_method_draw_outline"></a>

<!-- classref-method -->

`void` **draw_outline**\ (\ canvas\: [RID](class_rid.md), pos\: [Vector2](class_vector2.md), outline_size\: [int](class_int.md) = 1, color\: [Color](class_color.md) = Color(1, 1, 1, 1), oversampling\: [float](class_float.md) = 0.0\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_draw_outline)

Draw text into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_inferred_direction"></a>

<!-- classref-method -->

[Direction](class_textserver.md#enum_TextServer_Direction) **get_inferred_direction**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_inferred_direction)

Returns the text writing direction inferred by the BiDi algorithm.

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_line_ascent"></a>

<!-- classref-method -->

[float](class_float.md) **get_line_ascent**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_line_ascent)

Returns the text ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_line_descent"></a>

<!-- classref-method -->

[float](class_float.md) **get_line_descent**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_line_descent)

Returns the text descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_line_underline_position"></a>

<!-- classref-method -->

[float](class_float.md) **get_line_underline_position**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_line_underline_position)

Returns pixel offset of the underline below the baseline.

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_line_underline_thickness"></a>

<!-- classref-method -->

[float](class_float.md) **get_line_underline_thickness**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_line_underline_thickness)

Returns thickness of the underline.

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_line_width"></a>

<!-- classref-method -->

[float](class_float.md) **get_line_width**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_line_width)

Returns width (for horizontal layout) or height (for vertical) of the text.

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_object_rect"></a>

<!-- classref-method -->

[Rect2](class_rect2.md) **get_object_rect**\ (\ key\: [Variant](class_variant.md)\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_object_rect)

Returns bounding rectangle of the inline object.

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_objects"></a>

<!-- classref-method -->

[Array](class_array.md) **get_objects**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_objects)

Returns array of inline objects.

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_rid"></a>

<!-- classref-method -->

[RID](class_rid.md) **get_rid**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_rid)

Returns TextServer buffer RID.

<hr class="classref-item-separator">

<a id="class_TextLine_method_get_size"></a>

<!-- classref-method -->

[Vector2](class_vector2.md) **get_size**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_get_size)

Returns size of the bounding box of the text.

<hr class="classref-item-separator">

<a id="class_TextLine_method_hit_test"></a>

<!-- classref-method -->

[int](class_int.md) **hit_test**\ (\ coords\: [float](class_float.md)\ ) <span class="const">const</span> [ðŸ”—](#class_TextLine_method_hit_test)

Returns caret character offset at the specified pixel offset at the baseline. This function always returns a valid position.

<hr class="classref-item-separator">

<a id="class_TextLine_method_resize_object"></a>

<!-- classref-method -->

[bool](class_bool.md) **resize_object**\ (\ key\: [Variant](class_variant.md), size\: [Vector2](class_vector2.md), inline_align\: [InlineAlignment](class_@globalscope.md#enum_@GlobalScope_InlineAlignment) = 5, baseline\: [float](class_float.md) = 0.0\ ) [ðŸ”—](#class_TextLine_method_resize_object)

Sets new size and alignment of embedded object.

<hr class="classref-item-separator">

<a id="class_TextLine_method_set_bidi_override"></a>

<!-- classref-method -->

`void` **set_bidi_override**\ (\ override\: [Array](class_array.md)\ ) [ðŸ”—](#class_TextLine_method_set_bidi_override)

Overrides BiDi for the structured text.

Override ranges should cover full source text without overlaps. BiDi algorithm will be used on each range separately.

<hr class="classref-item-separator">

<a id="class_TextLine_method_tab_align"></a>

<!-- classref-method -->

`void` **tab_align**\ (\ tab_stops\: [PackedFloat32Array](class_packedfloat32array.md)\ ) [ðŸ”—](#class_TextLine_method_tab_align)

Aligns text to the given tab-stops.

