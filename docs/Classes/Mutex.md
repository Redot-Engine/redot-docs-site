<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Mutex.xml. -->

<a id="Mutex"></a>

# Mutex

**Inherits:** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

A binary [Semaphore](Semaphore.md) for synchronization of multiple [Thread](Thread.md)\\ s.

<!-- classref-introduction-group -->

## Description

A synchronization mutex (mutual exclusion). This is used to synchronize multiple [Thread](Thread.md)\\ s, and is equivalent to a binary [Semaphore](Semaphore.md). It guarantees that only one thread can access a critical section at a time.

This is a reentrant mutex, meaning that it can be locked multiple times by one thread, provided it also unlocks it as many times.

\ **Warning:** Mutexes must be used carefully to avoid deadlocks.

\ **Warning:** To ensure proper cleanup without crashes or deadlocks, the following conditions must be met:

- When a **Mutex**'s reference count reaches zero and it is therefore destroyed, no threads (including the one on which the destruction will happen) must have it locked.

- When a [Thread](Thread.md)'s reference count reaches zero and it is therefore destroyed, it must not have any mutex locked.

<!-- classref-introduction-group -->

## Tutorials

- [Using multiple threads](../tutorials/performance/using_multiple_threads.md)

- [Thread-safe APIs](../tutorials/performance/thread_safe_apis.md)

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>`void`</th>
      <th>[lock](#Mutex_method_lock)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[try_lock](#Mutex_method_try_lock)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[unlock](#Mutex_method_unlock)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Mutex_method_lock"></a>

<!-- classref-method -->

`void` **lock**\ (\ ) [ðŸ”—](#Mutex_method_lock)

Locks this **Mutex**, blocks until it is unlocked by the current owner.

\ **Note:** This function returns without blocking if the thread already has ownership of the mutex.

<hr class="classref-item-separator"/>

<a id="Mutex_method_try_lock"></a>

<!-- classref-method -->

[bool](bool.md) **try_lock**\ (\ ) [ðŸ”—](#Mutex_method_try_lock)

Tries locking this **Mutex**, but does not block. Returns ``true`` on success, ``false`` otherwise.

\ **Note:** This function returns ``true`` if the thread already has ownership of the mutex.

<hr class="classref-item-separator"/>

<a id="Mutex_method_unlock"></a>

<!-- classref-method -->

`void` **unlock**\ (\ ) [ðŸ”—](#Mutex_method_unlock)

Unlocks this **Mutex**, leaving it to other threads.

\ **Note:** If a thread called [lock()](Mutex.md#Mutex_method_lock) or [try_lock()](Mutex.md#Mutex_method_try_lock) multiple times while already having ownership of the mutex, it must also call [unlock()](Mutex.md#Mutex_method_unlock) the same number of times in order to unlock it correctly.

\ **Warning:** Calling [unlock()](Mutex.md#Mutex_method_unlock) more times that [lock()](Mutex.md#Mutex_method_lock) on a given thread, thus ending up trying to unlock a non-locked mutex, is wrong and may causes crashes or deadlocks.

