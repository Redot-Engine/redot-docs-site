<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/modules/csg/doc_classes/CSGPolygon3D.xml. -->

<a id="CSGPolygon3D"></a>

# CSGPolygon3D

**Inherits:** [CSGPrimitive3D](CSGPrimitive3D.md) **\<** [CSGShape3D](CSGShape3D.md) **\<** [GeometryInstance3D](GeometryInstance3D.md) **\<** [VisualInstance3D](VisualInstance3D.md) **\<** [Node3D](Node3D.md) **\<** [Node](Node.md) **\<** [Object](Object.md)

Extrudes a 2D polygon shape to create a 3D mesh.

<!-- classref-introduction-group -->

## Description

An array of 2D points is extruded to quickly and easily create a variety of 3D meshes. See also [CSGMesh3D](CSGMesh3D.md) for using 3D meshes as CSG nodes.

\ **Note:** CSG nodes are intended to be used for level prototyping. Creating CSG nodes has a significant CPU cost compared to creating a [MeshInstance3D](MeshInstance3D.md) with a [PrimitiveMesh](PrimitiveMesh.md). Moving a CSG node within another CSG node also has a significant CPU cost, so it should be avoided during gameplay.

<!-- classref-introduction-group -->

## Tutorials

- [Prototyping levels with CSG](../tutorials/3d/csg_tools.md)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[float](float.md)</th>
      <th>[depth](#CSGPolygon3D_property_depth)</th>
      <th>`1.0`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Material](Material.md)</td>
      <td>[material](#CSGPolygon3D_property_material)</td>
      <td></td>
    </tr>
    <tr>
      <td>[Mode](CSGPolygon3D.md#enum_CSGPolygon3D_Mode)</td>
      <td>[mode](#CSGPolygon3D_property_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[path_continuous_u](#CSGPolygon3D_property_path_continuous_u)</td>
      <td></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[path_interval](#CSGPolygon3D_property_path_interval)</td>
      <td></td>
    </tr>
    <tr>
      <td>[PathIntervalType](CSGPolygon3D.md#enum_CSGPolygon3D_PathIntervalType)</td>
      <td>[path_interval_type](#CSGPolygon3D_property_path_interval_type)</td>
      <td></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[path_joined](#CSGPolygon3D_property_path_joined)</td>
      <td></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[path_local](#CSGPolygon3D_property_path_local)</td>
      <td></td>
    </tr>
    <tr>
      <td>[NodePath](NodePath.md)</td>
      <td>[path_node](#CSGPolygon3D_property_path_node)</td>
      <td></td>
    </tr>
    <tr>
      <td>[PathRotation](CSGPolygon3D.md#enum_CSGPolygon3D_PathRotation)</td>
      <td>[path_rotation](#CSGPolygon3D_property_path_rotation)</td>
      <td></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[path_rotation_accurate](#CSGPolygon3D_property_path_rotation_accurate)</td>
      <td></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[path_simplify_angle](#CSGPolygon3D_property_path_simplify_angle)</td>
      <td></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[path_u_distance](#CSGPolygon3D_property_path_u_distance)</td>
      <td></td>
    </tr>
    <tr>
      <td>[PackedVector2Array](PackedVector2Array.md)</td>
      <td>[polygon](#CSGPolygon3D_property_polygon)</td>
      <td>`PackedVector2Array(0, 0, 0, 1, 1, 1, 1, 0)`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[smooth_faces](#CSGPolygon3D_property_smooth_faces)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[spin_degrees](#CSGPolygon3D_property_spin_degrees)</td>
      <td></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[spin_sides](#CSGPolygon3D_property_spin_sides)</td>
      <td></td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_CSGPolygon3D_Mode"></a>

<!-- classref-enumeration -->

enum **Mode**: [ðŸ”—](#enum_CSGPolygon3D_Mode)

<a id="CSGPolygon3D_constant_MODE_DEPTH"></a>

<!-- classref-enumeration-constant -->

[Mode](CSGPolygon3D.md#enum_CSGPolygon3D_Mode) **MODE_DEPTH** = `0`

The [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon) shape is extruded along the negative Z axis.<a id="CSGPolygon3D_constant_MODE_SPIN"></a>

<!-- classref-enumeration-constant -->

[Mode](CSGPolygon3D.md#enum_CSGPolygon3D_Mode) **MODE_SPIN** = `1`

The [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon) shape is extruded by rotating it around the Y axis.<a id="CSGPolygon3D_constant_MODE_PATH"></a>

<!-- classref-enumeration-constant -->

[Mode](CSGPolygon3D.md#enum_CSGPolygon3D_Mode) **MODE_PATH** = `2`

The [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon) shape is extruded along the [Path3D](Path3D.md) specified in [path_node](CSGPolygon3D.md#CSGPolygon3D_property_path_node).<hr class="classref-item-separator"/>

<a id="enum_CSGPolygon3D_PathRotation"></a>

<!-- classref-enumeration -->

enum **PathRotation**: [ðŸ”—](#enum_CSGPolygon3D_PathRotation)

<a id="CSGPolygon3D_constant_PATH_ROTATION_POLYGON"></a>

<!-- classref-enumeration-constant -->

[PathRotation](CSGPolygon3D.md#enum_CSGPolygon3D_PathRotation) **PATH_ROTATION_POLYGON** = `0`

The [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon) shape is not rotated.

\ **Note:** Requires the path Z coordinates to continually decrease to ensure viable shapes.<a id="CSGPolygon3D_constant_PATH_ROTATION_PATH"></a>

<!-- classref-enumeration-constant -->

[PathRotation](CSGPolygon3D.md#enum_CSGPolygon3D_PathRotation) **PATH_ROTATION_PATH** = `1`

The [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon) shape is rotated along the path, but it is not rotated around the path axis.

\ **Note:** Requires the path Z coordinates to continually decrease to ensure viable shapes.<a id="CSGPolygon3D_constant_PATH_ROTATION_PATH_FOLLOW"></a>

<!-- classref-enumeration-constant -->

[PathRotation](CSGPolygon3D.md#enum_CSGPolygon3D_PathRotation) **PATH_ROTATION_PATH_FOLLOW** = `2`

The [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon) shape follows the path and its rotations around the path axis.<hr class="classref-item-separator"/>

<a id="enum_CSGPolygon3D_PathIntervalType"></a>

<!-- classref-enumeration -->

enum **PathIntervalType**: [ðŸ”—](#enum_CSGPolygon3D_PathIntervalType)

<a id="CSGPolygon3D_constant_PATH_INTERVAL_DISTANCE"></a>

<!-- classref-enumeration-constant -->

[PathIntervalType](CSGPolygon3D.md#enum_CSGPolygon3D_PathIntervalType) **PATH_INTERVAL_DISTANCE** = `0`

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is set to [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), [path_interval](CSGPolygon3D.md#CSGPolygon3D_property_path_interval) will determine the distance, in meters, each interval of the path will extrude.<a id="CSGPolygon3D_constant_PATH_INTERVAL_SUBDIVIDE"></a>

<!-- classref-enumeration-constant -->

[PathIntervalType](CSGPolygon3D.md#enum_CSGPolygon3D_PathIntervalType) **PATH_INTERVAL_SUBDIVIDE** = `1`

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is set to [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), [path_interval](CSGPolygon3D.md#CSGPolygon3D_property_path_interval) will subdivide the polygons along the path.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="CSGPolygon3D_property_depth"></a>

<!-- classref-property -->

[float](float.md) **depth** = `1.0` [ðŸ”—](#CSGPolygon3D_property_depth)

<!-- classref-property-setget -->

- `void` **set_depth**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_depth**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_DEPTH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_DEPTH), the depth of the extrusion.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_material"></a>

<!-- classref-property -->

[Material](Material.md) **material** [ðŸ”—](#CSGPolygon3D_property_material)

<!-- classref-property-setget -->

- `void` **set_material**\ (\ value\: [Material](Material.md)\ )
- [Material](Material.md) **get_material**\ (\ )

Material to use for the resulting mesh. The UV maps the top half of the material to the extruded shape (U along the length of the extrusions and V around the outline of the [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon)), the bottom-left quarter to the front end face, and the bottom-right quarter to the back end face.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_mode"></a>

<!-- classref-property -->

[Mode](CSGPolygon3D.md#enum_CSGPolygon3D_Mode) **mode** = `0` [ðŸ”—](#CSGPolygon3D_property_mode)

<!-- classref-property-setget -->

- `void` **set_mode**\ (\ value\: [Mode](CSGPolygon3D.md#enum_CSGPolygon3D_Mode)\ )
- [Mode](CSGPolygon3D.md#enum_CSGPolygon3D_Mode) **get_mode**\ (\ )

The [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) used to extrude the [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon).

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_continuous_u"></a>

<!-- classref-property -->

[bool](bool.md) **path_continuous_u** [ðŸ”—](#CSGPolygon3D_property_path_continuous_u)

<!-- classref-property-setget -->

- `void` **set_path_continuous_u**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_path_continuous_u**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), by default, the top half of the [material](CSGPolygon3D.md#CSGPolygon3D_property_material) is stretched along the entire length of the extruded shape. If ``false`` the top half of the material is repeated every step of the extrusion.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_interval"></a>

<!-- classref-property -->

[float](float.md) **path_interval** [ðŸ”—](#CSGPolygon3D_property_path_interval)

<!-- classref-property-setget -->

- `void` **set_path_interval**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_path_interval**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), the path interval or ratio of path points to extrusions.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_interval_type"></a>

<!-- classref-property -->

[PathIntervalType](CSGPolygon3D.md#enum_CSGPolygon3D_PathIntervalType) **path_interval_type** [ðŸ”—](#CSGPolygon3D_property_path_interval_type)

<!-- classref-property-setget -->

- `void` **set_path_interval_type**\ (\ value\: [PathIntervalType](CSGPolygon3D.md#enum_CSGPolygon3D_PathIntervalType)\ )
- [PathIntervalType](CSGPolygon3D.md#enum_CSGPolygon3D_PathIntervalType) **get_path_interval_type**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), this will determine if the interval should be by distance ([PATH_INTERVAL_DISTANCE](CSGPolygon3D.md#CSGPolygon3D_constant_PATH_INTERVAL_DISTANCE)) or subdivision fractions ([PATH_INTERVAL_SUBDIVIDE](CSGPolygon3D.md#CSGPolygon3D_constant_PATH_INTERVAL_SUBDIVIDE)).

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_joined"></a>

<!-- classref-property -->

[bool](bool.md) **path_joined** [ðŸ”—](#CSGPolygon3D_property_path_joined)

<!-- classref-property-setget -->

- `void` **set_path_joined**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_path_joined**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), if ``true`` the ends of the path are joined, by adding an extrusion between the last and first points of the path.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_local"></a>

<!-- classref-property -->

[bool](bool.md) **path_local** [ðŸ”—](#CSGPolygon3D_property_path_local)

<!-- classref-property-setget -->

- `void` **set_path_local**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_path_local**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), if ``true`` the [Transform3D](Transform3D.md) of the **CSGPolygon3D** is used as the starting point for the extrusions, not the [Transform3D](Transform3D.md) of the [path_node](CSGPolygon3D.md#CSGPolygon3D_property_path_node).

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_node"></a>

<!-- classref-property -->

[NodePath](NodePath.md) **path_node** [ðŸ”—](#CSGPolygon3D_property_path_node)

<!-- classref-property-setget -->

- `void` **set_path_node**\ (\ value\: [NodePath](NodePath.md)\ )
- [NodePath](NodePath.md) **get_path_node**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), the location of the [Path3D](Path3D.md) object used to extrude the [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon).

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_rotation"></a>

<!-- classref-property -->

[PathRotation](CSGPolygon3D.md#enum_CSGPolygon3D_PathRotation) **path_rotation** [ðŸ”—](#CSGPolygon3D_property_path_rotation)

<!-- classref-property-setget -->

- `void` **set_path_rotation**\ (\ value\: [PathRotation](CSGPolygon3D.md#enum_CSGPolygon3D_PathRotation)\ )
- [PathRotation](CSGPolygon3D.md#enum_CSGPolygon3D_PathRotation) **get_path_rotation**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), the path rotation method used to rotate the [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon) as it is extruded.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_rotation_accurate"></a>

<!-- classref-property -->

[bool](bool.md) **path_rotation_accurate** [ðŸ”—](#CSGPolygon3D_property_path_rotation_accurate)

<!-- classref-property-setget -->

- `void` **set_path_rotation_accurate**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_path_rotation_accurate**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), if ``true`` the polygon will be rotated according to the proper tangent of the path at the sampled points. If ``false`` an approximation is used, which decreases in accuracy as the number of subdivisions decreases.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_simplify_angle"></a>

<!-- classref-property -->

[float](float.md) **path_simplify_angle** [ðŸ”—](#CSGPolygon3D_property_path_simplify_angle)

<!-- classref-property-setget -->

- `void` **set_path_simplify_angle**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_path_simplify_angle**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), extrusions that are less than this angle, will be merged together to reduce polygon count.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_path_u_distance"></a>

<!-- classref-property -->

[float](float.md) **path_u_distance** [ðŸ”—](#CSGPolygon3D_property_path_u_distance)

<!-- classref-property-setget -->

- `void` **set_path_u_distance**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_path_u_distance**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_PATH](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_PATH), this is the distance along the path, in meters, the texture coordinates will tile. When set to 0, texture coordinates will match geometry exactly with no tiling.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_polygon"></a>

<!-- classref-property -->

[PackedVector2Array](PackedVector2Array.md) **polygon** = `PackedVector2Array(0, 0, 0, 1, 1, 1, 1, 0)` [ðŸ”—](#CSGPolygon3D_property_polygon)

<!-- classref-property-setget -->

- `void` **set_polygon**\ (\ value\: [PackedVector2Array](PackedVector2Array.md)\ )
- [PackedVector2Array](PackedVector2Array.md) **get_polygon**\ (\ )

The point array that defines the 2D polygon that is extruded. This can be a convex or concave polygon with 3 or more points. The polygon must *not* have any intersecting edges. Otherwise, triangulation will fail and no mesh will be generated.

\ **Note:** If only 1 or 2 points are defined in [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon), no mesh will be generated.

**Note:** The returned array is *copied* and any changes to it will not update the original property value. See [PackedVector2Array](PackedVector2Array.md) for more details.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_smooth_faces"></a>

<!-- classref-property -->

[bool](bool.md) **smooth_faces** = `false` [ðŸ”—](#CSGPolygon3D_property_smooth_faces)

<!-- classref-property-setget -->

- `void` **set_smooth_faces**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_smooth_faces**\ (\ )

If ``true``, applies smooth shading to the extrusions.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_spin_degrees"></a>

<!-- classref-property -->

[float](float.md) **spin_degrees** [ðŸ”—](#CSGPolygon3D_property_spin_degrees)

<!-- classref-property-setget -->

- `void` **set_spin_degrees**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_spin_degrees**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_SPIN](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_SPIN), the total number of degrees the [polygon](CSGPolygon3D.md#CSGPolygon3D_property_polygon) is rotated when extruding.

<hr class="classref-item-separator"/>

<a id="CSGPolygon3D_property_spin_sides"></a>

<!-- classref-property -->

[int](int.md) **spin_sides** [ðŸ”—](#CSGPolygon3D_property_spin_sides)

<!-- classref-property-setget -->

- `void` **set_spin_sides**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_spin_sides**\ (\ )

When [mode](CSGPolygon3D.md#CSGPolygon3D_property_mode) is [MODE_SPIN](CSGPolygon3D.md#CSGPolygon3D_constant_MODE_SPIN), the number of extrusions made.

