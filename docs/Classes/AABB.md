<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/AABB.xml. -->

<a id="AABB"></a>

# AABB

A 3D axis-aligned bounding box.

<!-- classref-introduction-group -->

## Description

The **AABB** built-in [Variant](Variant.md) type represents an axis-aligned bounding box in a 3D space. It is defined by its [position](AABB.md#AABB_property_position) and [size](AABB.md#AABB_property_size), which are [Vector3](Vector3.md). It is frequently used for fast overlap tests (see [intersects()](AABB.md#AABB_method_intersects)). Although **AABB** itself is axis-aligned, it can be combined with [Transform3D](Transform3D.md) to represent a rotated or skewed bounding box.

It uses floating-point coordinates. The 2D counterpart to **AABB** is [Rect2](Rect2.md). There is no version of **AABB** that uses integer coordinates.

\ **Note:** Negative values for [size](AABB.md#AABB_property_size) are not supported. With negative size, most **AABB** methods do not work correctly. Use [abs()](AABB.md#AABB_method_abs) to get an equivalent **AABB** with a non-negative size.

\ **Note:** In a boolean context, an **AABB** evaluates to ``false`` if both [position](AABB.md#AABB_property_position) and [size](AABB.md#AABB_property_size) are zero (equal to [Vector3.ZERO](Vector3.md#Vector3_constant_ZERO)). Otherwise, it always evaluates to ``true``.

<div class="note">
There are notable differences when using this API with C#. See the C# differences documentation for more information.

</div>

<!-- classref-introduction-group -->

## Tutorials

- [Math documentation index](../tutorials/math/index.md)

- [Vector math](../tutorials/math/vector_math.md)

- [Advanced vector math](../tutorials/math/vectors_advanced.md)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[Vector3](Vector3.md)</th>
      <th>[end](#AABB_property_end)</th>
      <th>`Vector3(0, 0, 0)`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[position](#AABB_property_position)</td>
      <td>`Vector3(0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[size](#AABB_property_size)</td>
      <td>`Vector3(0, 0, 0)`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Constructors

<table>
  <thead>
    <tr>
      <th>[AABB](AABB.md)</th>
      <th>[AABB](#AABB_constructor_AABB)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[AABB](#AABB_constructor_AABB)\ (\ from\: [AABB](AABB.md)\ )</td>
    </tr>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[AABB](#AABB_constructor_AABB)\ (\ position\: [Vector3](Vector3.md), size\: [Vector3](Vector3.md)\ )</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[AABB](AABB.md)</th>
      <th>[abs](#AABB_method_abs)\ (\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[encloses](#AABB_method_encloses)\ (\ with\: [AABB](AABB.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[expand](#AABB_method_expand)\ (\ to_point\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[get_center](#AABB_method_get_center)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[get_endpoint](#AABB_method_get_endpoint)\ (\ idx\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[get_longest_axis](#AABB_method_get_longest_axis)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_longest_axis_index](#AABB_method_get_longest_axis_index)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[get_longest_axis_size](#AABB_method_get_longest_axis_size)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[get_shortest_axis](#AABB_method_get_shortest_axis)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_shortest_axis_index](#AABB_method_get_shortest_axis_index)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[get_shortest_axis_size](#AABB_method_get_shortest_axis_size)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[get_support](#AABB_method_get_support)\ (\ direction\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[get_volume](#AABB_method_get_volume)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[grow](#AABB_method_grow)\ (\ by\: [float](float.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_point](#AABB_method_has_point)\ (\ point\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_surface](#AABB_method_has_surface)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_volume](#AABB_method_has_volume)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[intersection](#AABB_method_intersection)\ (\ with\: [AABB](AABB.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[intersects](#AABB_method_intersects)\ (\ with\: [AABB](AABB.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[intersects_plane](#AABB_method_intersects_plane)\ (\ plane\: [Plane](Plane.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[intersects_ray](#AABB_method_intersects_ray)\ (\ from\: [Vector3](Vector3.md), dir\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[intersects_segment](#AABB_method_intersects_segment)\ (\ from\: [Vector3](Vector3.md), to\: [Vector3](Vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_equal_approx](#AABB_method_is_equal_approx)\ (\ aabb\: [AABB](AABB.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_finite](#AABB_method_is_finite)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[merge](#AABB_method_merge)\ (\ with\: [AABB](AABB.md)\ ) <span class="const">const</span></td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Operators

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[operator !=](#AABB_operator_neq_AABB)\ (\ right\: [AABB](AABB.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[operator *](#AABB_operator_mul_Transform3D)\ (\ right\: [Transform3D](Transform3D.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator ==](#AABB_operator_eq_AABB)\ (\ right\: [AABB](AABB.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="AABB_property_end"></a>

<!-- classref-property -->

[Vector3](Vector3.md) **end** = `Vector3(0, 0, 0)` [ðŸ”—](#AABB_property_end)

The ending point. This is usually the corner on the top-right and back of the bounding box, and is equivalent to ``position + size``. Setting this point affects the [size](AABB.md#AABB_property_size).

<hr class="classref-item-separator"/>

<a id="AABB_property_position"></a>

<!-- classref-property -->

[Vector3](Vector3.md) **position** = `Vector3(0, 0, 0)` [ðŸ”—](#AABB_property_position)

The origin point. This is usually the corner on the bottom-left and forward of the bounding box.

<hr class="classref-item-separator"/>

<a id="AABB_property_size"></a>

<!-- classref-property -->

[Vector3](Vector3.md) **size** = `Vector3(0, 0, 0)` [ðŸ”—](#AABB_property_size)

The bounding box's width, height, and depth starting from [position](AABB.md#AABB_property_position). Setting this value also affects the [end](AABB.md#AABB_property_end) point.

\ **Note:** It's recommended setting the width, height, and depth to non-negative values. This is because most methods in Redot assume that the [position](AABB.md#AABB_property_position) is the bottom-left-forward corner, and the [end](AABB.md#AABB_property_end) is the top-right-back corner. To get an equivalent bounding box with non-negative size, use [abs()](AABB.md#AABB_method_abs).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Constructor Descriptions

<a id="AABB_constructor_AABB"></a>

<!-- classref-constructor -->

[AABB](AABB.md) **AABB**\ (\ ) [ðŸ”—](#AABB_constructor_AABB)

Constructs an **AABB** with its [position](AABB.md#AABB_property_position) and [size](AABB.md#AABB_property_size) set to [Vector3.ZERO](Vector3.md#Vector3_constant_ZERO).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[AABB](AABB.md) **AABB**\ (\ from\: [AABB](AABB.md)\ )

Constructs an **AABB** as a copy of the given **AABB**.

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[AABB](AABB.md) **AABB**\ (\ position\: [Vector3](Vector3.md), size\: [Vector3](Vector3.md)\ )

Constructs an **AABB** by `position` and `size`.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="AABB_method_abs"></a>

<!-- classref-method -->

[AABB](AABB.md) **abs**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_abs)

Returns an **AABB** equivalent to this bounding box, with its width, height, and depth modified to be non-negative values.




```gdscript
    var box = AABB(Vector3(5, 0, 5), Vector3(-20, -10, -5))
    var absolute = box.abs()
    print(absolute.position) # Prints (-15.0, -10.0, 0.0)
    print(absolute.size)     # Prints (20.0, 10.0, 5.0)
```


```csharp
    var box = new Aabb(new Vector3(5, 0, 5), new Vector3(-20, -10, -5));
    var absolute = box.Abs();
    GD.Print(absolute.Position); // Prints (-15, -10, 0)
    GD.Print(absolute.Size);     // Prints (20, 10, 5)
```




\ **Note:** It's recommended to use this method when [size](AABB.md#AABB_property_size) is negative, as most other methods in Redot assume that the [size](AABB.md#AABB_property_size)'s components are greater than ``0``.

<hr class="classref-item-separator"/>

<a id="AABB_method_encloses"></a>

<!-- classref-method -->

[bool](bool.md) **encloses**\ (\ with\: [AABB](AABB.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_encloses)

Returns ``true`` if this bounding box *completely* encloses the `with` box. The edges of both boxes are included.




```gdscript
    var a = AABB(Vector3(0, 0, 0), Vector3(4, 4, 4))
    var b = AABB(Vector3(1, 1, 1), Vector3(3, 3, 3))
    var c = AABB(Vector3(2, 2, 2), Vector3(8, 8, 8))

    print(a.encloses(a)) # Prints true
    print(a.encloses(b)) # Prints true
    print(a.encloses(c)) # Prints false
```


```csharp
    var a = new Aabb(new Vector3(0, 0, 0), new Vector3(4, 4, 4));
    var b = new Aabb(new Vector3(1, 1, 1), new Vector3(3, 3, 3));
    var c = new Aabb(new Vector3(2, 2, 2), new Vector3(8, 8, 8));

    GD.Print(a.Encloses(a)); // Prints True
    GD.Print(a.Encloses(b)); // Prints True
    GD.Print(a.Encloses(c)); // Prints False
```




<hr class="classref-item-separator"/>

<a id="AABB_method_expand"></a>

<!-- classref-method -->

[AABB](AABB.md) **expand**\ (\ to_point\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_expand)

Returns a copy of this bounding box expanded to align the edges with the given `to_point`, if necessary.




```gdscript
    var box = AABB(Vector3(0, 0, 0), Vector3(5, 2, 5))

    box = box.expand(Vector3(10, 0, 0))
    print(box.position) # Prints (0.0, 0.0, 0.0)
    print(box.size)     # Prints (10.0, 2.0, 5.0)

    box = box.expand(Vector3(-5, 0, 5))
    print(box.position) # Prints (-5.0, 0.0, 0.0)
    print(box.size)     # Prints (15.0, 2.0, 5.0)
```


```csharp
    var box = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 5));

    box = box.Expand(new Vector3(10, 0, 0));
    GD.Print(box.Position); // Prints (0, 0, 0)
    GD.Print(box.Size);     // Prints (10, 2, 5)

    box = box.Expand(new Vector3(-5, 0, 5));
    GD.Print(box.Position); // Prints (-5, 0, 0)
    GD.Print(box.Size);     // Prints (15, 2, 5)
```




<hr class="classref-item-separator"/>

<a id="AABB_method_get_center"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **get_center**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_center)

Returns the center point of the bounding box. This is the same as ``position + (size / 2.0)``.

<hr class="classref-item-separator"/>

<a id="AABB_method_get_endpoint"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **get_endpoint**\ (\ idx\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_endpoint)

Returns the position of one of the 8 vertices that compose this bounding box. With an `idx` of ``0`` this is the same as [position](AABB.md#AABB_property_position), and an `idx` of ``7`` is the same as [end](AABB.md#AABB_property_end).

<hr class="classref-item-separator"/>

<a id="AABB_method_get_longest_axis"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **get_longest_axis**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_longest_axis)

Returns the longest normalized axis of this bounding box's [size](AABB.md#AABB_property_size), as a [Vector3](Vector3.md) ([Vector3.RIGHT](Vector3.md#Vector3_constant_RIGHT), [Vector3.UP](Vector3.md#Vector3_constant_UP), or [Vector3.BACK](Vector3.md#Vector3_constant_BACK)).




```gdscript
    var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

    print(box.get_longest_axis())       # Prints (0.0, 0.0, 1.0)
    print(box.get_longest_axis_index()) # Prints 2
    print(box.get_longest_axis_size())  # Prints 8.0
```


```csharp
    var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

    GD.Print(box.GetLongestAxis());      // Prints (0, 0, 1)
    GD.Print(box.GetLongestAxisIndex()); // Prints Z
    GD.Print(box.GetLongestAxisSize());  // Prints 8
```




See also [get_longest_axis_index()](AABB.md#AABB_method_get_longest_axis_index) and [get_longest_axis_size()](AABB.md#AABB_method_get_longest_axis_size).

<hr class="classref-item-separator"/>

<a id="AABB_method_get_longest_axis_index"></a>

<!-- classref-method -->

[int](int.md) **get_longest_axis_index**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_longest_axis_index)

Returns the index to the longest axis of this bounding box's [size](AABB.md#AABB_property_size) (see [Vector3.AXIS_X](Vector3.md#Vector3_constant_AXIS_X), [Vector3.AXIS_Y](Vector3.md#Vector3_constant_AXIS_Y), and [Vector3.AXIS_Z](Vector3.md#Vector3_constant_AXIS_Z)).

For an example, see [get_longest_axis()](AABB.md#AABB_method_get_longest_axis).

<hr class="classref-item-separator"/>

<a id="AABB_method_get_longest_axis_size"></a>

<!-- classref-method -->

[float](float.md) **get_longest_axis_size**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_longest_axis_size)

Returns the longest dimension of this bounding box's [size](AABB.md#AABB_property_size).

For an example, see [get_longest_axis()](AABB.md#AABB_method_get_longest_axis).

<hr class="classref-item-separator"/>

<a id="AABB_method_get_shortest_axis"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **get_shortest_axis**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_shortest_axis)

Returns the shortest normalized axis of this bounding box's [size](AABB.md#AABB_property_size), as a [Vector3](Vector3.md) ([Vector3.RIGHT](Vector3.md#Vector3_constant_RIGHT), [Vector3.UP](Vector3.md#Vector3_constant_UP), or [Vector3.BACK](Vector3.md#Vector3_constant_BACK)).




```gdscript
    var box = AABB(Vector3(0, 0, 0), Vector3(2, 4, 8))

    print(box.get_shortest_axis())       # Prints (1.0, 0.0, 0.0)
    print(box.get_shortest_axis_index()) # Prints 0
    print(box.get_shortest_axis_size())  # Prints 2.0
```


```csharp
    var box = new Aabb(new Vector3(0, 0, 0), new Vector3(2, 4, 8));

    GD.Print(box.GetShortestAxis());      // Prints (1, 0, 0)
    GD.Print(box.GetShortestAxisIndex()); // Prints X
    GD.Print(box.GetShortestAxisSize());  // Prints 2
```




See also [get_shortest_axis_index()](AABB.md#AABB_method_get_shortest_axis_index) and [get_shortest_axis_size()](AABB.md#AABB_method_get_shortest_axis_size).

<hr class="classref-item-separator"/>

<a id="AABB_method_get_shortest_axis_index"></a>

<!-- classref-method -->

[int](int.md) **get_shortest_axis_index**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_shortest_axis_index)

Returns the index to the shortest axis of this bounding box's [size](AABB.md#AABB_property_size) (see [Vector3.AXIS_X](Vector3.md#Vector3_constant_AXIS_X), [Vector3.AXIS_Y](Vector3.md#Vector3_constant_AXIS_Y), and [Vector3.AXIS_Z](Vector3.md#Vector3_constant_AXIS_Z)).

For an example, see [get_shortest_axis()](AABB.md#AABB_method_get_shortest_axis).

<hr class="classref-item-separator"/>

<a id="AABB_method_get_shortest_axis_size"></a>

<!-- classref-method -->

[float](float.md) **get_shortest_axis_size**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_shortest_axis_size)

Returns the shortest dimension of this bounding box's [size](AABB.md#AABB_property_size).

For an example, see [get_shortest_axis()](AABB.md#AABB_method_get_shortest_axis).

<hr class="classref-item-separator"/>

<a id="AABB_method_get_support"></a>

<!-- classref-method -->

[Vector3](Vector3.md) **get_support**\ (\ direction\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_support)

Returns the vertex's position of this bounding box that's the farthest in the given direction. This point is commonly known as the support point in collision detection algorithms.

<hr class="classref-item-separator"/>

<a id="AABB_method_get_volume"></a>

<!-- classref-method -->

[float](float.md) **get_volume**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_get_volume)

Returns the bounding box's volume. This is equivalent to ``size.x * size.y * size.z``. See also [has_volume()](AABB.md#AABB_method_has_volume).

<hr class="classref-item-separator"/>

<a id="AABB_method_grow"></a>

<!-- classref-method -->

[AABB](AABB.md) **grow**\ (\ by\: [float](float.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_grow)

Returns a copy of this bounding box extended on all sides by the given amount `by`. A negative amount shrinks the box instead.




```gdscript
    var a = AABB(Vector3(4, 4, 4), Vector3(8, 8, 8)).grow(4)
    print(a.position) # Prints (0.0, 0.0, 0.0)
    print(a.size)     # Prints (16.0, 16.0, 16.0)

    var b = AABB(Vector3(0, 0, 0), Vector3(8, 4, 2)).grow(2)
    print(b.position) # Prints (-2.0, -2.0, -2.0)
    print(b.size)     # Prints (12.0, 8.0, 6.0)
```


```csharp
    var a = new Aabb(new Vector3(4, 4, 4), new Vector3(8, 8, 8)).Grow(4);
    GD.Print(a.Position); // Prints (0, 0, 0)
    GD.Print(a.Size);     // Prints (16, 16, 16)

    var b = new Aabb(new Vector3(0, 0, 0), new Vector3(8, 4, 2)).Grow(2);
    GD.Print(b.Position); // Prints (-2, -2, -2)
    GD.Print(b.Size);     // Prints (12, 8, 6)
```




<hr class="classref-item-separator"/>

<a id="AABB_method_has_point"></a>

<!-- classref-method -->

[bool](bool.md) **has_point**\ (\ point\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_has_point)

Returns ``true`` if the bounding box contains the given `point`. By convention, points exactly on the right, top, and front sides are **not** included.

\ **Note:** This method is not reliable for **AABB** with a *negative* [size](AABB.md#AABB_property_size). Use [abs()](AABB.md#AABB_method_abs) first to get a valid bounding box.

<hr class="classref-item-separator"/>

<a id="AABB_method_has_surface"></a>

<!-- classref-method -->

[bool](bool.md) **has_surface**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_has_surface)

Returns ``true`` if this bounding box has a surface or a length, that is, at least one component of [size](AABB.md#AABB_property_size) is greater than ``0``. Otherwise, returns ``false``.

<hr class="classref-item-separator"/>

<a id="AABB_method_has_volume"></a>

<!-- classref-method -->

[bool](bool.md) **has_volume**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_has_volume)

Returns ``true`` if this bounding box's width, height, and depth are all positive. See also [get_volume()](AABB.md#AABB_method_get_volume).

<hr class="classref-item-separator"/>

<a id="AABB_method_intersection"></a>

<!-- classref-method -->

[AABB](AABB.md) **intersection**\ (\ with\: [AABB](AABB.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_intersection)

Returns the intersection between this bounding box and `with`. If the boxes do not intersect, returns an empty **AABB**. If the boxes intersect at the edge, returns a flat **AABB** with no volume (see [has_surface()](AABB.md#AABB_method_has_surface) and [has_volume()](AABB.md#AABB_method_has_volume)).




```gdscript
    var box1 = AABB(Vector3(0, 0, 0), Vector3(5, 2, 8))
    var box2 = AABB(Vector3(2, 0, 2), Vector3(8, 4, 4))

    var intersection = box1.intersection(box2)
    print(intersection.position) # Prints (2.0, 0.0, 2.0)
    print(intersection.size)     # Prints (3.0, 2.0, 4.0)
```


```csharp
    var box1 = new Aabb(new Vector3(0, 0, 0), new Vector3(5, 2, 8));
    var box2 = new Aabb(new Vector3(2, 0, 2), new Vector3(8, 4, 4));

    var intersection = box1.Intersection(box2);
    GD.Print(intersection.Position); // Prints (2, 0, 2)
    GD.Print(intersection.Size);     // Prints (3, 2, 4)
```




\ **Note:** If you only need to know whether two bounding boxes are intersecting, use [intersects()](AABB.md#AABB_method_intersects), instead.

<hr class="classref-item-separator"/>

<a id="AABB_method_intersects"></a>

<!-- classref-method -->

[bool](bool.md) **intersects**\ (\ with\: [AABB](AABB.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_intersects)

Returns ``true`` if this bounding box overlaps with the box `with`. The edges of both boxes are *always* excluded.

<hr class="classref-item-separator"/>

<a id="AABB_method_intersects_plane"></a>

<!-- classref-method -->

[bool](bool.md) **intersects_plane**\ (\ plane\: [Plane](Plane.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_intersects_plane)

Returns ``true`` if this bounding box is on both sides of the given `plane`.

<hr class="classref-item-separator"/>

<a id="AABB_method_intersects_ray"></a>

<!-- classref-method -->

[Variant](Variant.md) **intersects_ray**\ (\ from\: [Vector3](Vector3.md), dir\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_intersects_ray)

Returns the first point where this bounding box and the given ray intersect, as a [Vector3](Vector3.md). If no intersection occurs, returns ``null``.

The ray begin at `from`, faces `dir` and extends towards infinity.

<hr class="classref-item-separator"/>

<a id="AABB_method_intersects_segment"></a>

<!-- classref-method -->

[Variant](Variant.md) **intersects_segment**\ (\ from\: [Vector3](Vector3.md), to\: [Vector3](Vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_intersects_segment)

Returns the first point where this bounding box and the given segment intersect, as a [Vector3](Vector3.md). If no intersection occurs, returns ``null``.

The segment begins at `from` and ends at `to`.

<hr class="classref-item-separator"/>

<a id="AABB_method_is_equal_approx"></a>

<!-- classref-method -->

[bool](bool.md) **is_equal_approx**\ (\ aabb\: [AABB](AABB.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_is_equal_approx)

Returns ``true`` if this bounding box and `aabb` are approximately equal, by calling [Vector3.is_equal_approx()](Vector3.md#Vector3_method_is_equal_approx) on the [position](AABB.md#AABB_property_position) and the [size](AABB.md#AABB_property_size).

<hr class="classref-item-separator"/>

<a id="AABB_method_is_finite"></a>

<!-- classref-method -->

[bool](bool.md) **is_finite**\ (\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_is_finite)

Returns ``true`` if this bounding box's values are finite, by calling [Vector3.is_finite()](Vector3.md#Vector3_method_is_finite) on the [position](AABB.md#AABB_property_position) and the [size](AABB.md#AABB_property_size).

<hr class="classref-item-separator"/>

<a id="AABB_method_merge"></a>

<!-- classref-method -->

[AABB](AABB.md) **merge**\ (\ with\: [AABB](AABB.md)\ ) <span class="const">const</span> [ðŸ”—](#AABB_method_merge)

Returns an **AABB** that encloses both this bounding box and `with` around the edges. See also [encloses()](AABB.md#AABB_method_encloses).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Operator Descriptions

<a id="AABB_operator_neq_AABB"></a>

<!-- classref-operator -->

[bool](bool.md) **operator !=**\ (\ right\: [AABB](AABB.md)\ ) [ðŸ”—](#AABB_operator_neq_AABB)

Returns ``true`` if the [position](AABB.md#AABB_property_position) or [size](AABB.md#AABB_property_size) of both bounding boxes are not equal.

\ **Note:** Due to floating-point precision errors, consider using [is_equal_approx()](AABB.md#AABB_method_is_equal_approx) instead, which is more reliable.

<hr class="classref-item-separator"/>

<a id="AABB_operator_mul_Transform3D"></a>

<!-- classref-operator -->

[AABB](AABB.md) **operator ***\ (\ right\: [Transform3D](Transform3D.md)\ ) [ðŸ”—](#AABB_operator_mul_Transform3D)

Inversely transforms (multiplies) the **AABB** by the given [Transform3D](Transform3D.md) transformation matrix, under the assumption that the transformation basis is orthonormal (i.e. rotation/reflection is fine, scaling/skew is not).

\ ``aabb * transform`` is equivalent to ``transform.inverse() * aabb``. See [Transform3D.inverse()](Transform3D.md#Transform3D_method_inverse).

For transforming by inverse of an affine transformation (e.g. with scaling) ``transform.affine_inverse() * aabb`` can be used instead. See [Transform3D.affine_inverse()](Transform3D.md#Transform3D_method_affine_inverse).

<hr class="classref-item-separator"/>

<a id="AABB_operator_eq_AABB"></a>

<!-- classref-operator -->

[bool](bool.md) **operator ==**\ (\ right\: [AABB](AABB.md)\ ) [ðŸ”—](#AABB_operator_eq_AABB)

Returns ``true`` if both [position](AABB.md#AABB_property_position) and [size](AABB.md#AABB_property_size) of the bounding boxes are exactly equal, respectively.

\ **Note:** Due to floating-point precision errors, consider using [is_equal_approx()](AABB.md#AABB_method_is_equal_approx) instead, which is more reliable.

