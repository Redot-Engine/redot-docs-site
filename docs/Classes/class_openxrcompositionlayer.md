<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/modules/openxr/doc_classes/OpenXRCompositionLayer.xml. -->

<a id="class_OpenXRCompositionLayer"></a>

# OpenXRCompositionLayer

**Experimental:** This class may be changed or removed in future versions.

**Inherits:** [Node3D](class_node3d.md) **<** [Node](class_node.md) **<** [Object](class_object.md)

**Inherited By:** [OpenXRCompositionLayerCylinder](class_openxrcompositionlayercylinder.md), [OpenXRCompositionLayerEquirect](class_openxrcompositionlayerequirect.md), [OpenXRCompositionLayerQuad](class_openxrcompositionlayerquad.md)

The parent class of all OpenXR composition layer nodes.

<!-- classref-introduction-group -->

## Description

Composition layers allow 2D viewports to be displayed inside of the headset by the XR compositor through special projections that retain their quality. This allows for rendering clear text while keeping the layer at a native resolution.

\ **Note:** If the OpenXR runtime doesn't support the given composition layer type, a fallback mesh can be generated with a [ViewportTexture](class_viewporttexture.md), in order to emulate the composition layer.

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[bool](class_bool.md)</th>
      <th>[alpha_blend](#class_OpenXRCompositionLayer_property_alpha_blend)</th>
      <th>`false`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector2i](class_vector2i.md)</td>
      <td>[android_surface_size](#class_OpenXRCompositionLayer_property_android_surface_size)</td>
      <td>`Vector2i(1024, 1024)`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[enable_hole_punch](#class_OpenXRCompositionLayer_property_enable_hole_punch)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[SubViewport](class_subviewport.md)</td>
      <td>[layer_viewport](#class_OpenXRCompositionLayer_property_layer_viewport)</td>
      <td></td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[sort_order](#class_OpenXRCompositionLayer_property_sort_order)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle)</td>
      <td>[swapchain_state_alpha_swizzle](#class_OpenXRCompositionLayer_property_swapchain_state_alpha_swizzle)</td>
      <td>`3`</td>
    </tr>
    <tr>
      <td>[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle)</td>
      <td>[swapchain_state_blue_swizzle](#class_OpenXRCompositionLayer_property_swapchain_state_blue_swizzle)</td>
      <td>`2`</td>
    </tr>
    <tr>
      <td>[Color](class_color.md)</td>
      <td>[swapchain_state_border_color](#class_OpenXRCompositionLayer_property_swapchain_state_border_color)</td>
      <td>`Color(0, 0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle)</td>
      <td>[swapchain_state_green_swizzle](#class_OpenXRCompositionLayer_property_swapchain_state_green_swizzle)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap)</td>
      <td>[swapchain_state_horizontal_wrap](#class_OpenXRCompositionLayer_property_swapchain_state_horizontal_wrap)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter)</td>
      <td>[swapchain_state_mag_filter](#class_OpenXRCompositionLayer_property_swapchain_state_mag_filter)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[swapchain_state_max_anisotropy](#class_OpenXRCompositionLayer_property_swapchain_state_max_anisotropy)</td>
      <td>`1.0`</td>
    </tr>
    <tr>
      <td>[Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter)</td>
      <td>[swapchain_state_min_filter](#class_OpenXRCompositionLayer_property_swapchain_state_min_filter)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[MipmapMode](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_MipmapMode)</td>
      <td>[swapchain_state_mipmap_mode](#class_OpenXRCompositionLayer_property_swapchain_state_mipmap_mode)</td>
      <td>`2`</td>
    </tr>
    <tr>
      <td>[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle)</td>
      <td>[swapchain_state_red_swizzle](#class_OpenXRCompositionLayer_property_swapchain_state_red_swizzle)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap)</td>
      <td>[swapchain_state_vertical_wrap](#class_OpenXRCompositionLayer_property_swapchain_state_vertical_wrap)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[use_android_surface](#class_OpenXRCompositionLayer_property_use_android_surface)</td>
      <td>`false`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[JavaObject](class_javaobject.md)</th>
      <th>[get_android_surface](#class_OpenXRCompositionLayer_method_get_android_surface)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector2](class_vector2.md)</td>
      <td>[intersects_ray](#class_OpenXRCompositionLayer_method_intersects_ray)\ (\ origin\: [Vector3](class_vector3.md), direction\: [Vector3](class_vector3.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_natively_supported](#class_OpenXRCompositionLayer_method_is_natively_supported)\ (\ ) <span class="const">const</span></td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_OpenXRCompositionLayer_Filter"></a>

<!-- classref-enumeration -->

enum **Filter**: [ðŸ”—](#enum_OpenXRCompositionLayer_Filter)

<a id="class_OpenXRCompositionLayer_constant_FILTER_NEAREST"></a>

<!-- classref-enumeration-constant -->

[Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter) **FILTER_NEAREST** = `0`

Perform nearest-neighbor filtering when sampling the texture.<a id="class_OpenXRCompositionLayer_constant_FILTER_LINEAR"></a>

<!-- classref-enumeration-constant -->

[Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter) **FILTER_LINEAR** = `1`

Perform linear filtering when sampling the texture.<a id="class_OpenXRCompositionLayer_constant_FILTER_CUBIC"></a>

<!-- classref-enumeration-constant -->

[Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter) **FILTER_CUBIC** = `2`

Perform cubic filtering when sampling the texture.<hr class="classref-item-separator">

<a id="enum_OpenXRCompositionLayer_MipmapMode"></a>

<!-- classref-enumeration -->

enum **MipmapMode**: [ðŸ”—](#enum_OpenXRCompositionLayer_MipmapMode)

<a id="class_OpenXRCompositionLayer_constant_MIPMAP_MODE_DISABLED"></a>

<!-- classref-enumeration-constant -->

[MipmapMode](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_MipmapMode) **MIPMAP_MODE_DISABLED** = `0`

Disable mipmapping.

\ **Note:** Mipmapping can only be disabled in the Compatibility renderer.<a id="class_OpenXRCompositionLayer_constant_MIPMAP_MODE_NEAREST"></a>

<!-- classref-enumeration-constant -->

[MipmapMode](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_MipmapMode) **MIPMAP_MODE_NEAREST** = `1`

Use the mipmap of the nearest resolution.<a id="class_OpenXRCompositionLayer_constant_MIPMAP_MODE_LINEAR"></a>

<!-- classref-enumeration-constant -->

[MipmapMode](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_MipmapMode) **MIPMAP_MODE_LINEAR** = `2`

Use linear interpolation of the two mipmaps of the nearest resolution.<hr class="classref-item-separator">

<a id="enum_OpenXRCompositionLayer_Wrap"></a>

<!-- classref-enumeration -->

enum **Wrap**: [ðŸ”—](#enum_OpenXRCompositionLayer_Wrap)

<a id="class_OpenXRCompositionLayer_constant_WRAP_CLAMP_TO_BORDER"></a>

<!-- classref-enumeration-constant -->

[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **WRAP_CLAMP_TO_BORDER** = `0`

Clamp the texture to its specified border color.<a id="class_OpenXRCompositionLayer_constant_WRAP_CLAMP_TO_EDGE"></a>

<!-- classref-enumeration-constant -->

[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **WRAP_CLAMP_TO_EDGE** = `1`

Clamp the texture to its edge color.<a id="class_OpenXRCompositionLayer_constant_WRAP_REPEAT"></a>

<!-- classref-enumeration-constant -->

[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **WRAP_REPEAT** = `2`

Repeat the texture infinitely.<a id="class_OpenXRCompositionLayer_constant_WRAP_MIRRORED_REPEAT"></a>

<!-- classref-enumeration-constant -->

[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **WRAP_MIRRORED_REPEAT** = `3`

Repeat the texture infinitely, mirroring it on each repeat.<a id="class_OpenXRCompositionLayer_constant_WRAP_MIRROR_CLAMP_TO_EDGE"></a>

<!-- classref-enumeration-constant -->

[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **WRAP_MIRROR_CLAMP_TO_EDGE** = `4`

Mirror the texture once and then clamp the texture to its edge color.

\ **Note:** This wrap mode is not available in the Compatibility renderer.<hr class="classref-item-separator">

<a id="enum_OpenXRCompositionLayer_Swizzle"></a>

<!-- classref-enumeration -->

enum **Swizzle**: [ðŸ”—](#enum_OpenXRCompositionLayer_Swizzle)

<a id="class_OpenXRCompositionLayer_constant_SWIZZLE_RED"></a>

<!-- classref-enumeration-constant -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **SWIZZLE_RED** = `0`

Maps a color channel to the value of the red channel.<a id="class_OpenXRCompositionLayer_constant_SWIZZLE_GREEN"></a>

<!-- classref-enumeration-constant -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **SWIZZLE_GREEN** = `1`

Maps a color channel to the value of the green channel.<a id="class_OpenXRCompositionLayer_constant_SWIZZLE_BLUE"></a>

<!-- classref-enumeration-constant -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **SWIZZLE_BLUE** = `2`

Maps a color channel to the value of the blue channel.<a id="class_OpenXRCompositionLayer_constant_SWIZZLE_ALPHA"></a>

<!-- classref-enumeration-constant -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **SWIZZLE_ALPHA** = `3`

Maps a color channel to the value of the alpha channel.<a id="class_OpenXRCompositionLayer_constant_SWIZZLE_ZERO"></a>

<!-- classref-enumeration-constant -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **SWIZZLE_ZERO** = `4`

Maps a color channel to the value of zero.<a id="class_OpenXRCompositionLayer_constant_SWIZZLE_ONE"></a>

<!-- classref-enumeration-constant -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **SWIZZLE_ONE** = `5`

Maps a color channel to the value of one.<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_OpenXRCompositionLayer_property_alpha_blend"></a>

<!-- classref-property -->

[bool](class_bool.md) **alpha_blend** = `false` [ðŸ”—](#class_OpenXRCompositionLayer_property_alpha_blend)

<!-- classref-property-setget -->

- `void` **set_alpha_blend**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **get_alpha_blend**\ (\ )

Enables the blending the layer using its alpha channel.

Can be combined with [Viewport.transparent_bg](class_viewport.md#class_Viewport_property_transparent_bg) to give the layer a transparent background.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_android_surface_size"></a>

<!-- classref-property -->

[Vector2i](class_vector2i.md) **android_surface_size** = `Vector2i(1024, 1024)` [ðŸ”—](#class_OpenXRCompositionLayer_property_android_surface_size)

<!-- classref-property-setget -->

- `void` **set_android_surface_size**\ (\ value\: [Vector2i](class_vector2i.md)\ )
- [Vector2i](class_vector2i.md) **get_android_surface_size**\ (\ )

The size of the Android surface to create if [use_android_surface](class_openxrcompositionlayer.md#class_OpenXRCompositionLayer_property_use_android_surface) is enabled.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_enable_hole_punch"></a>

<!-- classref-property -->

[bool](class_bool.md) **enable_hole_punch** = `false` [ðŸ”—](#class_OpenXRCompositionLayer_property_enable_hole_punch)

<!-- classref-property-setget -->

- `void` **set_enable_hole_punch**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **get_enable_hole_punch**\ (\ )

Enables a technique called "hole punching", which allows putting the composition layer behind the main projection layer (i.e. setting [sort_order](class_openxrcompositionlayer.md#class_OpenXRCompositionLayer_property_sort_order) to a negative value) while "punching a hole" through everything rendered by Redot so that the layer is still visible.

This can be used to create the illusion that the composition layer exists in the same 3D space as everything rendered by Redot, allowing objects to appear to pass both behind or in front of the composition layer.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_layer_viewport"></a>

<!-- classref-property -->

[SubViewport](class_subviewport.md) **layer_viewport** [ðŸ”—](#class_OpenXRCompositionLayer_property_layer_viewport)

<!-- classref-property-setget -->

- `void` **set_layer_viewport**\ (\ value\: [SubViewport](class_subviewport.md)\ )
- [SubViewport](class_subviewport.md) **get_layer_viewport**\ (\ )

The [SubViewport](class_subviewport.md) to render on the composition layer.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_sort_order"></a>

<!-- classref-property -->

[int](class_int.md) **sort_order** = `1` [ðŸ”—](#class_OpenXRCompositionLayer_property_sort_order)

<!-- classref-property-setget -->

- `void` **set_sort_order**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_sort_order**\ (\ )

The sort order for this composition layer. Higher numbers will be shown in front of lower numbers.

\ **Note:** This will have no effect if a fallback mesh is being used.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_alpha_swizzle"></a>

<!-- classref-property -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **swapchain_state_alpha_swizzle** = `3` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_alpha_swizzle)

<!-- classref-property-setget -->

- `void` **set_alpha_swizzle**\ (\ value\: [Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle)\ )
- [Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **get_alpha_swizzle**\ (\ )

The swizzle value for the alpha channel of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_blue_swizzle"></a>

<!-- classref-property -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **swapchain_state_blue_swizzle** = `2` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_blue_swizzle)

<!-- classref-property-setget -->

- `void` **set_blue_swizzle**\ (\ value\: [Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle)\ )
- [Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **get_blue_swizzle**\ (\ )

The swizzle value for the blue channel of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_border_color"></a>

<!-- classref-property -->

[Color](class_color.md) **swapchain_state_border_color** = `Color(0, 0, 0, 0)` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_border_color)

<!-- classref-property-setget -->

- `void` **set_border_color**\ (\ value\: [Color](class_color.md)\ )
- [Color](class_color.md) **get_border_color**\ (\ )

The border color of the swapchain state that is used when the wrap mode clamps to the border.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_green_swizzle"></a>

<!-- classref-property -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **swapchain_state_green_swizzle** = `1` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_green_swizzle)

<!-- classref-property-setget -->

- `void` **set_green_swizzle**\ (\ value\: [Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle)\ )
- [Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **get_green_swizzle**\ (\ )

The swizzle value for the green channel of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_horizontal_wrap"></a>

<!-- classref-property -->

[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **swapchain_state_horizontal_wrap** = `0` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_horizontal_wrap)

<!-- classref-property-setget -->

- `void` **set_horizontal_wrap**\ (\ value\: [Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap)\ )
- [Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **get_horizontal_wrap**\ (\ )

The horizontal wrap mode of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_mag_filter"></a>

<!-- classref-property -->

[Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter) **swapchain_state_mag_filter** = `1` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_mag_filter)

<!-- classref-property-setget -->

- `void` **set_mag_filter**\ (\ value\: [Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter)\ )
- [Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter) **get_mag_filter**\ (\ )

The magnification filter of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_max_anisotropy"></a>

<!-- classref-property -->

[float](class_float.md) **swapchain_state_max_anisotropy** = `1.0` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_max_anisotropy)

<!-- classref-property-setget -->

- `void` **set_max_anisotropy**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_max_anisotropy**\ (\ )

The max anisotropy of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_min_filter"></a>

<!-- classref-property -->

[Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter) **swapchain_state_min_filter** = `1` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_min_filter)

<!-- classref-property-setget -->

- `void` **set_min_filter**\ (\ value\: [Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter)\ )
- [Filter](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Filter) **get_min_filter**\ (\ )

The minification filter of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_mipmap_mode"></a>

<!-- classref-property -->

[MipmapMode](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_MipmapMode) **swapchain_state_mipmap_mode** = `2` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_mipmap_mode)

<!-- classref-property-setget -->

- `void` **set_mipmap_mode**\ (\ value\: [MipmapMode](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_MipmapMode)\ )
- [MipmapMode](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_MipmapMode) **get_mipmap_mode**\ (\ )

The mipmap mode of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_red_swizzle"></a>

<!-- classref-property -->

[Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **swapchain_state_red_swizzle** = `0` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_red_swizzle)

<!-- classref-property-setget -->

- `void` **set_red_swizzle**\ (\ value\: [Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle)\ )
- [Swizzle](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Swizzle) **get_red_swizzle**\ (\ )

The swizzle value for the red channel of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_swapchain_state_vertical_wrap"></a>

<!-- classref-property -->

[Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **swapchain_state_vertical_wrap** = `0` [ðŸ”—](#class_OpenXRCompositionLayer_property_swapchain_state_vertical_wrap)

<!-- classref-property-setget -->

- `void` **set_vertical_wrap**\ (\ value\: [Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap)\ )
- [Wrap](class_openxrcompositionlayer.md#enum_OpenXRCompositionLayer_Wrap) **get_vertical_wrap**\ (\ )

The vertical wrap mode of the swapchain state.

\ **Note:** This property only has an effect on devices that support the OpenXR XR_FB_swapchain_update_state OpenGLES/Vulkan extensions.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_property_use_android_surface"></a>

<!-- classref-property -->

[bool](class_bool.md) **use_android_surface** = `false` [ðŸ”—](#class_OpenXRCompositionLayer_property_use_android_surface)

<!-- classref-property-setget -->

- `void` **set_use_android_surface**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **get_use_android_surface**\ (\ )

If enabled, an Android surface will be created (with the dimensions from [android_surface_size](class_openxrcompositionlayer.md#class_OpenXRCompositionLayer_property_android_surface_size)) which will provide the 2D content for the composition layer, rather than using [layer_viewport](class_openxrcompositionlayer.md#class_OpenXRCompositionLayer_property_layer_viewport).

See [get_android_surface()](class_openxrcompositionlayer.md#class_OpenXRCompositionLayer_method_get_android_surface) for information about how to get the surface so that your application can draw to it.

\ **Note:** This will only work in Android builds.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_OpenXRCompositionLayer_method_get_android_surface"></a>

<!-- classref-method -->

[JavaObject](class_javaobject.md) **get_android_surface**\ (\ ) [ðŸ”—](#class_OpenXRCompositionLayer_method_get_android_surface)

Returns a [JavaObject](class_javaobject.md) representing an ``android.view.Surface`` if [use_android_surface](class_openxrcompositionlayer.md#class_OpenXRCompositionLayer_property_use_android_surface) is enabled and OpenXR has created the surface. Otherwise, this will return ``null``.

\ **Note:** The surface can only be created during an active OpenXR session. So, if [use_android_surface](class_openxrcompositionlayer.md#class_OpenXRCompositionLayer_property_use_android_surface) is enabled outside of an OpenXR session, it won't be created until a new session fully starts.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_method_intersects_ray"></a>

<!-- classref-method -->

[Vector2](class_vector2.md) **intersects_ray**\ (\ origin\: [Vector3](class_vector3.md), direction\: [Vector3](class_vector3.md)\ ) <span class="const">const</span> [ðŸ”—](#class_OpenXRCompositionLayer_method_intersects_ray)

Returns UV coordinates where the given ray intersects with the composition layer. `origin` and `direction` must be in global space.

Returns ``Vector2(-1.0, -1.0)`` if the ray doesn't intersect.

<hr class="classref-item-separator">

<a id="class_OpenXRCompositionLayer_method_is_natively_supported"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_natively_supported**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_OpenXRCompositionLayer_method_is_natively_supported)

Returns ``true`` if the OpenXR runtime natively supports this composition layer type.

\ **Note:** This will only return an accurate result after the OpenXR session has started.

