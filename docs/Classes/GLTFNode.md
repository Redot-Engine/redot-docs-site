<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/modules/gltf/doc_classes/GLTFNode.xml. -->

<a id="GLTFNode"></a>

# GLTFNode

**Inherits:** [Resource](Resource.md) **\<** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

glTF node class.

<!-- classref-introduction-group -->

## Description

Represents a glTF node. glTF nodes may have names, transforms, children (other glTF nodes), and more specialized properties (represented by their own classes).

glTF nodes generally exist inside of [GLTFState](GLTFState.md) which represents all data of a glTF file. Most of GLTFNode's properties are indices of other data in the glTF file. You can extend a glTF node with additional properties by using [get_additional_data()](GLTFNode.md#GLTFNode_method_get_additional_data) and [set_additional_data()](GLTFNode.md#GLTFNode_method_set_additional_data).

<!-- classref-introduction-group -->

## Tutorials

- [Runtime file loading and saving](../tutorials/io/runtime_file_loading_and_saving.md)

- [glTF scene and node spec](https://github.com/KhronosGroup/glTF-Tutorials/blob/master/gltfTutorial/gltfTutorial_004_ScenesNodes.md")

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[int](int.md)</th>
      <th>[camera](#GLTFNode_property_camera)</th>
      <th>`-1`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[PackedInt32Array](PackedInt32Array.md)</td>
      <td>[children](#GLTFNode_property_children)</td>
      <td>`PackedInt32Array()`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[height](#GLTFNode_property_height)</td>
      <td>`-1`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[light](#GLTFNode_property_light)</td>
      <td>`-1`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[mesh](#GLTFNode_property_mesh)</td>
      <td>`-1`</td>
    </tr>
    <tr>
      <td>[String](String.md)</td>
      <td>[original_name](#GLTFNode_property_original_name)</td>
      <td>`""`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[parent](#GLTFNode_property_parent)</td>
      <td>`-1`</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[position](#GLTFNode_property_position)</td>
      <td>`Vector3(0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[Quaternion](Quaternion.md)</td>
      <td>[rotation](#GLTFNode_property_rotation)</td>
      <td>`Quaternion(0, 0, 0, 1)`</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[scale](#GLTFNode_property_scale)</td>
      <td>`Vector3(1, 1, 1)`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[skeleton](#GLTFNode_property_skeleton)</td>
      <td>`-1`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[skin](#GLTFNode_property_skin)</td>
      <td>`-1`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[visible](#GLTFNode_property_visible)</td>
      <td>`true`</td>
    </tr>
    <tr>
      <td>[Transform3D](Transform3D.md)</td>
      <td>[xform](#GLTFNode_property_xform)</td>
      <td>`Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>`void`</th>
      <th>[append_child_index](#GLTFNode_method_append_child_index)\ (\ child_index\: [int](int.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[get_additional_data](#GLTFNode_method_get_additional_data)\ (\ extension_name\: [StringName](StringName.md)\ )</td>
    </tr>
    <tr>
      <td>[NodePath](NodePath.md)</td>
      <td>[get_scene_node_path](#GLTFNode_method_get_scene_node_path)\ (\ gltf_state\: [GLTFState](GLTFState.md), handle_skeletons\: [bool](bool.md) = true\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_additional_data](#GLTFNode_method_set_additional_data)\ (\ extension_name\: [StringName](StringName.md), additional_data\: [Variant](Variant.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="GLTFNode_property_camera"></a>

<!-- classref-property -->

[int](int.md) **camera** = `-1` [ðŸ”—](#GLTFNode_property_camera)

<!-- classref-property-setget -->

- `void` **set_camera**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_camera**\ (\ )

If this glTF node is a camera, the index of the [GLTFCamera](GLTFCamera.md) in the [GLTFState](GLTFState.md) that describes the camera's properties. If ``-1``, this node is not a camera.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_children"></a>

<!-- classref-property -->

[PackedInt32Array](PackedInt32Array.md) **children** = `PackedInt32Array()` [ðŸ”—](#GLTFNode_property_children)

<!-- classref-property-setget -->

- `void` **set_children**\ (\ value\: [PackedInt32Array](PackedInt32Array.md)\ )
- [PackedInt32Array](PackedInt32Array.md) **get_children**\ (\ )

The indices of the child nodes in the [GLTFState](GLTFState.md). If this glTF node has no children, this will be an empty array.

**Note:** The returned array is *copied* and any changes to it will not update the original property value. See [PackedInt32Array](PackedInt32Array.md) for more details.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_height"></a>

<!-- classref-property -->

[int](int.md) **height** = `-1` [ðŸ”—](#GLTFNode_property_height)

<!-- classref-property-setget -->

- `void` **set_height**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_height**\ (\ )

How deep into the node hierarchy this node is. A root node will have a height of 0, its children will have a height of 1, and so on. If -1, the height has not been calculated.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_light"></a>

<!-- classref-property -->

[int](int.md) **light** = `-1` [ðŸ”—](#GLTFNode_property_light)

<!-- classref-property-setget -->

- `void` **set_light**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_light**\ (\ )

If this glTF node is a light, the index of the [GLTFLight](GLTFLight.md) in the [GLTFState](GLTFState.md) that describes the light's properties. If -1, this node is not a light.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_mesh"></a>

<!-- classref-property -->

[int](int.md) **mesh** = `-1` [ðŸ”—](#GLTFNode_property_mesh)

<!-- classref-property-setget -->

- `void` **set_mesh**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_mesh**\ (\ )

If this glTF node is a mesh, the index of the [GLTFMesh](GLTFMesh.md) in the [GLTFState](GLTFState.md) that describes the mesh's properties. If -1, this node is not a mesh.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_original_name"></a>

<!-- classref-property -->

[String](String.md) **original_name** = `""` [ðŸ”—](#GLTFNode_property_original_name)

<!-- classref-property-setget -->

- `void` **set_original_name**\ (\ value\: [String](String.md)\ )
- [String](String.md) **get_original_name**\ (\ )

The original name of the node.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_parent"></a>

<!-- classref-property -->

[int](int.md) **parent** = `-1` [ðŸ”—](#GLTFNode_property_parent)

<!-- classref-property-setget -->

- `void` **set_parent**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_parent**\ (\ )

The index of the parent node in the [GLTFState](GLTFState.md). If -1, this node is a root node.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_position"></a>

<!-- classref-property -->

[Vector3](Vector3.md) **position** = `Vector3(0, 0, 0)` [ðŸ”—](#GLTFNode_property_position)

<!-- classref-property-setget -->

- `void` **set_position**\ (\ value\: [Vector3](Vector3.md)\ )
- [Vector3](Vector3.md) **get_position**\ (\ )

The position of the glTF node relative to its parent.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_rotation"></a>

<!-- classref-property -->

[Quaternion](Quaternion.md) **rotation** = `Quaternion(0, 0, 0, 1)` [ðŸ”—](#GLTFNode_property_rotation)

<!-- classref-property-setget -->

- `void` **set_rotation**\ (\ value\: [Quaternion](Quaternion.md)\ )
- [Quaternion](Quaternion.md) **get_rotation**\ (\ )

The rotation of the glTF node relative to its parent.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_scale"></a>

<!-- classref-property -->

[Vector3](Vector3.md) **scale** = `Vector3(1, 1, 1)` [ðŸ”—](#GLTFNode_property_scale)

<!-- classref-property-setget -->

- `void` **set_scale**\ (\ value\: [Vector3](Vector3.md)\ )
- [Vector3](Vector3.md) **get_scale**\ (\ )

The scale of the glTF node relative to its parent.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_skeleton"></a>

<!-- classref-property -->

[int](int.md) **skeleton** = `-1` [ðŸ”—](#GLTFNode_property_skeleton)

<!-- classref-property-setget -->

- `void` **set_skeleton**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_skeleton**\ (\ )

If this glTF node has a skeleton, the index of the [GLTFSkeleton](GLTFSkeleton.md) in the [GLTFState](GLTFState.md) that describes the skeleton's properties. If -1, this node does not have a skeleton.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_skin"></a>

<!-- classref-property -->

[int](int.md) **skin** = `-1` [ðŸ”—](#GLTFNode_property_skin)

<!-- classref-property-setget -->

- `void` **set_skin**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_skin**\ (\ )

If this glTF node has a skin, the index of the [GLTFSkin](GLTFSkin.md) in the [GLTFState](GLTFState.md) that describes the skin's properties. If -1, this node does not have a skin.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_visible"></a>

<!-- classref-property -->

[bool](bool.md) **visible** = `true` [ðŸ”—](#GLTFNode_property_visible)

<!-- classref-property-setget -->

- `void` **set_visible**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_visible**\ (\ )

If ``true``, the GLTF node is visible. If ``false``, the GLTF node is not visible. This is translated to the [Node3D.visible](Node3D.md#Node3D_property_visible) property in the Redot scene, and is exported to ``KHR_node_visibility`` when ``false``.

<hr class="classref-item-separator"/>

<a id="GLTFNode_property_xform"></a>

<!-- classref-property -->

[Transform3D](Transform3D.md) **xform** = `Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)` [ðŸ”—](#GLTFNode_property_xform)

<!-- classref-property-setget -->

- `void` **set_xform**\ (\ value\: [Transform3D](Transform3D.md)\ )
- [Transform3D](Transform3D.md) **get_xform**\ (\ )

The transform of the glTF node relative to its parent. This property is usually unused since the position, rotation, and scale properties are preferred.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="GLTFNode_method_append_child_index"></a>

<!-- classref-method -->

`void` **append_child_index**\ (\ child_index\: [int](int.md)\ ) [ðŸ”—](#GLTFNode_method_append_child_index)

Appends the given child node index to the [children](GLTFNode.md#GLTFNode_property_children) array.

<hr class="classref-item-separator"/>

<a id="GLTFNode_method_get_additional_data"></a>

<!-- classref-method -->

[Variant](Variant.md) **get_additional_data**\ (\ extension_name\: [StringName](StringName.md)\ ) [ðŸ”—](#GLTFNode_method_get_additional_data)

Gets additional arbitrary data in this **GLTFNode** instance. This can be used to keep per-node state data in [GLTFDocumentExtension](GLTFDocumentExtension.md) classes, which is important because they are stateless.

The argument should be the [GLTFDocumentExtension](GLTFDocumentExtension.md) name (does not have to match the extension name in the glTF file), and the return value can be anything you set. If nothing was set, the return value is ``null``.

<hr class="classref-item-separator"/>

<a id="GLTFNode_method_get_scene_node_path"></a>

<!-- classref-method -->

[NodePath](NodePath.md) **get_scene_node_path**\ (\ gltf_state\: [GLTFState](GLTFState.md), handle_skeletons\: [bool](bool.md) = true\ ) [ðŸ”—](#GLTFNode_method_get_scene_node_path)

Returns the [NodePath](NodePath.md) that this GLTF node will have in the Redot scene tree after being imported. This is useful when importing glTF object model pointers with [GLTFObjectModelProperty](GLTFObjectModelProperty.md), for handling extensions such as ``KHR_animation_pointer`` or ``KHR_interactivity``.

If `handle_skeletons` is ``true``, paths to skeleton bone glTF nodes will be resolved properly. For example, a path that would be ``^"A/B/C/Bone1/Bone2/Bone3"`` if ``false`` will become ``^"A/B/C/Skeleton3D:Bone3"``.

<hr class="classref-item-separator"/>

<a id="GLTFNode_method_set_additional_data"></a>

<!-- classref-method -->

`void` **set_additional_data**\ (\ extension_name\: [StringName](StringName.md), additional_data\: [Variant](Variant.md)\ ) [ðŸ”—](#GLTFNode_method_set_additional_data)

Sets additional arbitrary data in this **GLTFNode** instance. This can be used to keep per-node state data in [GLTFDocumentExtension](GLTFDocumentExtension.md) classes, which is important because they are stateless.

The first argument should be the [GLTFDocumentExtension](GLTFDocumentExtension.md) name (does not have to match the extension name in the glTF file), and the second argument can be anything you want.

