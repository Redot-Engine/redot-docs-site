<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/AESContext.xml. -->

<a id="AESContext"></a>

# AESContext

**Inherits:** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

Provides access to AES encryption/decryption of raw data.

<!-- classref-introduction-group -->

## Description

This class holds the context information required for encryption and decryption operations with AES (Advanced Encryption Standard). Both AES-ECB and AES-CBC modes are supported.




```gdscript
    extends Node

    var aes = AESContext.new()

    func _ready():
        var key = "My secret key!!!" # Key must be either 16 or 32 bytes.
        var data = "My secret text!!" # Data size must be multiple of 16 bytes, apply padding if needed.
        # Encrypt ECB
        aes.start(AESContext.MODE_ECB_ENCRYPT, key.to_utf8_buffer())
        var encrypted = aes.update(data.to_utf8_buffer())
        aes.finish()
        # Decrypt ECB
        aes.start(AESContext.MODE_ECB_DECRYPT, key.to_utf8_buffer())
        var decrypted = aes.update(encrypted)
        aes.finish()
        # Check ECB
        assert(decrypted == data.to_utf8_buffer())

        var iv = "My secret iv!!!!" # IV must be of exactly 16 bytes.
        # Encrypt CBC
        aes.start(AESContext.MODE_CBC_ENCRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
        encrypted = aes.update(data.to_utf8_buffer())
        aes.finish()
        # Decrypt CBC
        aes.start(AESContext.MODE_CBC_DECRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
        decrypted = aes.update(encrypted)
        aes.finish()
        # Check CBC
        assert(decrypted == data.to_utf8_buffer())
```


```csharp
    using Godot;
    using System.Diagnostics;

    public partial class MyNode : Node
    {
        private AesContext _aes = new AesContext();

        public override void _Ready()
        {
            string key = "My secret key!!!"; // Key must be either 16 or 32 bytes.
            string data = "My secret text!!"; // Data size must be multiple of 16 bytes, apply padding if needed.
            // Encrypt ECB
            _aes.Start(AesContext.Mode.EcbEncrypt, key.ToUtf8Buffer());
            byte[] encrypted = _aes.Update(data.ToUtf8Buffer());
            _aes.Finish();
            // Decrypt ECB
            _aes.Start(AesContext.Mode.EcbDecrypt, key.ToUtf8Buffer());
            byte[] decrypted = _aes.Update(encrypted);
            _aes.Finish();
            // Check ECB
            Debug.Assert(decrypted == data.ToUtf8Buffer());

            string iv = "My secret iv!!!!"; // IV must be of exactly 16 bytes.
            // Encrypt CBC
            _aes.Start(AesContext.Mode.EcbEncrypt, key.ToUtf8Buffer(), iv.ToUtf8Buffer());
            encrypted = _aes.Update(data.ToUtf8Buffer());
            _aes.Finish();
            // Decrypt CBC
            _aes.Start(AesContext.Mode.EcbDecrypt, key.ToUtf8Buffer(), iv.ToUtf8Buffer());
            decrypted = _aes.Update(encrypted);
            _aes.Finish();
            // Check CBC
            Debug.Assert(decrypted == data.ToUtf8Buffer());
        }
    }
```




<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>`void`</th>
      <th>[finish](#AESContext_method_finish)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[PackedByteArray](PackedByteArray.md)</td>
      <td>[get_iv_state](#AESContext_method_get_iv_state)\ (\ )</td>
    </tr>
    <tr>
      <td>[Error](@GlobalScope.md#enum_@GlobalScope_Error)</td>
      <td>[start](#AESContext_method_start)\ (\ mode\: [Mode](AESContext.md#enum_AESContext_Mode), key\: [PackedByteArray](PackedByteArray.md), iv\: [PackedByteArray](PackedByteArray.md) = PackedByteArray()\ )</td>
    </tr>
    <tr>
      <td>[PackedByteArray](PackedByteArray.md)</td>
      <td>[update](#AESContext_method_update)\ (\ src\: [PackedByteArray](PackedByteArray.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_AESContext_Mode"></a>

<!-- classref-enumeration -->

enum **Mode**: [ðŸ”—](#enum_AESContext_Mode)

<a id="AESContext_constant_MODE_ECB_ENCRYPT"></a>

<!-- classref-enumeration-constant -->

[Mode](AESContext.md#enum_AESContext_Mode) **MODE_ECB_ENCRYPT** = `0`

AES electronic codebook encryption mode.<a id="AESContext_constant_MODE_ECB_DECRYPT"></a>

<!-- classref-enumeration-constant -->

[Mode](AESContext.md#enum_AESContext_Mode) **MODE_ECB_DECRYPT** = `1`

AES electronic codebook decryption mode.<a id="AESContext_constant_MODE_CBC_ENCRYPT"></a>

<!-- classref-enumeration-constant -->

[Mode](AESContext.md#enum_AESContext_Mode) **MODE_CBC_ENCRYPT** = `2`

AES cipher blocker chaining encryption mode.<a id="AESContext_constant_MODE_CBC_DECRYPT"></a>

<!-- classref-enumeration-constant -->

[Mode](AESContext.md#enum_AESContext_Mode) **MODE_CBC_DECRYPT** = `3`

AES cipher blocker chaining decryption mode.<a id="AESContext_constant_MODE_MAX"></a>

<!-- classref-enumeration-constant -->

[Mode](AESContext.md#enum_AESContext_Mode) **MODE_MAX** = `4`

Maximum value for the mode enum.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="AESContext_method_finish"></a>

<!-- classref-method -->

`void` **finish**\ (\ ) [ðŸ”—](#AESContext_method_finish)

Close this AES context so it can be started again. See [start()](AESContext.md#AESContext_method_start).

<hr class="classref-item-separator"/>

<a id="AESContext_method_get_iv_state"></a>

<!-- classref-method -->

[PackedByteArray](PackedByteArray.md) **get_iv_state**\ (\ ) [ðŸ”—](#AESContext_method_get_iv_state)

Get the current IV state for this context (IV gets updated when calling [update()](AESContext.md#AESContext_method_update)). You normally don't need this function.

\ **Note:** This function only makes sense when the context is started with [MODE_CBC_ENCRYPT](AESContext.md#AESContext_constant_MODE_CBC_ENCRYPT) or [MODE_CBC_DECRYPT](AESContext.md#AESContext_constant_MODE_CBC_DECRYPT).

<hr class="classref-item-separator"/>

<a id="AESContext_method_start"></a>

<!-- classref-method -->

[Error](@GlobalScope.md#enum_@GlobalScope_Error) **start**\ (\ mode\: [Mode](AESContext.md#enum_AESContext_Mode), key\: [PackedByteArray](PackedByteArray.md), iv\: [PackedByteArray](PackedByteArray.md) = PackedByteArray()\ ) [ðŸ”—](#AESContext_method_start)

Start the AES context in the given `mode`. A `key` of either 16 or 32 bytes must always be provided, while an `iv` (initialization vector) of exactly 16 bytes, is only needed when `mode` is either [MODE_CBC_ENCRYPT](AESContext.md#AESContext_constant_MODE_CBC_ENCRYPT) or [MODE_CBC_DECRYPT](AESContext.md#AESContext_constant_MODE_CBC_DECRYPT).

<hr class="classref-item-separator"/>

<a id="AESContext_method_update"></a>

<!-- classref-method -->

[PackedByteArray](PackedByteArray.md) **update**\ (\ src\: [PackedByteArray](PackedByteArray.md)\ ) [ðŸ”—](#AESContext_method_update)

Run the desired operation for this AES context. Will return a [PackedByteArray](PackedByteArray.md) containing the result of encrypting (or decrypting) the given `src`. See [start()](AESContext.md#AESContext_method_start) for mode of operation.

\ **Note:** The size of `src` must be a multiple of 16. Apply some padding if needed.

