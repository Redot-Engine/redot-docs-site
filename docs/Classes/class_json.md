<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/JSON.xml. -->

<a id="class_JSON"></a>

# JSON

**Inherits:** [Resource](class_resource.md) **<** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

Helper class for creating and parsing JSON data.

<!-- classref-introduction-group -->

## Description

The **JSON** class enables all data types to be converted to and from a JSON string. This is useful for serializing data, e.g. to save to a file or send over the network.

\ [stringify()](class_json.md#class_JSON_method_stringify) is used to convert any data type into a JSON string.

\ [parse()](class_json.md#class_JSON_method_parse) is used to convert any existing JSON data into a [Variant](class_variant.md) that can be used within Redot. If successfully parsed, use [data](class_json.md#class_JSON_property_data) to retrieve the [Variant](class_variant.md), and use [@GlobalScope.typeof()](class_@globalscope.md#class_@GlobalScope_method_typeof) to check if the Variant's type is what you expect. JSON Objects are converted into a [Dictionary](class_dictionary.md), but JSON data can be used to store [Array](class_array.md)\ s, numbers, [String](class_string.md)\ s and even just a boolean.

```
    var data_to_send = ["a", "b", "c"]
    var json_string = JSON.stringify(data_to_send)
    # Save data
    # ...
    # Retrieve data
    var json = JSON.new()
    var error = json.parse(json_string)
    if error == OK:
        var data_received = json.data
        if typeof(data_received) == TYPE_ARRAY:
            print(data_received) # Prints the array.
        else:
            print("Unexpected data")
    else:
        print("JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
```

Alternatively, you can parse strings using the static [parse_string()](class_json.md#class_JSON_method_parse_string) method, but it doesn't handle errors.

```
    var data = JSON.parse_string(json_string) # Returns null if parsing failed.
```

\ **Note:** Both parse methods do not fully comply with the JSON specification:

- Trailing commas in arrays or objects are ignored, instead of causing a parser error.

- New line and tab characters are accepted in string literals, and are treated like their corresponding escape sequences ``\n`` and ``\t``.

- Numbers are parsed using [String.to_float()](class_string.md#class_String_method_to_float) which is generally more lax than the JSON specification.

- Certain errors, such as invalid Unicode sequences, do not cause a parser error. Instead, the string is cleaned up and an error is logged to the console.

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[Variant](class_variant.md)</th>
      <th>[data](#class_JSON_property_data)</th>
      <th>`null`</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Variant](class_variant.md)</th>
      <th>[from_native](#class_JSON_method_from_native)\ (\ variant\: [Variant](class_variant.md), full_objects\: [bool](class_bool.md) = false\ ) <span class="static">static</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[get_error_line](#class_JSON_method_get_error_line)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](class_string.md)</td>
      <td>[get_error_message](#class_JSON_method_get_error_message)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[String](class_string.md)</td>
      <td>[get_parsed_text](#class_JSON_method_get_parsed_text)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[parse](#class_JSON_method_parse)\ (\ json_text\: [String](class_string.md), keep_text\: [bool](class_bool.md) = false\ )</td>
    </tr>
    <tr>
      <td>[Variant](class_variant.md)</td>
      <td>[parse_string](#class_JSON_method_parse_string)\ (\ json_string\: [String](class_string.md)\ ) <span class="static">static</span></td>
    </tr>
    <tr>
      <td>[String](class_string.md)</td>
      <td>[stringify](#class_JSON_method_stringify)\ (\ data\: [Variant](class_variant.md), indent\: [String](class_string.md) = "", sort_keys\: [bool](class_bool.md) = true, full_precision\: [bool](class_bool.md) = false\ ) <span class="static">static</span></td>
    </tr>
    <tr>
      <td>[Variant](class_variant.md)</td>
      <td>[to_native](#class_JSON_method_to_native)\ (\ json\: [Variant](class_variant.md), allow_objects\: [bool](class_bool.md) = false\ ) <span class="static">static</span></td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_JSON_property_data"></a>

<!-- classref-property -->

[Variant](class_variant.md) **data** = `null` [ðŸ”—](#class_JSON_property_data)

<!-- classref-property-setget -->

- `void` **set_data**\ (\ value\: [Variant](class_variant.md)\ )
- [Variant](class_variant.md) **get_data**\ (\ )

Contains the parsed JSON data in [Variant](class_variant.md) form.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_JSON_method_from_native"></a>

<!-- classref-method -->

[Variant](class_variant.md) **from_native**\ (\ variant\: [Variant](class_variant.md), full_objects\: [bool](class_bool.md) = false\ ) <span class="static">static</span> [ðŸ”—](#class_JSON_method_from_native)

Converts a native engine type to a JSON-compliant value.

By default, objects are ignored for security reasons, unless `full_objects` is ``true``.

You can convert a native value to a JSON string like this:

```
    func encode_data(value, full_objects = false):
        return JSON.stringify(JSON.from_native(value, full_objects))
```

<hr class="classref-item-separator">

<a id="class_JSON_method_get_error_line"></a>

<!-- classref-method -->

[int](class_int.md) **get_error_line**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_JSON_method_get_error_line)

Returns ``0`` if the last call to [parse()](class_json.md#class_JSON_method_parse) was successful, or the line number where the parse failed.

<hr class="classref-item-separator">

<a id="class_JSON_method_get_error_message"></a>

<!-- classref-method -->

[String](class_string.md) **get_error_message**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_JSON_method_get_error_message)

Returns an empty string if the last call to [parse()](class_json.md#class_JSON_method_parse) was successful, or the error message if it failed.

<hr class="classref-item-separator">

<a id="class_JSON_method_get_parsed_text"></a>

<!-- classref-method -->

[String](class_string.md) **get_parsed_text**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_JSON_method_get_parsed_text)

Return the text parsed by [parse()](class_json.md#class_JSON_method_parse) (requires passing ``keep_text`` to [parse()](class_json.md#class_JSON_method_parse)).

<hr class="classref-item-separator">

<a id="class_JSON_method_parse"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **parse**\ (\ json_text\: [String](class_string.md), keep_text\: [bool](class_bool.md) = false\ ) [ðŸ”—](#class_JSON_method_parse)

Attempts to parse the `json_text` provided.

Returns an [Error](class_@globalscope.md#enum_@GlobalScope_Error). If the parse was successful, it returns [@GlobalScope.OK](class_@globalscope.md#class_@GlobalScope_constant_OK) and the result can be retrieved using [data](class_json.md#class_JSON_property_data). If unsuccessful, use [get_error_line()](class_json.md#class_JSON_method_get_error_line) and [get_error_message()](class_json.md#class_JSON_method_get_error_message) to identify the source of the failure.

Non-static variant of [parse_string()](class_json.md#class_JSON_method_parse_string), if you want custom error handling.

The optional `keep_text` argument instructs the parser to keep a copy of the original text. This text can be obtained later by using the [get_parsed_text()](class_json.md#class_JSON_method_get_parsed_text) function and is used when saving the resource (instead of generating new text from [data](class_json.md#class_JSON_property_data)).

<hr class="classref-item-separator">

<a id="class_JSON_method_parse_string"></a>

<!-- classref-method -->

[Variant](class_variant.md) **parse_string**\ (\ json_string\: [String](class_string.md)\ ) <span class="static">static</span> [ðŸ”—](#class_JSON_method_parse_string)

Attempts to parse the `json_string` provided and returns the parsed data. Returns ``null`` if parse failed.

<hr class="classref-item-separator">

<a id="class_JSON_method_stringify"></a>

<!-- classref-method -->

[String](class_string.md) **stringify**\ (\ data\: [Variant](class_variant.md), indent\: [String](class_string.md) = "", sort_keys\: [bool](class_bool.md) = true, full_precision\: [bool](class_bool.md) = false\ ) <span class="static">static</span> [ðŸ”—](#class_JSON_method_stringify)

Converts a [Variant](class_variant.md) var to JSON text and returns the result. Useful for serializing data to store or send over the network.

\ **Note:** The JSON specification does not define integer or float types, but only a *number* type. Therefore, converting a Variant to JSON text will convert all numerical values to [float](class_float.md) types.

\ **Note:** If `full_precision` is ``true``, when stringifying floats, the unreliable digits are stringified in addition to the reliable digits to guarantee exact decoding.

The `indent` parameter controls if and how something is indented; its contents will be used where there should be an indent in the output. Even spaces like ``"   "`` will work. ``\t`` and ``\n`` can also be used for a tab indent, or to make a newline for each indent respectively.

\ **Example output:**\ 

```
    ## JSON.stringify(my_dictionary)
    {"name":"my_dictionary","version":"1.0.0","entities":[{"name":"entity_0","value":"value_0"},{"name":"entity_1","value":"value_1"}]}

    ## JSON.stringify(my_dictionary, "\t")
    {
        "name": "my_dictionary",
        "version": "1.0.0",
        "entities": [
            {
                "name": "entity_0",
                "value": "value_0"
            },
            {
                "name": "entity_1",
                "value": "value_1"
            }
        ]
    }

    ## JSON.stringify(my_dictionary, "...")
    {
    ..."name": "my_dictionary",
    ..."version": "1.0.0",
    ..."entities": [
    ......{
    ........."name": "entity_0",
    ........."value": "value_0"
    ......},
    ......{
    ........."name": "entity_1",
    ........."value": "value_1"
    ......}
    ...]
    }
```

<hr class="classref-item-separator">

<a id="class_JSON_method_to_native"></a>

<!-- classref-method -->

[Variant](class_variant.md) **to_native**\ (\ json\: [Variant](class_variant.md), allow_objects\: [bool](class_bool.md) = false\ ) <span class="static">static</span> [ðŸ”—](#class_JSON_method_to_native)

Converts a JSON-compliant value that was created with [from_native()](class_json.md#class_JSON_method_from_native) back to native engine types.

By default, objects are ignored for security reasons, unless `allow_objects` is ``true``.

You can convert a JSON string back to a native value like this:

```
    func decode_data(string, allow_objects = false):
        return JSON.to_native(JSON.parse_string(string), allow_objects)
```

