<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/ImageFrames.xml. -->

<a id="class_ImageFrames"></a>

# ImageFrames

**Inherits:** [Resource](class_resource.md) **<** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

A container for sequence of [Image](class_image.md)\ s.

<!-- classref-introduction-group -->

## Description

A container of [Image](class_image.md)\ s used to load and arrange a sequence of frames. Each frame can specify a delay for animated images.

Can be used to load animated image formats externally.

Supported animated image formats are [GIF](https://www.w3.org/Graphics/GIF/spec-gif89a.txt) (``.gif``), [APNG](https://wiki.mozilla.org/APNG_Specification) (``.png`` and ``.apng``), [WepP](https://developers.google.com/speed/webp/docs/riff_container) (``.webp``), and any format exposed via a GDExtension plugin.

An [ImageTexture](class_imagetexture.md) is not meant to be operated from within the editor interface directly, and is mostly useful for rendering images on screen dynamically via code. If you need to generate images procedurally from within the editor, consider saving and importing images as custom texture resources implementing a new [EditorImportPlugin](class_editorimportplugin.md).

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[int](class_int.md)</th>
      <th>[frame_count](#class_ImageFrames_property_frame_count)</th>
      <th>`0`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[loop_count](#class_ImageFrames_property_loop_count)</td>
      <td>`0`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[float](class_float.md)</th>
      <th>[get_frame_delay](#class_ImageFrames_method_get_frame_delay)\ (\ frame\: [int](class_int.md)\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Image](class_image.md)</td>
      <td>[get_frame_image](#class_ImageFrames_method_get_frame_image)\ (\ frame\: [int](class_int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[is_empty](#class_ImageFrames_method_is_empty)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[load](#class_ImageFrames_method_load)\ (\ path\: [String](class_string.md)\ )</td>
    </tr>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[load_apng_from_buffer](#class_ImageFrames_method_load_apng_from_buffer)\ (\ buffer\: [PackedByteArray](class_packedbytearray.md), max_frames\: [int](class_int.md)\ )</td>
    </tr>
    <tr>
      <td>[ImageFrames](class_imageframes.md)</td>
      <td>[load_from_file](#class_ImageFrames_method_load_from_file)\ (\ path\: [String](class_string.md)\ ) <span class="static">static</span></td>
    </tr>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[load_gif_from_buffer](#class_ImageFrames_method_load_gif_from_buffer)\ (\ buffer\: [PackedByteArray](class_packedbytearray.md), max_frames\: [int](class_int.md)\ )</td>
    </tr>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[load_webp_from_buffer](#class_ImageFrames_method_load_webp_from_buffer)\ (\ buffer\: [PackedByteArray](class_packedbytearray.md), max_frames\: [int](class_int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_frame_delay](#class_ImageFrames_method_set_frame_delay)\ (\ frame\: [int](class_int.md), delay\: [float](class_float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_frame_image](#class_ImageFrames_method_set_frame_image)\ (\ frame\: [int](class_int.md), image\: [Image](class_image.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_ImageFrames_property_frame_count"></a>

<!-- classref-property -->

[int](class_int.md) **frame_count** = `0` [ðŸ”—](#class_ImageFrames_property_frame_count)

<!-- classref-property-setget -->

- `void` **set_frame_count**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_frame_count**\ (\ )

Number of frames to use in the animation. While you can create the frames independently with [set_frame_image()](class_imageframes.md#class_ImageFrames_method_set_frame_image), you need to set this value for the animation to take new frames into account.

<hr class="classref-item-separator">

<a id="class_ImageFrames_property_loop_count"></a>

<!-- classref-property -->

[int](class_int.md) **loop_count** = `0` [ðŸ”—](#class_ImageFrames_property_loop_count)

<!-- classref-property-setget -->

- `void` **set_loop_count**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_loop_count**\ (\ )

Number of times the animation loops. A value of ``0`` represents infinity.

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_ImageFrames_method_get_frame_delay"></a>

<!-- classref-method -->

[float](class_float.md) **get_frame_delay**\ (\ frame\: [int](class_int.md)\ ) <span class="const">const</span> [ðŸ”—](#class_ImageFrames_method_get_frame_delay)

Returns the given frame's duration, in seconds.

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_get_frame_image"></a>

<!-- classref-method -->

[Image](class_image.md) **get_frame_image**\ (\ frame\: [int](class_int.md)\ ) <span class="const">const</span> [ðŸ”—](#class_ImageFrames_method_get_frame_image)

Returns the given frame's [Image](class_image.md).

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_is_empty"></a>

<!-- classref-method -->

[bool](class_bool.md) **is_empty**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_ImageFrames_method_is_empty)

Returns ``true`` if the [frame_count](class_imageframes.md#class_ImageFrames_property_frame_count) is ``0``.

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_load"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **load**\ (\ path\: [String](class_string.md)\ ) [ðŸ”—](#class_ImageFrames_method_load)

Loads a sequence of image frames from file `path`.

\ **Warning:** This method should only be used in the editor or in cases when you need to load external images at run-time, such as images located at the ``user://`` directory, and may not work in exported projects.

```
    var frames = ImageFrames.load_from_file("res://animated.gif")
    var animated_texture = AnimatedTexture.create_from_image_frames(frames)
    $Sprite2D.texture = animated_texture
```

This way, textures can be created at run-time by loading images both from within the editor and externally.

\ **Warning:** Prefer to load imported textures with [@GDScript.load()](class_@gdscript.md#class_@GDScript_method_load) over loading them from within the filesystem dynamically with [load()](class_imageframes.md#class_ImageFrames_method_load), as it may not work in exported projects:

```
    var animated_texture = load("res://animated.gif")
    $Sprite2D.texture = texture
```

This is because images have to be imported as an [AnimatedTexture](class_animatedtexture.md) first to be loaded with [@GDScript.load()](class_@gdscript.md#class_@GDScript_method_load). If you'd still like to load an animated image file just like any other [Resource](class_resource.md), import it as an **ImageFrames** resource instead, and then load it normally using the [@GDScript.load()](class_@gdscript.md#class_@GDScript_method_load) method.

\ **Note:** The image frame can be create from an imported texture using the [AnimatedTexture.create_from_image_frames()](class_animatedtexture.md#class_AnimatedTexture_method_create_from_image_frames) method:

```
    var texture = load("res://animated.gif")
    var image: AnimatedTexture = AnimatedTexture.create_from_image_frames(texture)
```

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_load_apng_from_buffer"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **load_apng_from_buffer**\ (\ buffer\: [PackedByteArray](class_packedbytearray.md), max_frames\: [int](class_int.md)\ ) [ðŸ”—](#class_ImageFrames_method_load_apng_from_buffer)

Loads image frames from the binary contents of an APNG file.

\ **Note:** This function will read standard PNG files just like [Image.load_png_from_buffer()](class_image.md#class_Image_method_load_png_from_buffer). If libpng is not compiled with support for reading APNG files, APNG files are treated as PNG files.

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_load_from_file"></a>

<!-- classref-method -->

[ImageFrames](class_imageframes.md) **load_from_file**\ (\ path\: [String](class_string.md)\ ) <span class="static">static</span> [ðŸ”—](#class_ImageFrames_method_load_from_file)

Creates a new **ImageFrames** and loads data from the specified file.

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_load_gif_from_buffer"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **load_gif_from_buffer**\ (\ buffer\: [PackedByteArray](class_packedbytearray.md), max_frames\: [int](class_int.md)\ ) [ðŸ”—](#class_ImageFrames_method_load_gif_from_buffer)

Loads image frames from the binary contents of a GIF file.

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_load_webp_from_buffer"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **load_webp_from_buffer**\ (\ buffer\: [PackedByteArray](class_packedbytearray.md), max_frames\: [int](class_int.md)\ ) [ðŸ”—](#class_ImageFrames_method_load_webp_from_buffer)

Loads image frames from the binary contents of a WebP file.

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_set_frame_delay"></a>

<!-- classref-method -->

`void` **set_frame_delay**\ (\ frame\: [int](class_int.md), delay\: [float](class_float.md)\ ) [ðŸ”—](#class_ImageFrames_method_set_frame_delay)

Sets the delay of any given frame. If set to ``0``, the frame may be skipped if converted into an [AnimatedTexture](class_animatedtexture.md).

<hr class="classref-item-separator">

<a id="class_ImageFrames_method_set_frame_image"></a>

<!-- classref-method -->

`void` **set_frame_image**\ (\ frame\: [int](class_int.md), image\: [Image](class_image.md)\ ) [ðŸ”—](#class_ImageFrames_method_set_frame_image)

Assigns an [Image](class_image.md) to the given frame. Frame IDs start at 0, so the first frame has ID 0, and the last frame has ID [frame_count](class_imageframes.md#class_ImageFrames_property_frame_count) - 1.

