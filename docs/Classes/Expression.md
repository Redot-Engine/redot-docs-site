<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Expression.xml. -->

<a id="Expression"></a>

# Expression

**Inherits:** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

A class that stores an expression you can execute.

<!-- classref-introduction-group -->

## Description

An expression can be made of any arithmetic operation, built-in math function call, method call of a passed instance, or built-in type construction call.

An example expression text using the built-in math functions could be ``sqrt(pow(3, 2) + pow(4, 2))``.

In the following example we use a [LineEdit](LineEdit.md) node to write our expression and show the result.




```gdscript
    var expression = Expression.new()

    func _ready():
        $LineEdit.text_submitted.connect(self._on_text_submitted)

    func _on_text_submitted(command):
        var error = expression.parse(command)
        if error != OK:
            print(expression.get_error_text())
            return
        var result = expression.execute()
        if not expression.has_execute_failed():
            $LineEdit.text = str(result)
```


```csharp
    private Expression _expression = new Expression();

    public override void _Ready()
    {
        GetNode<LineEdit>("LineEdit").TextSubmitted += OnTextEntered;
    }

    private void OnTextEntered(string command)
    {
        Error error = _expression.Parse(command);
        if (error != Error.Ok)
        {
            GD.Print(_expression.GetErrorText());
            return;
        }
        Variant result = _expression.Execute();
        if (!_expression.HasExecuteFailed())
        {
            GetNode<LineEdit>("LineEdit").Text = result.ToString();
        }
    }
```




<!-- classref-introduction-group -->

## Tutorials

- [Evaluating Expressions](../tutorials/scripting/evaluating_expressions.md)

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Variant](Variant.md)</th>
      <th>[execute](#Expression_method_execute)\ (\ inputs\: [Array](Array.md) = [], base_instance\: [Object](Object.md) = null, show_error\: [bool](bool.md) = true, const_calls_only\: [bool](bool.md) = false\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[String](String.md)</td>
      <td>[get_error_text](#Expression_method_get_error_text)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has_execute_failed](#Expression_method_has_execute_failed)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Error](@GlobalScope.md#enum_@GlobalScope_Error)</td>
      <td>[parse](#Expression_method_parse)\ (\ expression\: [String](String.md), input_names\: [PackedStringArray](PackedStringArray.md) = PackedStringArray()\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Expression_method_execute"></a>

<!-- classref-method -->

[Variant](Variant.md) **execute**\ (\ inputs\: [Array](Array.md) = [], base_instance\: [Object](Object.md) = null, show_error\: [bool](bool.md) = true, const_calls_only\: [bool](bool.md) = false\ ) [ðŸ”—](#Expression_method_execute)

Executes the expression that was previously parsed by [parse()](Expression.md#Expression_method_parse) and returns the result. Before you use the returned object, you should check if the method failed by calling [has_execute_failed()](Expression.md#Expression_method_has_execute_failed).

If you defined input variables in [parse()](Expression.md#Expression_method_parse), you can specify their values in the inputs array, in the same order.

<hr class="classref-item-separator"/>

<a id="Expression_method_get_error_text"></a>

<!-- classref-method -->

[String](String.md) **get_error_text**\ (\ ) <span class="const">const</span> [ðŸ”—](#Expression_method_get_error_text)

Returns the error text if [parse()](Expression.md#Expression_method_parse) or [execute()](Expression.md#Expression_method_execute) has failed.

<hr class="classref-item-separator"/>

<a id="Expression_method_has_execute_failed"></a>

<!-- classref-method -->

[bool](bool.md) **has_execute_failed**\ (\ ) <span class="const">const</span> [ðŸ”—](#Expression_method_has_execute_failed)

Returns ``true`` if [execute()](Expression.md#Expression_method_execute) has failed.

<hr class="classref-item-separator"/>

<a id="Expression_method_parse"></a>

<!-- classref-method -->

[Error](@GlobalScope.md#enum_@GlobalScope_Error) **parse**\ (\ expression\: [String](String.md), input_names\: [PackedStringArray](PackedStringArray.md) = PackedStringArray()\ ) [ðŸ”—](#Expression_method_parse)

Parses the expression and returns an [Error](@GlobalScope.md#enum_@GlobalScope_Error) code.

You can optionally specify names of variables that may appear in the expression with `input_names`, so that you can bind them when it gets executed.

