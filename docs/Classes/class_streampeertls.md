<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/StreamPeerTLS.xml. -->

<a id="class_StreamPeerTLS"></a>

# StreamPeerTLS

**Inherits:** [StreamPeer](class_streampeer.md) **<** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

A stream peer that handles TLS connections.

<!-- classref-introduction-group -->

## Description

A stream peer that handles TLS connections. This object can be used to connect to a TLS server or accept a single TLS client connection.

\ **Note:** When exporting to Android, make sure to enable the ``INTERNET`` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.

<!-- classref-introduction-group -->

## Tutorials

- [TLS certificates](../tutorials/networking/ssl_certificates.md)

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</th>
      <th>[accept_stream](#class_StreamPeerTLS_method_accept_stream)\ (\ stream\: [StreamPeer](class_streampeer.md), server_options\: [TLSOptions](class_tlsoptions.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Error](class_@globalscope.md#enum_@GlobalScope_Error)</td>
      <td>[connect_to_stream](#class_StreamPeerTLS_method_connect_to_stream)\ (\ stream\: [StreamPeer](class_streampeer.md), common_name\: [String](class_string.md), client_options\: [TLSOptions](class_tlsoptions.md) = null\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[disconnect_from_stream](#class_StreamPeerTLS_method_disconnect_from_stream)\ (\ )</td>
    </tr>
    <tr>
      <td>[Status](class_streampeertls.md#enum_StreamPeerTLS_Status)</td>
      <td>[get_status](#class_StreamPeerTLS_method_get_status)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[StreamPeer](class_streampeer.md)</td>
      <td>[get_stream](#class_StreamPeerTLS_method_get_stream)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[poll](#class_StreamPeerTLS_method_poll)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_StreamPeerTLS_Status"></a>

<!-- classref-enumeration -->

enum **Status**: [ðŸ”—](#enum_StreamPeerTLS_Status)

<a id="class_StreamPeerTLS_constant_STATUS_DISCONNECTED"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertls.md#enum_StreamPeerTLS_Status) **STATUS_DISCONNECTED** = `0`

A status representing a **StreamPeerTLS** that is disconnected.<a id="class_StreamPeerTLS_constant_STATUS_HANDSHAKING"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertls.md#enum_StreamPeerTLS_Status) **STATUS_HANDSHAKING** = `1`

A status representing a **StreamPeerTLS** during handshaking.<a id="class_StreamPeerTLS_constant_STATUS_CONNECTED"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertls.md#enum_StreamPeerTLS_Status) **STATUS_CONNECTED** = `2`

A status representing a **StreamPeerTLS** that is connected to a host.<a id="class_StreamPeerTLS_constant_STATUS_ERROR"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertls.md#enum_StreamPeerTLS_Status) **STATUS_ERROR** = `3`

A status representing a **StreamPeerTLS** in error state.<a id="class_StreamPeerTLS_constant_STATUS_ERROR_HOSTNAME_MISMATCH"></a>

<!-- classref-enumeration-constant -->

[Status](class_streampeertls.md#enum_StreamPeerTLS_Status) **STATUS_ERROR_HOSTNAME_MISMATCH** = `4`

An error status that shows a mismatch in the TLS certificate domain presented by the host and the domain requested for validation.<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="class_StreamPeerTLS_method_accept_stream"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **accept_stream**\ (\ stream\: [StreamPeer](class_streampeer.md), server_options\: [TLSOptions](class_tlsoptions.md)\ ) [ðŸ”—](#class_StreamPeerTLS_method_accept_stream)

Accepts a peer connection as a server using the given `server_options`. See [TLSOptions.server()](class_tlsoptions.md#class_TLSOptions_method_server).

<hr class="classref-item-separator">

<a id="class_StreamPeerTLS_method_connect_to_stream"></a>

<!-- classref-method -->

[Error](class_@globalscope.md#enum_@GlobalScope_Error) **connect_to_stream**\ (\ stream\: [StreamPeer](class_streampeer.md), common_name\: [String](class_string.md), client_options\: [TLSOptions](class_tlsoptions.md) = null\ ) [ðŸ”—](#class_StreamPeerTLS_method_connect_to_stream)

Connects to a peer using an underlying [StreamPeer](class_streampeer.md) `stream` and verifying the remote certificate is correctly signed for the given `common_name`. You can pass the optional `client_options` parameter to customize the trusted certification authorities, or disable the common name verification. See [TLSOptions.client()](class_tlsoptions.md#class_TLSOptions_method_client) and [TLSOptions.client_unsafe()](class_tlsoptions.md#class_TLSOptions_method_client_unsafe).

<hr class="classref-item-separator">

<a id="class_StreamPeerTLS_method_disconnect_from_stream"></a>

<!-- classref-method -->

`void` **disconnect_from_stream**\ (\ ) [ðŸ”—](#class_StreamPeerTLS_method_disconnect_from_stream)

Disconnects from host.

<hr class="classref-item-separator">

<a id="class_StreamPeerTLS_method_get_status"></a>

<!-- classref-method -->

[Status](class_streampeertls.md#enum_StreamPeerTLS_Status) **get_status**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_StreamPeerTLS_method_get_status)

Returns the status of the connection.

<hr class="classref-item-separator">

<a id="class_StreamPeerTLS_method_get_stream"></a>

<!-- classref-method -->

[StreamPeer](class_streampeer.md) **get_stream**\ (\ ) <span class="const">const</span> [ðŸ”—](#class_StreamPeerTLS_method_get_stream)

Returns the underlying [StreamPeer](class_streampeer.md) connection, used in [accept_stream()](class_streampeertls.md#class_StreamPeerTLS_method_accept_stream) or [connect_to_stream()](class_streampeertls.md#class_StreamPeerTLS_method_connect_to_stream).

<hr class="classref-item-separator">

<a id="class_StreamPeerTLS_method_poll"></a>

<!-- classref-method -->

`void` **poll**\ (\ ) [ðŸ”—](#class_StreamPeerTLS_method_poll)

Poll the connection to check for incoming bytes. Call this right before [StreamPeer.get_available_bytes()](class_streampeer.md#class_StreamPeer_method_get_available_bytes) for it to work properly.

