<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/modules/noise/doc_classes/FastNoiseLite.xml. -->

<a id="class_FastNoiseLite"></a>

# FastNoiseLite

**Inherits:** [Noise](class_noise.md) **<** [Resource](class_resource.md) **<** [RefCounted](class_refcounted.md) **<** [Object](class_object.md)

Generates noise using the FastNoiseLite library.

<!-- classref-introduction-group -->

## Description

This class generates noise using the FastNoiseLite library, which is a collection of several noise algorithms including Cellular, Perlin, Value, and more.

Most generated noise values are in the range of ``[-1, 1]``, but not always. Some of the cellular noise algorithms return results above ``1``.

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[CellularDistanceFunction](class_fastnoiselite.md#enum_FastNoiseLite_CellularDistanceFunction)</th>
      <th>[cellular_distance_function](#class_FastNoiseLite_property_cellular_distance_function)</th>
      <th>`0`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[cellular_jitter](#class_FastNoiseLite_property_cellular_jitter)</td>
      <td>`1.0`</td>
    </tr>
    <tr>
      <td>[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType)</td>
      <td>[cellular_return_type](#class_FastNoiseLite_property_cellular_return_type)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[domain_warp_amplitude](#class_FastNoiseLite_property_domain_warp_amplitude)</td>
      <td>`30.0`</td>
    </tr>
    <tr>
      <td>[bool](class_bool.md)</td>
      <td>[domain_warp_enabled](#class_FastNoiseLite_property_domain_warp_enabled)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[domain_warp_fractal_gain](#class_FastNoiseLite_property_domain_warp_fractal_gain)</td>
      <td>`0.5`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[domain_warp_fractal_lacunarity](#class_FastNoiseLite_property_domain_warp_fractal_lacunarity)</td>
      <td>`6.0`</td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[domain_warp_fractal_octaves](#class_FastNoiseLite_property_domain_warp_fractal_octaves)</td>
      <td>`5`</td>
    </tr>
    <tr>
      <td>[DomainWarpFractalType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpFractalType)</td>
      <td>[domain_warp_fractal_type](#class_FastNoiseLite_property_domain_warp_fractal_type)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[domain_warp_frequency](#class_FastNoiseLite_property_domain_warp_frequency)</td>
      <td>`0.05`</td>
    </tr>
    <tr>
      <td>[DomainWarpType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpType)</td>
      <td>[domain_warp_type](#class_FastNoiseLite_property_domain_warp_type)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[fractal_gain](#class_FastNoiseLite_property_fractal_gain)</td>
      <td>`0.5`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[fractal_lacunarity](#class_FastNoiseLite_property_fractal_lacunarity)</td>
      <td>`2.0`</td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[fractal_octaves](#class_FastNoiseLite_property_fractal_octaves)</td>
      <td>`5`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[fractal_ping_pong_strength](#class_FastNoiseLite_property_fractal_ping_pong_strength)</td>
      <td>`2.0`</td>
    </tr>
    <tr>
      <td>[FractalType](class_fastnoiselite.md#enum_FastNoiseLite_FractalType)</td>
      <td>[fractal_type](#class_FastNoiseLite_property_fractal_type)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[fractal_weighted_strength](#class_FastNoiseLite_property_fractal_weighted_strength)</td>
      <td>`0.0`</td>
    </tr>
    <tr>
      <td>[float](class_float.md)</td>
      <td>[frequency](#class_FastNoiseLite_property_frequency)</td>
      <td>`0.01`</td>
    </tr>
    <tr>
      <td>[NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType)</td>
      <td>[noise_type](#class_FastNoiseLite_property_noise_type)</td>
      <td>`1`</td>
    </tr>
    <tr>
      <td>[Vector3](class_vector3.md)</td>
      <td>[offset](#class_FastNoiseLite_property_offset)</td>
      <td>`Vector3(0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[int](class_int.md)</td>
      <td>[seed](#class_FastNoiseLite_property_seed)</td>
      <td>`0`</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_FastNoiseLite_NoiseType"></a>

<!-- classref-enumeration -->

enum **NoiseType**: [ðŸ”—](#enum_FastNoiseLite_NoiseType)

<a id="class_FastNoiseLite_constant_TYPE_VALUE"></a>

<!-- classref-enumeration-constant -->

[NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType) **TYPE_VALUE** = `5`

A lattice of points are assigned random values then interpolated based on neighboring values.<a id="class_FastNoiseLite_constant_TYPE_VALUE_CUBIC"></a>

<!-- classref-enumeration-constant -->

[NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType) **TYPE_VALUE_CUBIC** = `4`

Similar to value noise ([TYPE_VALUE](class_fastnoiselite.md#class_FastNoiseLite_constant_TYPE_VALUE)), but slower. Has more variance in peaks and valleys.

Cubic noise can be used to avoid certain artifacts when using value noise to create a bumpmap. In general, you should always use this mode if the value noise is being used for a heightmap or bumpmap.<a id="class_FastNoiseLite_constant_TYPE_PERLIN"></a>

<!-- classref-enumeration-constant -->

[NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType) **TYPE_PERLIN** = `3`

A lattice of random gradients. Their dot products are interpolated to obtain values in between the lattices.<a id="class_FastNoiseLite_constant_TYPE_CELLULAR"></a>

<!-- classref-enumeration-constant -->

[NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType) **TYPE_CELLULAR** = `2`

Cellular includes both Worley noise and Voronoi diagrams which creates various regions of the same value.<a id="class_FastNoiseLite_constant_TYPE_SIMPLEX"></a>

<!-- classref-enumeration-constant -->

[NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType) **TYPE_SIMPLEX** = `0`

As opposed to [TYPE_PERLIN](class_fastnoiselite.md#class_FastNoiseLite_constant_TYPE_PERLIN), gradients exist in a simplex lattice rather than a grid lattice, avoiding directional artifacts. Internally uses FastNoiseLite's OpenSimplex2 noise type.<a id="class_FastNoiseLite_constant_TYPE_SIMPLEX_SMOOTH"></a>

<!-- classref-enumeration-constant -->

[NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType) **TYPE_SIMPLEX_SMOOTH** = `1`

Modified, higher quality version of [TYPE_SIMPLEX](class_fastnoiselite.md#class_FastNoiseLite_constant_TYPE_SIMPLEX), but slower. Internally uses FastNoiseLite's OpenSimplex2S noise type.<hr class="classref-item-separator">

<a id="enum_FastNoiseLite_FractalType"></a>

<!-- classref-enumeration -->

enum **FractalType**: [ðŸ”—](#enum_FastNoiseLite_FractalType)

<a id="class_FastNoiseLite_constant_FRACTAL_NONE"></a>

<!-- classref-enumeration-constant -->

[FractalType](class_fastnoiselite.md#enum_FastNoiseLite_FractalType) **FRACTAL_NONE** = `0`

No fractal noise.<a id="class_FastNoiseLite_constant_FRACTAL_FBM"></a>

<!-- classref-enumeration-constant -->

[FractalType](class_fastnoiselite.md#enum_FastNoiseLite_FractalType) **FRACTAL_FBM** = `1`

Method using Fractional Brownian Motion to combine octaves into a fractal.<a id="class_FastNoiseLite_constant_FRACTAL_RIDGED"></a>

<!-- classref-enumeration-constant -->

[FractalType](class_fastnoiselite.md#enum_FastNoiseLite_FractalType) **FRACTAL_RIDGED** = `2`

Method of combining octaves into a fractal resulting in a "ridged" look.<a id="class_FastNoiseLite_constant_FRACTAL_PING_PONG"></a>

<!-- classref-enumeration-constant -->

[FractalType](class_fastnoiselite.md#enum_FastNoiseLite_FractalType) **FRACTAL_PING_PONG** = `3`

Method of combining octaves into a fractal with a ping pong effect.<hr class="classref-item-separator">

<a id="enum_FastNoiseLite_CellularDistanceFunction"></a>

<!-- classref-enumeration -->

enum **CellularDistanceFunction**: [ðŸ”—](#enum_FastNoiseLite_CellularDistanceFunction)

<a id="class_FastNoiseLite_constant_DISTANCE_EUCLIDEAN"></a>

<!-- classref-enumeration-constant -->

[CellularDistanceFunction](class_fastnoiselite.md#enum_FastNoiseLite_CellularDistanceFunction) **DISTANCE_EUCLIDEAN** = `0`

Euclidean distance to the nearest point.<a id="class_FastNoiseLite_constant_DISTANCE_EUCLIDEAN_SQUARED"></a>

<!-- classref-enumeration-constant -->

[CellularDistanceFunction](class_fastnoiselite.md#enum_FastNoiseLite_CellularDistanceFunction) **DISTANCE_EUCLIDEAN_SQUARED** = `1`

Squared Euclidean distance to the nearest point.<a id="class_FastNoiseLite_constant_DISTANCE_MANHATTAN"></a>

<!-- classref-enumeration-constant -->

[CellularDistanceFunction](class_fastnoiselite.md#enum_FastNoiseLite_CellularDistanceFunction) **DISTANCE_MANHATTAN** = `2`

Manhattan distance (taxicab metric) to the nearest point.<a id="class_FastNoiseLite_constant_DISTANCE_HYBRID"></a>

<!-- classref-enumeration-constant -->

[CellularDistanceFunction](class_fastnoiselite.md#enum_FastNoiseLite_CellularDistanceFunction) **DISTANCE_HYBRID** = `3`

Blend of [DISTANCE_EUCLIDEAN](class_fastnoiselite.md#class_FastNoiseLite_constant_DISTANCE_EUCLIDEAN) and [DISTANCE_MANHATTAN](class_fastnoiselite.md#class_FastNoiseLite_constant_DISTANCE_MANHATTAN) to give curved cell boundaries.<hr class="classref-item-separator">

<a id="enum_FastNoiseLite_CellularReturnType"></a>

<!-- classref-enumeration -->

enum **CellularReturnType**: [ðŸ”—](#enum_FastNoiseLite_CellularReturnType)

<a id="class_FastNoiseLite_constant_RETURN_CELL_VALUE"></a>

<!-- classref-enumeration-constant -->

[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **RETURN_CELL_VALUE** = `0`

The cellular distance function will return the same value for all points within a cell.<a id="class_FastNoiseLite_constant_RETURN_DISTANCE"></a>

<!-- classref-enumeration-constant -->

[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **RETURN_DISTANCE** = `1`

The cellular distance function will return a value determined by the distance to the nearest point.<a id="class_FastNoiseLite_constant_RETURN_DISTANCE2"></a>

<!-- classref-enumeration-constant -->

[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **RETURN_DISTANCE2** = `2`

The cellular distance function returns the distance to the second-nearest point.<a id="class_FastNoiseLite_constant_RETURN_DISTANCE2_ADD"></a>

<!-- classref-enumeration-constant -->

[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **RETURN_DISTANCE2_ADD** = `3`

The distance to the nearest point is added to the distance to the second-nearest point.<a id="class_FastNoiseLite_constant_RETURN_DISTANCE2_SUB"></a>

<!-- classref-enumeration-constant -->

[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **RETURN_DISTANCE2_SUB** = `4`

The distance to the nearest point is subtracted from the distance to the second-nearest point.<a id="class_FastNoiseLite_constant_RETURN_DISTANCE2_MUL"></a>

<!-- classref-enumeration-constant -->

[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **RETURN_DISTANCE2_MUL** = `5`

The distance to the nearest point is multiplied with the distance to the second-nearest point.<a id="class_FastNoiseLite_constant_RETURN_DISTANCE2_DIV"></a>

<!-- classref-enumeration-constant -->

[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **RETURN_DISTANCE2_DIV** = `6`

The distance to the nearest point is divided by the distance to the second-nearest point.<hr class="classref-item-separator">

<a id="enum_FastNoiseLite_DomainWarpType"></a>

<!-- classref-enumeration -->

enum **DomainWarpType**: [ðŸ”—](#enum_FastNoiseLite_DomainWarpType)

<a id="class_FastNoiseLite_constant_DOMAIN_WARP_SIMPLEX"></a>

<!-- classref-enumeration-constant -->

[DomainWarpType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpType) **DOMAIN_WARP_SIMPLEX** = `0`

The domain is warped using the simplex noise algorithm.<a id="class_FastNoiseLite_constant_DOMAIN_WARP_SIMPLEX_REDUCED"></a>

<!-- classref-enumeration-constant -->

[DomainWarpType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpType) **DOMAIN_WARP_SIMPLEX_REDUCED** = `1`

The domain is warped using a simplified version of the simplex noise algorithm.<a id="class_FastNoiseLite_constant_DOMAIN_WARP_BASIC_GRID"></a>

<!-- classref-enumeration-constant -->

[DomainWarpType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpType) **DOMAIN_WARP_BASIC_GRID** = `2`

The domain is warped using a simple noise grid (not as smooth as the other methods, but more performant).<hr class="classref-item-separator">

<a id="enum_FastNoiseLite_DomainWarpFractalType"></a>

<!-- classref-enumeration -->

enum **DomainWarpFractalType**: [ðŸ”—](#enum_FastNoiseLite_DomainWarpFractalType)

<a id="class_FastNoiseLite_constant_DOMAIN_WARP_FRACTAL_NONE"></a>

<!-- classref-enumeration-constant -->

[DomainWarpFractalType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpFractalType) **DOMAIN_WARP_FRACTAL_NONE** = `0`

No fractal noise for warping the space.<a id="class_FastNoiseLite_constant_DOMAIN_WARP_FRACTAL_PROGRESSIVE"></a>

<!-- classref-enumeration-constant -->

[DomainWarpFractalType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpFractalType) **DOMAIN_WARP_FRACTAL_PROGRESSIVE** = `1`

Warping the space progressively, octave for octave, resulting in a more "liquified" distortion.<a id="class_FastNoiseLite_constant_DOMAIN_WARP_FRACTAL_INDEPENDENT"></a>

<!-- classref-enumeration-constant -->

[DomainWarpFractalType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpFractalType) **DOMAIN_WARP_FRACTAL_INDEPENDENT** = `2`

Warping the space independently for each octave, resulting in a more chaotic distortion.<hr class="classref-section-separator">

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="class_FastNoiseLite_property_cellular_distance_function"></a>

<!-- classref-property -->

[CellularDistanceFunction](class_fastnoiselite.md#enum_FastNoiseLite_CellularDistanceFunction) **cellular_distance_function** = `0` [ðŸ”—](#class_FastNoiseLite_property_cellular_distance_function)

<!-- classref-property-setget -->

- `void` **set_cellular_distance_function**\ (\ value\: [CellularDistanceFunction](class_fastnoiselite.md#enum_FastNoiseLite_CellularDistanceFunction)\ )
- [CellularDistanceFunction](class_fastnoiselite.md#enum_FastNoiseLite_CellularDistanceFunction) **get_cellular_distance_function**\ (\ )

Determines how the distance to the nearest/second-nearest point is computed.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_cellular_jitter"></a>

<!-- classref-property -->

[float](class_float.md) **cellular_jitter** = `1.0` [ðŸ”—](#class_FastNoiseLite_property_cellular_jitter)

<!-- classref-property-setget -->

- `void` **set_cellular_jitter**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_cellular_jitter**\ (\ )

Maximum distance a point can move off of its grid position. Set to ``0`` for an even grid.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_cellular_return_type"></a>

<!-- classref-property -->

[CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **cellular_return_type** = `1` [ðŸ”—](#class_FastNoiseLite_property_cellular_return_type)

<!-- classref-property-setget -->

- `void` **set_cellular_return_type**\ (\ value\: [CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType)\ )
- [CellularReturnType](class_fastnoiselite.md#enum_FastNoiseLite_CellularReturnType) **get_cellular_return_type**\ (\ )

Return type from cellular noise calculations.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_domain_warp_amplitude"></a>

<!-- classref-property -->

[float](class_float.md) **domain_warp_amplitude** = `30.0` [ðŸ”—](#class_FastNoiseLite_property_domain_warp_amplitude)

<!-- classref-property-setget -->

- `void` **set_domain_warp_amplitude**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_domain_warp_amplitude**\ (\ )

Sets the maximum warp distance from the origin.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_domain_warp_enabled"></a>

<!-- classref-property -->

[bool](class_bool.md) **domain_warp_enabled** = `false` [ðŸ”—](#class_FastNoiseLite_property_domain_warp_enabled)

<!-- classref-property-setget -->

- `void` **set_domain_warp_enabled**\ (\ value\: [bool](class_bool.md)\ )
- [bool](class_bool.md) **is_domain_warp_enabled**\ (\ )

If enabled, another FastNoiseLite instance is used to warp the space, resulting in a distortion of the noise.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_domain_warp_fractal_gain"></a>

<!-- classref-property -->

[float](class_float.md) **domain_warp_fractal_gain** = `0.5` [ðŸ”—](#class_FastNoiseLite_property_domain_warp_fractal_gain)

<!-- classref-property-setget -->

- `void` **set_domain_warp_fractal_gain**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_domain_warp_fractal_gain**\ (\ )

Determines the strength of each subsequent layer of the noise which is used to warp the space.

A low value places more emphasis on the lower frequency base layers, while a high value puts more emphasis on the higher frequency layers.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_domain_warp_fractal_lacunarity"></a>

<!-- classref-property -->

[float](class_float.md) **domain_warp_fractal_lacunarity** = `6.0` [ðŸ”—](#class_FastNoiseLite_property_domain_warp_fractal_lacunarity)

<!-- classref-property-setget -->

- `void` **set_domain_warp_fractal_lacunarity**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_domain_warp_fractal_lacunarity**\ (\ )

The change in frequency between octaves, also known as "lacunarity", of the fractal noise which warps the space. Increasing this value results in higher octaves, producing noise with finer details and a rougher appearance.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_domain_warp_fractal_octaves"></a>

<!-- classref-property -->

[int](class_int.md) **domain_warp_fractal_octaves** = `5` [ðŸ”—](#class_FastNoiseLite_property_domain_warp_fractal_octaves)

<!-- classref-property-setget -->

- `void` **set_domain_warp_fractal_octaves**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_domain_warp_fractal_octaves**\ (\ )

The number of noise layers that are sampled to get the final value for the fractal noise which warps the space.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_domain_warp_fractal_type"></a>

<!-- classref-property -->

[DomainWarpFractalType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpFractalType) **domain_warp_fractal_type** = `1` [ðŸ”—](#class_FastNoiseLite_property_domain_warp_fractal_type)

<!-- classref-property-setget -->

- `void` **set_domain_warp_fractal_type**\ (\ value\: [DomainWarpFractalType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpFractalType)\ )
- [DomainWarpFractalType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpFractalType) **get_domain_warp_fractal_type**\ (\ )

The method for combining octaves into a fractal which is used to warp the space.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_domain_warp_frequency"></a>

<!-- classref-property -->

[float](class_float.md) **domain_warp_frequency** = `0.05` [ðŸ”—](#class_FastNoiseLite_property_domain_warp_frequency)

<!-- classref-property-setget -->

- `void` **set_domain_warp_frequency**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_domain_warp_frequency**\ (\ )

Frequency of the noise which warps the space. Low frequency results in smooth noise while high frequency results in rougher, more granular noise.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_domain_warp_type"></a>

<!-- classref-property -->

[DomainWarpType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpType) **domain_warp_type** = `0` [ðŸ”—](#class_FastNoiseLite_property_domain_warp_type)

<!-- classref-property-setget -->

- `void` **set_domain_warp_type**\ (\ value\: [DomainWarpType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpType)\ )
- [DomainWarpType](class_fastnoiselite.md#enum_FastNoiseLite_DomainWarpType) **get_domain_warp_type**\ (\ )

The warp algorithm.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_fractal_gain"></a>

<!-- classref-property -->

[float](class_float.md) **fractal_gain** = `0.5` [ðŸ”—](#class_FastNoiseLite_property_fractal_gain)

<!-- classref-property-setget -->

- `void` **set_fractal_gain**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_fractal_gain**\ (\ )

Determines the strength of each subsequent layer of noise in fractal noise.

A low value places more emphasis on the lower frequency base layers, while a high value puts more emphasis on the higher frequency layers.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_fractal_lacunarity"></a>

<!-- classref-property -->

[float](class_float.md) **fractal_lacunarity** = `2.0` [ðŸ”—](#class_FastNoiseLite_property_fractal_lacunarity)

<!-- classref-property-setget -->

- `void` **set_fractal_lacunarity**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_fractal_lacunarity**\ (\ )

Frequency multiplier between subsequent octaves. Increasing this value results in higher octaves producing noise with finer details and a rougher appearance.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_fractal_octaves"></a>

<!-- classref-property -->

[int](class_int.md) **fractal_octaves** = `5` [ðŸ”—](#class_FastNoiseLite_property_fractal_octaves)

<!-- classref-property-setget -->

- `void` **set_fractal_octaves**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_fractal_octaves**\ (\ )

The number of noise layers that are sampled to get the final value for fractal noise types.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_fractal_ping_pong_strength"></a>

<!-- classref-property -->

[float](class_float.md) **fractal_ping_pong_strength** = `2.0` [ðŸ”—](#class_FastNoiseLite_property_fractal_ping_pong_strength)

<!-- classref-property-setget -->

- `void` **set_fractal_ping_pong_strength**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_fractal_ping_pong_strength**\ (\ )

Sets the strength of the fractal ping pong type.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_fractal_type"></a>

<!-- classref-property -->

[FractalType](class_fastnoiselite.md#enum_FastNoiseLite_FractalType) **fractal_type** = `1` [ðŸ”—](#class_FastNoiseLite_property_fractal_type)

<!-- classref-property-setget -->

- `void` **set_fractal_type**\ (\ value\: [FractalType](class_fastnoiselite.md#enum_FastNoiseLite_FractalType)\ )
- [FractalType](class_fastnoiselite.md#enum_FastNoiseLite_FractalType) **get_fractal_type**\ (\ )

The method for combining octaves into a fractal.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_fractal_weighted_strength"></a>

<!-- classref-property -->

[float](class_float.md) **fractal_weighted_strength** = `0.0` [ðŸ”—](#class_FastNoiseLite_property_fractal_weighted_strength)

<!-- classref-property-setget -->

- `void` **set_fractal_weighted_strength**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_fractal_weighted_strength**\ (\ )

Higher weighting means higher octaves have less impact if lower octaves have a large impact.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_frequency"></a>

<!-- classref-property -->

[float](class_float.md) **frequency** = `0.01` [ðŸ”—](#class_FastNoiseLite_property_frequency)

<!-- classref-property-setget -->

- `void` **set_frequency**\ (\ value\: [float](class_float.md)\ )
- [float](class_float.md) **get_frequency**\ (\ )

The frequency for all noise types. Low frequency results in smooth noise while high frequency results in rougher, more granular noise.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_noise_type"></a>

<!-- classref-property -->

[NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType) **noise_type** = `1` [ðŸ”—](#class_FastNoiseLite_property_noise_type)

<!-- classref-property-setget -->

- `void` **set_noise_type**\ (\ value\: [NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType)\ )
- [NoiseType](class_fastnoiselite.md#enum_FastNoiseLite_NoiseType) **get_noise_type**\ (\ )

The noise algorithm used.

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_offset"></a>

<!-- classref-property -->

[Vector3](class_vector3.md) **offset** = `Vector3(0, 0, 0)` [ðŸ”—](#class_FastNoiseLite_property_offset)

<!-- classref-property-setget -->

- `void` **set_offset**\ (\ value\: [Vector3](class_vector3.md)\ )
- [Vector3](class_vector3.md) **get_offset**\ (\ )

Translate the noise input coordinates by the given [Vector3](class_vector3.md).

<hr class="classref-item-separator">

<a id="class_FastNoiseLite_property_seed"></a>

<!-- classref-property -->

[int](class_int.md) **seed** = `0` [ðŸ”—](#class_FastNoiseLite_property_seed)

<!-- classref-property-setget -->

- `void` **set_seed**\ (\ value\: [int](class_int.md)\ )
- [int](class_int.md) **get_seed**\ (\ )

The random number seed for all noise types.

