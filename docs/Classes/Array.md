<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/Array.xml. -->

<a id="Array"></a>

# Array

A built-in data structure that holds a sequence of elements.

<!-- classref-introduction-group -->

## Description

An array data structure that can contain a sequence of elements of any [Variant](Variant.md) type by default. Values can optionally be constrained to a specific type by creating a *typed array*. Elements are accessed by a numerical index starting at ``0``. Negative indices are used to count from the back (``-1`` is the last element, ``-2`` is the second to last, etc.).




```gdscript
    var array = ["First", 2, 3, "Last"]
    print(array[0])  # Prints "First"
    print(array[2])  # Prints 3
    print(array[-1]) # Prints "Last"

    array[1] = "Second"
    print(array[1])  # Prints "Second"
    print(array[-3]) # Prints "Second"

    # This typed array can only contain integers.
    # Attempting to add any other type will result in an error.
    var typed_array: Array[int] = [1, 2, 3]
```


```csharp
    Godot.Collections.Array array = ["First", 2, 3, "Last"];
    GD.Print(array[0]); // Prints "First"
    GD.Print(array[2]); // Prints 3
    GD.Print(array[^1]); // Prints "Last"

    array[1] = "Second";
    GD.Print(array[1]); // Prints "Second"
    GD.Print(array[^3]); // Prints "Second"

    // This typed array can only contain integers.
    // Attempting to add any other type will result in an error.
    Godot.Collections.Array<int> typedArray = [1, 2, 3];
```




\ **Note:** Arrays are always passed by **reference**. To get a copy of an array that can be modified independently of the original array, use [duplicate()](Array.md#Array_method_duplicate).

\ **Note:** Erasing elements while iterating over arrays is **not** supported and will result in unpredictable behavior.

\ **Differences between packed arrays, typed arrays, and untyped arrays:** Packed arrays are generally faster to iterate on and modify compared to a typed array of the same type (e.g. [PackedInt64Array](PackedInt64Array.md) versus ``Array[int]``). Also, packed arrays consume less memory. As a downside, packed arrays are less flexible as they don't offer as many convenience methods such as [map()](Array.md#Array_method_map). Typed arrays are in turn faster to iterate on and modify than untyped arrays.

<div class="note">
There are notable differences when using this API with C#. See the C# differences documentation for more information.

</div>

<!-- classref-reftable-group -->

## Constructors

<table>
  <thead>
    <tr>
      <th>[Array](Array.md)</th>
      <th>[Array](#Array_constructor_Array)\ (\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ base\: [Array](Array.md), type\: [int](int.md), class_name\: [StringName](StringName.md), script\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedByteArray](PackedByteArray.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedColorArray](PackedColorArray.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedFloat32Array](PackedFloat32Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedFloat64Array](PackedFloat64Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedInt32Array](PackedInt32Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedInt64Array](PackedInt64Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedStringArray](PackedStringArray.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedVector2Array](PackedVector2Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedVector3Array](PackedVector3Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[Array](#Array_constructor_Array)\ (\ from\: [PackedVector4Array](PackedVector4Array.md)\ )</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[all](#Array_method_all)\ (\ method\: [Callable](Callable.md)\ ) <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[any](#Array_method_any)\ (\ method\: [Callable](Callable.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[append](#Array_method_append)\ (\ value\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[append_array](#Array_method_append_array)\ (\ array\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[assign](#Array_method_assign)\ (\ array\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[back](#Array_method_back)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[bsearch](#Array_method_bsearch)\ (\ value\: [Variant](Variant.md), before\: [bool](bool.md) = true\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[bsearch_custom](#Array_method_bsearch_custom)\ (\ value\: [Variant](Variant.md), func\: [Callable](Callable.md), before\: [bool](bool.md) = true\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[clear](#Array_method_clear)\ (\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[count](#Array_method_count)\ (\ value\: [Variant](Variant.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[duplicate](#Array_method_duplicate)\ (\ deep\: [bool](bool.md) = false\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[duplicate_deep](#Array_method_duplicate_deep)\ (\ deep_subresources_mode\: [int](int.md) = 1\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[erase](#Array_method_erase)\ (\ value\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[fill](#Array_method_fill)\ (\ value\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[filter](#Array_method_filter)\ (\ method\: [Callable](Callable.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[find](#Array_method_find)\ (\ what\: [Variant](Variant.md), from\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[find_custom](#Array_method_find_custom)\ (\ method\: [Callable](Callable.md), from\: [int](int.md) = 0\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[front](#Array_method_front)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[get](#Array_method_get)\ (\ index\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_typed_builtin](#Array_method_get_typed_builtin)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[StringName](StringName.md)</td>
      <td>[get_typed_class_name](#Array_method_get_typed_class_name)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[get_typed_script](#Array_method_get_typed_script)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[has](#Array_method_has)\ (\ value\: [Variant](Variant.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[hash](#Array_method_hash)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[insert](#Array_method_insert)\ (\ position\: [int](int.md), value\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_empty](#Array_method_is_empty)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_read_only](#Array_method_is_read_only)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_same_typed](#Array_method_is_same_typed)\ (\ array\: [Array](Array.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_typed](#Array_method_is_typed)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[make_read_only](#Array_method_make_read_only)\ (\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[map](#Array_method_map)\ (\ method\: [Callable](Callable.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[max](#Array_method_max)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[min](#Array_method_min)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[pick_random](#Array_method_pick_random)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[pop_at](#Array_method_pop_at)\ (\ position\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[pop_back](#Array_method_pop_back)\ (\ )</td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[pop_front](#Array_method_pop_front)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[push_back](#Array_method_push_back)\ (\ value\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[push_front](#Array_method_push_front)\ (\ value\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[reduce](#Array_method_reduce)\ (\ method\: [Callable](Callable.md), accum\: [Variant](Variant.md) = null\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[remove_at](#Array_method_remove_at)\ (\ position\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[resize](#Array_method_resize)\ (\ size\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[reverse](#Array_method_reverse)\ (\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[rfind](#Array_method_rfind)\ (\ what\: [Variant](Variant.md), from\: [int](int.md) = -1\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[rfind_custom](#Array_method_rfind_custom)\ (\ method\: [Callable](Callable.md), from\: [int](int.md) = -1\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set](#Array_method_set)\ (\ index\: [int](int.md), value\: [Variant](Variant.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[shuffle](#Array_method_shuffle)\ (\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[size](#Array_method_size)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[slice](#Array_method_slice)\ (\ begin\: [int](int.md), end\: [int](int.md) = 2147483647, step\: [int](int.md) = 1, deep\: [bool](bool.md) = false\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[sort](#Array_method_sort)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[sort_custom](#Array_method_sort_custom)\ (\ func\: [Callable](Callable.md)\ )</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Operators

<table>
  <thead>
    <tr>
      <th>[bool](bool.md)</th>
      <th>[operator !=](#Array_operator_neq_Array)\ (\ right\: [Array](Array.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Array](Array.md)</td>
      <td>[operator +](#Array_operator_sum_Array)\ (\ right\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator \<](#Array_operator_lt_Array)\ (\ right\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator \<=](#Array_operator_lte_Array)\ (\ right\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator ==](#Array_operator_eq_Array)\ (\ right\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator >](#Array_operator_gt_Array)\ (\ right\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[operator >=](#Array_operator_gte_Array)\ (\ right\: [Array](Array.md)\ )</td>
    </tr>
    <tr>
      <td>[Variant](Variant.md)</td>
      <td>[operator []](#Array_operator_idx_int)\ (\ index\: [int](int.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Constructor Descriptions

<a id="Array_constructor_Array"></a>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ ) [ðŸ”—](#Array_constructor_Array)

Constructs an empty **Array**.

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ base\: [Array](Array.md), type\: [int](int.md), class_name\: [StringName](StringName.md), script\: [Variant](Variant.md)\ )

Creates a typed array from the `base` array. A typed array can only contain elements of the given type, or that inherit from the given class, as described by this constructor's parameters:

- `type` is the built-in [Variant](Variant.md) type, as one the [Variant.Type](@GlobalScope.md#enum_@GlobalScope_Variant.Type) constants.

- `class_name` is the built-in class name (see [Object.get_class()](Object.md#Object_method_get_class)).

- `script` is the associated script. It must be a [Script](Script.md) instance or ``null``.

If `type` is not [@GlobalScope.TYPE_OBJECT](@GlobalScope.md#@GlobalScope_constant_TYPE_OBJECT), `class_name` must be an empty [StringName](StringName.md) and `script` must be ``null``.

```
    class_name Sword
    extends Node

    class Stats:
        pass

    func _ready():
        var a = Array([], TYPE_INT, "", null)               # Array[int]
        var b = Array([], TYPE_OBJECT, "Node", null)        # Array[Node]
        var c = Array([], TYPE_OBJECT, "Node", Sword)       # Array[Sword]
        var d = Array([], TYPE_OBJECT, "RefCounted", Stats) # Array[Stats]
```


The `base` array's elements are converted when necessary. If this is not possible or `base` is already typed, this constructor fails and returns an empty **Array**.

In GDScript, this constructor is usually not necessary, as it is possible to create a typed array through static typing:

```
    var numbers: Array[float] = []
    var children: Array[Node] = [$Node, $Sprite2D, $RigidBody3D]

    var integers: Array[int] = [0.2, 4.5, -2.0]
    print(integers) # Prints [0, 4, -2]
```


<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [Array](Array.md)\ )

Returns the same array as `from`. If you need a copy of the array, use [duplicate()](Array.md#Array_method_duplicate).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedByteArray](PackedByteArray.md)\ )

Constructs an array from a [PackedByteArray](PackedByteArray.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedColorArray](PackedColorArray.md)\ )

Constructs an array from a [PackedColorArray](PackedColorArray.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedFloat32Array](PackedFloat32Array.md)\ )

Constructs an array from a [PackedFloat32Array](PackedFloat32Array.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedFloat64Array](PackedFloat64Array.md)\ )

Constructs an array from a [PackedFloat64Array](PackedFloat64Array.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedInt32Array](PackedInt32Array.md)\ )

Constructs an array from a [PackedInt32Array](PackedInt32Array.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedInt64Array](PackedInt64Array.md)\ )

Constructs an array from a [PackedInt64Array](PackedInt64Array.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedStringArray](PackedStringArray.md)\ )

Constructs an array from a [PackedStringArray](PackedStringArray.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedVector2Array](PackedVector2Array.md)\ )

Constructs an array from a [PackedVector2Array](PackedVector2Array.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedVector3Array](PackedVector3Array.md)\ )

Constructs an array from a [PackedVector3Array](PackedVector3Array.md).

<hr class="classref-item-separator"/>

<!-- classref-constructor -->

[Array](Array.md) **Array**\ (\ from\: [PackedVector4Array](PackedVector4Array.md)\ )

Constructs an array from a [PackedVector4Array](PackedVector4Array.md).

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="Array_method_all"></a>

<!-- classref-method -->

[bool](bool.md) **all**\ (\ method\: [Callable](Callable.md)\ ) <span class="const">const</span> [ðŸ”—](#Array_method_all)

Calls the given [Callable](Callable.md) on each element in the array and returns ``true`` if the [Callable](Callable.md) returns ``true`` for *all* elements in the array. If the [Callable](Callable.md) returns ``false`` for one array element or more, this method returns ``false``.

The `method` should take one [Variant](Variant.md) parameter (the current array element) and return a [bool](bool.md).




```gdscript
    func greater_than_5(number):
        return number &gt; 5

    func _ready():
        print([6, 10, 6].all(greater_than_5)) # Prints true (3/3 elements evaluate to true).
        print([4, 10, 4].all(greater_than_5)) # Prints false (1/3 elements evaluate to true).
        print([4, 4, 4].all(greater_than_5))  # Prints false (0/3 elements evaluate to true).
        print([].all(greater_than_5))         # Prints true (0/0 elements evaluate to true).

        # Same as the first line above, but using a lambda function.
        print([6, 10, 6].all(func(element): return element &gt; 5)) # Prints true
```


```csharp
    private static bool GreaterThan5(int number)
    {
        return number &gt; 5;
    }

    public override void _Ready()
    {
        // Prints True (3/3 elements evaluate to true).
        GD.Print(new Godot.Collections.Array&gt;int&lt; { 6, 10, 6 }.All(GreaterThan5));
        // Prints False (1/3 elements evaluate to true).
        GD.Print(new Godot.Collections.Array&gt;int&lt; { 4, 10, 4 }.All(GreaterThan5));
        // Prints False (0/3 elements evaluate to true).
        GD.Print(new Godot.Collections.Array&gt;int&lt; { 4, 4, 4 }.All(GreaterThan5));
        // Prints True (0/0 elements evaluate to true).
        GD.Print(new Godot.Collections.Array&gt;int&lt; { }.All(GreaterThan5));

        // Same as the first line above, but using a lambda function.
        GD.Print(new Godot.Collections.Array&gt;int&lt; { 6, 10, 6 }.All(element =&gt; element &gt; 5)); // Prints True
    }
```




See also [any()](Array.md#Array_method_any), [filter()](Array.md#Array_method_filter), [map()](Array.md#Array_method_map) and [reduce()](Array.md#Array_method_reduce).

\ **Note:** Unlike relying on the size of an array returned by [filter()](Array.md#Array_method_filter), this method will return as early as possible to improve performance (especially with large arrays).

\ **Note:** For an empty array, this method [always](https://en.wikipedia.org/wiki/Vacuous_truth) returns ``true``.

<hr class="classref-item-separator"/>

<a id="Array_method_any"></a>

<!-- classref-method -->

[bool](bool.md) **any**\ (\ method\: [Callable](Callable.md)\ ) <span class="const">const</span> [ðŸ”—](#Array_method_any)

Calls the given [Callable](Callable.md) on each element in the array and returns ``true`` if the [Callable](Callable.md) returns ``true`` for *one or more* elements in the array. If the [Callable](Callable.md) returns ``false`` for all elements in the array, this method returns ``false``.

The `method` should take one [Variant](Variant.md) parameter (the current array element) and return a [bool](bool.md).

```
    func greater_than_5(number):
        return number &gt; 5

    func _ready():
        print([6, 10, 6].any(greater_than_5)) # Prints true (3 elements evaluate to true).
        print([4, 10, 4].any(greater_than_5)) # Prints true (1 elements evaluate to true).
        print([4, 4, 4].any(greater_than_5))  # Prints false (0 elements evaluate to true).
        print([].any(greater_than_5))         # Prints false (0 elements evaluate to true).

        # Same as the first line above, but using a lambda function.
        print([6, 10, 6].any(func(number): return number &gt; 5)) # Prints true
```


See also [all()](Array.md#Array_method_all), [filter()](Array.md#Array_method_filter), [map()](Array.md#Array_method_map) and [reduce()](Array.md#Array_method_reduce).

\ **Note:** Unlike relying on the size of an array returned by [filter()](Array.md#Array_method_filter), this method will return as early as possible to improve performance (especially with large arrays).

\ **Note:** For an empty array, this method always returns ``false``.

<hr class="classref-item-separator"/>

<a id="Array_method_append"></a>

<!-- classref-method -->

`void` **append**\ (\ value\: [Variant](Variant.md)\ ) [ðŸ”—](#Array_method_append)

Appends `value` at the end of the array (alias of [push_back()](Array.md#Array_method_push_back)).

<hr class="classref-item-separator"/>

<a id="Array_method_append_array"></a>

<!-- classref-method -->

`void` **append_array**\ (\ array\: [Array](Array.md)\ ) [ðŸ”—](#Array_method_append_array)

Appends another `array` at the end of this array.

```
    var numbers = [1, 2, 3]
    var extra = [4, 5, 6]
    numbers.append_array(extra)
    print(numbers) # Prints [1, 2, 3, 4, 5, 6]
```


<hr class="classref-item-separator"/>

<a id="Array_method_assign"></a>

<!-- classref-method -->

`void` **assign**\ (\ array\: [Array](Array.md)\ ) [ðŸ”—](#Array_method_assign)

Assigns elements of another `array` into the array. Resizes the array to match `array`. Performs type conversions if the array is typed.

<hr class="classref-item-separator"/>

<a id="Array_method_back"></a>

<!-- classref-method -->

[Variant](Variant.md) **back**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_back)

Returns the last element of the array. If the array is empty, fails and returns ``null``. See also [front()](Array.md#Array_method_front).

\ **Note:** Unlike with the ``[]`` operator (``array[-1]``), an error is generated without stopping project execution.

<hr class="classref-item-separator"/>

<a id="Array_method_bsearch"></a>

<!-- classref-method -->

[int](int.md) **bsearch**\ (\ value\: [Variant](Variant.md), before\: [bool](bool.md) = true\ ) <span class="const">const</span> [ðŸ”—](#Array_method_bsearch)

Returns the index of `value` in the sorted array. If it cannot be found, returns where `value` should be inserted to keep the array sorted. The algorithm used is [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm).

If `before` is ``true`` (as by default), the returned index comes before all existing elements equal to `value` in the array.

```
    var numbers = [2, 4, 8, 10]
    var idx = numbers.bsearch(7)

    numbers.insert(idx, 7)
    print(numbers) # Prints [2, 4, 7, 8, 10]

    var fruits = ["Apple", "Lemon", "Lemon", "Orange"]
    print(fruits.bsearch("Lemon", true))  # Prints 1, points at the first "Lemon".
    print(fruits.bsearch("Lemon", false)) # Prints 3, points at "Orange".
```


\ **Note:** Calling [bsearch()](Array.md#Array_method_bsearch) on an *unsorted* array will result in unexpected behavior. Use [sort()](Array.md#Array_method_sort) before calling this method.

<hr class="classref-item-separator"/>

<a id="Array_method_bsearch_custom"></a>

<!-- classref-method -->

[int](int.md) **bsearch_custom**\ (\ value\: [Variant](Variant.md), func\: [Callable](Callable.md), before\: [bool](bool.md) = true\ ) <span class="const">const</span> [ðŸ”—](#Array_method_bsearch_custom)

Returns the index of `value` in the sorted array. If it cannot be found, returns where `value` should be inserted to keep the array sorted (using `func` for the comparisons). The algorithm used is [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm).

Similar to [sort_custom()](Array.md#Array_method_sort_custom), `func` is called as many times as necessary, receiving one array element and `value` as arguments. The function should return ``true`` if the array element should be *behind* `value`, otherwise it should return ``false``.

If `before` is ``true`` (as by default), the returned index comes before all existing elements equal to `value` in the array.

```
    func sort_by_amount(a, b):
        if a[1] &lt; b[1]:
            return true
        return false

    func _ready():
        var my_items = [["Tomato", 2], ["Kiwi", 5], ["Rice", 9]]

        var apple = ["Apple", 5]
        # "Apple" is inserted before "Kiwi".
        my_items.insert(my_items.bsearch_custom(apple, sort_by_amount, true), apple)

        var banana = ["Banana", 5]
        # "Banana" is inserted after "Kiwi".
        my_items.insert(my_items.bsearch_custom(banana, sort_by_amount, false), banana)

        # Prints [["Tomato", 2], ["Apple", 5], ["Kiwi", 5], ["Banana", 5], ["Rice", 9]]
        print(my_items)
```


\ **Note:** Calling [bsearch_custom()](Array.md#Array_method_bsearch_custom) on an *unsorted* array will result in unexpected behavior. Use [sort_custom()](Array.md#Array_method_sort_custom) with `func` before calling this method.

<hr class="classref-item-separator"/>

<a id="Array_method_clear"></a>

<!-- classref-method -->

`void` **clear**\ (\ ) [ðŸ”—](#Array_method_clear)

Removes all elements from the array. This is equivalent to using [resize()](Array.md#Array_method_resize) with a size of ``0``.

<hr class="classref-item-separator"/>

<a id="Array_method_count"></a>

<!-- classref-method -->

[int](int.md) **count**\ (\ value\: [Variant](Variant.md)\ ) <span class="const">const</span> [ðŸ”—](#Array_method_count)

Returns the number of times an element is in the array.

To count how many elements in an array satisfy a condition, see [reduce()](Array.md#Array_method_reduce).

<hr class="classref-item-separator"/>

<a id="Array_method_duplicate"></a>

<!-- classref-method -->

[Array](Array.md) **duplicate**\ (\ deep\: [bool](bool.md) = false\ ) <span class="const">const</span> [ðŸ”—](#Array_method_duplicate)

Returns a new copy of the array.

By default, a **shallow** copy is returned: all nested **Array**, [Dictionary](Dictionary.md), and [Resource](Resource.md) elements are shared with the original array. Modifying any of those in one array will also affect them in the other.

If `deep` is ``true``, a **deep** copy is returned: all nested arrays and dictionaries are also duplicated (recursively). Any [Resource](Resource.md) is still shared with the original array, though.

<hr class="classref-item-separator"/>

<a id="Array_method_duplicate_deep"></a>

<!-- classref-method -->

[Array](Array.md) **duplicate_deep**\ (\ deep_subresources_mode\: [int](int.md) = 1\ ) <span class="const">const</span> [ðŸ”—](#Array_method_duplicate_deep)

Duplicates this array, deeply, like [duplicate()](Array.md#Array_method_duplicate)\\ ``(true)``, with extra control over how subresources are handled.

\ `deep_subresources_mode` must be one of the values from [DeepDuplicateMode](Resource.md#enum_Resource_DeepDuplicateMode). By default, only internal resources will be duplicated (recursively).

<hr class="classref-item-separator"/>

<a id="Array_method_erase"></a>

<!-- classref-method -->

`void` **erase**\ (\ value\: [Variant](Variant.md)\ ) [ðŸ”—](#Array_method_erase)

Finds and removes the first occurrence of `value` from the array. If `value` does not exist in the array, nothing happens. To remove an element by index, use [remove_at()](Array.md#Array_method_remove_at) instead.

\ **Note:** This method shifts every element's index after the removed `value` back, which may have a noticeable performance cost, especially on larger arrays.

\ **Note:** Erasing elements while iterating over arrays is **not** supported and will result in unpredictable behavior.

<hr class="classref-item-separator"/>

<a id="Array_method_fill"></a>

<!-- classref-method -->

`void` **fill**\ (\ value\: [Variant](Variant.md)\ ) [ðŸ”—](#Array_method_fill)

Assigns the given `value` to all elements in the array.

This method can often be combined with [resize()](Array.md#Array_method_resize) to create an array with a given size and initialized elements:




```gdscript
    var array = []
    array.resize(5)
    array.fill(2)
    print(array) # Prints [2, 2, 2, 2, 2]
```


```csharp
    Godot.Collections.Array array = [];
    array.Resize(5);
    array.Fill(2);
    GD.Print(array); // Prints [2, 2, 2, 2, 2]
```




\ **Note:** If `value` is a [Variant](Variant.md) passed by reference ([Object](Object.md)-derived, **Array**, [Dictionary](Dictionary.md), etc.), the array will be filled with references to the same `value`, which are not duplicates.

<hr class="classref-item-separator"/>

<a id="Array_method_filter"></a>

<!-- classref-method -->

[Array](Array.md) **filter**\ (\ method\: [Callable](Callable.md)\ ) <span class="const">const</span> [ðŸ”—](#Array_method_filter)

Calls the given [Callable](Callable.md) on each element in the array and returns a new, filtered **Array**.

The `method` receives one of the array elements as an argument, and should return ``true`` to add the element to the filtered array, or ``false`` to exclude it.

```
    func is_even(number):
        return number % 2 == 0

    func _ready():
        print([1, 4, 5, 8].filter(is_even)) # Prints [4, 8]

        # Same as above, but using a lambda function.
        print([1, 4, 5, 8].filter(func(number): return number % 2 == 0))
```


See also [any()](Array.md#Array_method_any), [all()](Array.md#Array_method_all), [map()](Array.md#Array_method_map) and [reduce()](Array.md#Array_method_reduce).

<hr class="classref-item-separator"/>

<a id="Array_method_find"></a>

<!-- classref-method -->

[int](int.md) **find**\ (\ what\: [Variant](Variant.md), from\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#Array_method_find)

Returns the index of the **first** occurrence of `what` in this array, or ``-1`` if there are none. The search's start can be specified with `from`, continuing to the end of the array.

\ **Note:** If you just want to know whether the array contains `what`, use [has()](Array.md#Array_method_has) (``Contains`` in C#). In GDScript, you may also use the ``in`` operator.

\ **Note:** For performance reasons, the search is affected by `what`'s [Variant.Type](@GlobalScope.md#enum_@GlobalScope_Variant.Type). For example, ``7`` ([int](int.md)) and ``7.0`` ([float](float.md)) are not considered equal for this method.

<hr class="classref-item-separator"/>

<a id="Array_method_find_custom"></a>

<!-- classref-method -->

[int](int.md) **find_custom**\ (\ method\: [Callable](Callable.md), from\: [int](int.md) = 0\ ) <span class="const">const</span> [ðŸ”—](#Array_method_find_custom)

Returns the index of the **first** element in the array that causes `method` to return ``true``, or ``-1`` if there are none. The search's start can be specified with `from`, continuing to the end of the array.

\ `method` is a callable that takes an element of the array, and returns a [bool](bool.md).

\ **Note:** If you just want to know whether the array contains *anything* that satisfies `method`, use [any()](Array.md#Array_method_any).




```gdscript
    func is_even(number):
        return number % 2 == 0

    func _ready():
        print([1, 3, 4, 7].find_custom(is_even.bind())) # Prints 2
```




<hr class="classref-item-separator"/>

<a id="Array_method_front"></a>

<!-- classref-method -->

[Variant](Variant.md) **front**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_front)

Returns the first element of the array. If the array is empty, fails and returns ``null``. See also [back()](Array.md#Array_method_back).

\ **Note:** Unlike with the ``[]`` operator (``array[0]``), an error is generated without stopping project execution.

<hr class="classref-item-separator"/>

<a id="Array_method_get"></a>

<!-- classref-method -->

[Variant](Variant.md) **get**\ (\ index\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#Array_method_get)

Returns the element at the given `index` in the array. If `index` out-of-bounds or negative, this method fails and returns ``null``.

This method is similar (but not identical) to the ``[]`` operator. Most notably, when this method fails, it doesn't pause project execution if run from the editor.

<hr class="classref-item-separator"/>

<a id="Array_method_get_typed_builtin"></a>

<!-- classref-method -->

[int](int.md) **get_typed_builtin**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_get_typed_builtin)

Returns the built-in [Variant](Variant.md) type of the typed array as a [Variant.Type](@GlobalScope.md#enum_@GlobalScope_Variant.Type) constant. If the array is not typed, returns [@GlobalScope.TYPE_NIL](@GlobalScope.md#@GlobalScope_constant_TYPE_NIL). See also [is_typed()](Array.md#Array_method_is_typed).

<hr class="classref-item-separator"/>

<a id="Array_method_get_typed_class_name"></a>

<!-- classref-method -->

[StringName](StringName.md) **get_typed_class_name**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_get_typed_class_name)

Returns the **built-in** class name of the typed array, if the built-in [Variant](Variant.md) type [@GlobalScope.TYPE_OBJECT](@GlobalScope.md#@GlobalScope_constant_TYPE_OBJECT). Otherwise, returns an empty [StringName](StringName.md). See also [is_typed()](Array.md#Array_method_is_typed) and [Object.get_class()](Object.md#Object_method_get_class).

<hr class="classref-item-separator"/>

<a id="Array_method_get_typed_script"></a>

<!-- classref-method -->

[Variant](Variant.md) **get_typed_script**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_get_typed_script)

Returns the [Script](Script.md) instance associated with this typed array, or ``null`` if it does not exist. See also [is_typed()](Array.md#Array_method_is_typed).

<hr class="classref-item-separator"/>

<a id="Array_method_has"></a>

<!-- classref-method -->

[bool](bool.md) **has**\ (\ value\: [Variant](Variant.md)\ ) <span class="const">const</span> [ðŸ”—](#Array_method_has)

Returns ``true`` if the array contains the given `value`.




```gdscript
    print(["inside", 7].has("inside"))  # Prints true
    print(["inside", 7].has("outside")) # Prints false
    print(["inside", 7].has(7))         # Prints true
    print(["inside", 7].has("7"))       # Prints false
```


```csharp
    Godot.Collections.Array arr = ["inside", 7];
    // By C# convention, this method is renamed to `Contains`.
    GD.Print(arr.Contains("inside"));  // Prints True
    GD.Print(arr.Contains("outside")); // Prints False
    GD.Print(arr.Contains(7));         // Prints True
    GD.Print(arr.Contains("7"));       // Prints False
```




In GDScript, this is equivalent to the ``in`` operator:

```
    if 4 in [2, 4, 6, 8]:
        print("4 is here!") # Will be printed.
```


\ **Note:** For performance reasons, the search is affected by the `value`'s [Variant.Type](@GlobalScope.md#enum_@GlobalScope_Variant.Type). For example, ``7`` ([int](int.md)) and ``7.0`` ([float](float.md)) are not considered equal for this method.

<hr class="classref-item-separator"/>

<a id="Array_method_hash"></a>

<!-- classref-method -->

[int](int.md) **hash**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_hash)

Returns a hashed 32-bit integer value representing the array and its contents.

\ **Note:** Arrays with equal hash values are *not* guaranteed to be the same, as a result of hash collisions. On the countrary, arrays with different hash values are guaranteed to be different.

<hr class="classref-item-separator"/>

<a id="Array_method_insert"></a>

<!-- classref-method -->

[int](int.md) **insert**\ (\ position\: [int](int.md), value\: [Variant](Variant.md)\ ) [ðŸ”—](#Array_method_insert)

Inserts a new element (`value`) at a given index (`position`) in the array. `position` should be between ``0`` and the array's [size()](Array.md#Array_method_size). If negative, `position` is considered relative to the end of the array.

Returns [@GlobalScope.OK](@GlobalScope.md#@GlobalScope_constant_OK) on success, or one of the other [Error](@GlobalScope.md#enum_@GlobalScope_Error) constants if this method fails.

\ **Note:** Every element's index after `position` needs to be shifted forward, which may have a noticeable performance cost, especially on larger arrays.

<hr class="classref-item-separator"/>

<a id="Array_method_is_empty"></a>

<!-- classref-method -->

[bool](bool.md) **is_empty**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_is_empty)

Returns ``true`` if the array is empty (``[]``). See also [size()](Array.md#Array_method_size).

<hr class="classref-item-separator"/>

<a id="Array_method_is_read_only"></a>

<!-- classref-method -->

[bool](bool.md) **is_read_only**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_is_read_only)

Returns ``true`` if the array is read-only. See [make_read_only()](Array.md#Array_method_make_read_only).

In GDScript, arrays are automatically read-only if declared with the ``const`` keyword.

<hr class="classref-item-separator"/>

<a id="Array_method_is_same_typed"></a>

<!-- classref-method -->

[bool](bool.md) **is_same_typed**\ (\ array\: [Array](Array.md)\ ) <span class="const">const</span> [ðŸ”—](#Array_method_is_same_typed)

Returns ``true`` if this array is typed the same as the given `array`. See also [is_typed()](Array.md#Array_method_is_typed).

<hr class="classref-item-separator"/>

<a id="Array_method_is_typed"></a>

<!-- classref-method -->

[bool](bool.md) **is_typed**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_is_typed)

Returns ``true`` if the array is typed. Typed arrays can only contain elements of a specific type, as defined by the typed array constructor. The methods of a typed array are still expected to return a generic [Variant](Variant.md).

In GDScript, it is possible to define a typed array with static typing:

```
    var numbers: Array[float] = [0.2, 4.2, -2.0]
    print(numbers.is_typed()) # Prints true
```


<hr class="classref-item-separator"/>

<a id="Array_method_make_read_only"></a>

<!-- classref-method -->

`void` **make_read_only**\ (\ ) [ðŸ”—](#Array_method_make_read_only)

Makes the array read-only. The array's elements cannot be overridden with different values, and their order cannot change. Does not apply to nested elements, such as dictionaries.

In GDScript, arrays are automatically read-only if declared with the ``const`` keyword.

<hr class="classref-item-separator"/>

<a id="Array_method_map"></a>

<!-- classref-method -->

[Array](Array.md) **map**\ (\ method\: [Callable](Callable.md)\ ) <span class="const">const</span> [ðŸ”—](#Array_method_map)

Calls the given [Callable](Callable.md) for each element in the array and returns a new array filled with values returned by the `method`.

The `method` should take one [Variant](Variant.md) parameter (the current array element) and can return any [Variant](Variant.md).

```
    func double(number):
        return number * 2

    func _ready():
        print([1, 2, 3].map(double)) # Prints [2, 4, 6]

        # Same as above, but using a lambda function.
        print([1, 2, 3].map(func(element): return element * 2))
```


See also [filter()](Array.md#Array_method_filter), [reduce()](Array.md#Array_method_reduce), [any()](Array.md#Array_method_any) and [all()](Array.md#Array_method_all).

<hr class="classref-item-separator"/>

<a id="Array_method_max"></a>

<!-- classref-method -->

[Variant](Variant.md) **max**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_max)

Returns the maximum value contained in the array, if all elements can be compared. Otherwise, returns ``null``. See also [min()](Array.md#Array_method_min).

To find the maximum value using a custom comparator, you can use [reduce()](Array.md#Array_method_reduce).

<hr class="classref-item-separator"/>

<a id="Array_method_min"></a>

<!-- classref-method -->

[Variant](Variant.md) **min**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_min)

Returns the minimum value contained in the array, if all elements can be compared. Otherwise, returns ``null``. See also [max()](Array.md#Array_method_max).

<hr class="classref-item-separator"/>

<a id="Array_method_pick_random"></a>

<!-- classref-method -->

[Variant](Variant.md) **pick_random**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_pick_random)

Returns a random element from the array. Generates an error and returns ``null`` if the array is empty.




```gdscript
    # May print 1, 2, 3.25, or "Hi".
    print([1, 2, 3.25, "Hi"].pick_random())
```


```csharp
    Godot.Collections.Array array = [1, 2, 3.25f, "Hi"];
    GD.Print(array.PickRandom()); // May print 1, 2, 3.25, or "Hi".
```




\ **Note:** Like many similar functions in the engine (such as [@GlobalScope.randi()](@GlobalScope.md#@GlobalScope_method_randi) or [shuffle()](Array.md#Array_method_shuffle)), this method uses a common, global random seed. To get a predictable outcome from this method, see [@GlobalScope.seed()](@GlobalScope.md#@GlobalScope_method_seed).

<hr class="classref-item-separator"/>

<a id="Array_method_pop_at"></a>

<!-- classref-method -->

[Variant](Variant.md) **pop_at**\ (\ position\: [int](int.md)\ ) [ðŸ”—](#Array_method_pop_at)

Removes and returns the element of the array at index `position`. If negative, `position` is considered relative to the end of the array. Returns ``null`` if the array is empty. If `position` is out of bounds, an error message is also generated.

\ **Note:** This method shifts every element's index after `position` back, which may have a noticeable performance cost, especially on larger arrays.

<hr class="classref-item-separator"/>

<a id="Array_method_pop_back"></a>

<!-- classref-method -->

[Variant](Variant.md) **pop_back**\ (\ ) [ðŸ”—](#Array_method_pop_back)

Removes and returns the last element of the array. Returns ``null`` if the array is empty, without generating an error. See also [pop_front()](Array.md#Array_method_pop_front).

<hr class="classref-item-separator"/>

<a id="Array_method_pop_front"></a>

<!-- classref-method -->

[Variant](Variant.md) **pop_front**\ (\ ) [ðŸ”—](#Array_method_pop_front)

Removes and returns the first element of the array. Returns ``null`` if the array is empty, without generating an error. See also [pop_back()](Array.md#Array_method_pop_back).

\ **Note:** This method shifts every other element's index back, which may have a noticeable performance cost, especially on larger arrays.

<hr class="classref-item-separator"/>

<a id="Array_method_push_back"></a>

<!-- classref-method -->

`void` **push_back**\ (\ value\: [Variant](Variant.md)\ ) [ðŸ”—](#Array_method_push_back)

Appends an element at the end of the array. See also [push_front()](Array.md#Array_method_push_front).

<hr class="classref-item-separator"/>

<a id="Array_method_push_front"></a>

<!-- classref-method -->

`void` **push_front**\ (\ value\: [Variant](Variant.md)\ ) [ðŸ”—](#Array_method_push_front)

Adds an element at the beginning of the array. See also [push_back()](Array.md#Array_method_push_back).

\ **Note:** This method shifts every other element's index forward, which may have a noticeable performance cost, especially on larger arrays.

<hr class="classref-item-separator"/>

<a id="Array_method_reduce"></a>

<!-- classref-method -->

[Variant](Variant.md) **reduce**\ (\ method\: [Callable](Callable.md), accum\: [Variant](Variant.md) = null\ ) <span class="const">const</span> [ðŸ”—](#Array_method_reduce)

Calls the given [Callable](Callable.md) for each element in array, accumulates the result in `accum`, then returns it.

The `method` takes two arguments: the current value of `accum` and the current array element. If `accum` is ``null`` (as by default), the iteration will start from the second element, with the first one used as initial value of `accum`.

```
    func sum(accum, number):
        return accum + number

    func _ready():
        print([1, 2, 3].reduce(sum, 0))  # Prints 6
        print([1, 2, 3].reduce(sum, 10)) # Prints 16

        # Same as above, but using a lambda function.
        print([1, 2, 3].reduce(func(accum, number): return accum + number, 10))
```


If [max()](Array.md#Array_method_max) is not desirable, this method may also be used to implement a custom comparator:

```
    func _ready():
        var arr = [Vector2i(5, 0), Vector2i(3, 4), Vector2i(1, 2)]

        var longest_vec = arr.reduce(func(max, vec): return vec if is_length_greater(vec, max) else max)
        print(longest_vec) # Prints (3, 4)

    func is_length_greater(a, b):
        return a.length() &gt; b.length()
```


This method can also be used to count how many elements in an array satisfy a certain condition, similar to [count()](Array.md#Array_method_count):

```
    func is_even(number):
        return number % 2 == 0

    func _ready():
        var arr = [1, 2, 3, 4, 5]
        # If the current element is even, increment count, otherwise leave count the same.
        var even_count = arr.reduce(func(count, next): return count + 1 if is_even(next) else count, 0)
        print(even_count) # Prints 2
```


See also [map()](Array.md#Array_method_map), [filter()](Array.md#Array_method_filter), [any()](Array.md#Array_method_any), and [all()](Array.md#Array_method_all).

<hr class="classref-item-separator"/>

<a id="Array_method_remove_at"></a>

<!-- classref-method -->

`void` **remove_at**\ (\ position\: [int](int.md)\ ) [ðŸ”—](#Array_method_remove_at)

Removes the element from the array at the given index (`position`). If the index is out of bounds, this method fails. If the index is negative, `position` is considered relative to the end of the array.

If you need to return the removed element, use [pop_at()](Array.md#Array_method_pop_at). To remove an element by value, use [erase()](Array.md#Array_method_erase) instead.

\ **Note:** This method shifts every element's index after `position` back, which may have a noticeable performance cost, especially on larger arrays.

<hr class="classref-item-separator"/>

<a id="Array_method_resize"></a>

<!-- classref-method -->

[int](int.md) **resize**\ (\ size\: [int](int.md)\ ) [ðŸ”—](#Array_method_resize)

Sets the array's number of elements to `size`. If `size` is smaller than the array's current size, the elements at the end are removed. If `size` is greater, new default elements (usually ``null``) are added, depending on the array's type.

Returns [@GlobalScope.OK](@GlobalScope.md#@GlobalScope_constant_OK) on success, or one of the following [Error](@GlobalScope.md#enum_@GlobalScope_Error) constants if this method fails: [@GlobalScope.ERR_LOCKED](@GlobalScope.md#@GlobalScope_constant_ERR_LOCKED) if the array is read-only, [@GlobalScope.ERR_INVALID_PARAMETER](@GlobalScope.md#@GlobalScope_constant_ERR_INVALID_PARAMETER) if the size is negative, or [@GlobalScope.ERR_OUT_OF_MEMORY](@GlobalScope.md#@GlobalScope_constant_ERR_OUT_OF_MEMORY) if allocations fail. Use [size()](Array.md#Array_method_size) to find the actual size of the array after resize.

\ **Note:** Calling this method once and assigning the new values is faster than calling [append()](Array.md#Array_method_append) for every new element.

<hr class="classref-item-separator"/>

<a id="Array_method_reverse"></a>

<!-- classref-method -->

`void` **reverse**\ (\ ) [ðŸ”—](#Array_method_reverse)

Reverses the order of all elements in the array.

<hr class="classref-item-separator"/>

<a id="Array_method_rfind"></a>

<!-- classref-method -->

[int](int.md) **rfind**\ (\ what\: [Variant](Variant.md), from\: [int](int.md) = -1\ ) <span class="const">const</span> [ðŸ”—](#Array_method_rfind)

Returns the index of the **last** occurrence of `what` in this array, or ``-1`` if there are none. The search's start can be specified with `from`, continuing to the beginning of the array. This method is the reverse of [find()](Array.md#Array_method_find).

<hr class="classref-item-separator"/>

<a id="Array_method_rfind_custom"></a>

<!-- classref-method -->

[int](int.md) **rfind_custom**\ (\ method\: [Callable](Callable.md), from\: [int](int.md) = -1\ ) <span class="const">const</span> [ðŸ”—](#Array_method_rfind_custom)

Returns the index of the **last** element of the array that causes `method` to return ``true``, or ``-1`` if there are none. The search's start can be specified with `from`, continuing to the beginning of the array. This method is the reverse of [find_custom()](Array.md#Array_method_find_custom).

<hr class="classref-item-separator"/>

<a id="Array_method_set"></a>

<!-- classref-method -->

`void` **set**\ (\ index\: [int](int.md), value\: [Variant](Variant.md)\ ) [ðŸ”—](#Array_method_set)

Sets the value of the element at the given `index` to the given `value`. This will not change the size of the array, it only changes the value at an index already in the array. This is the same as using the ``[]`` operator (``array[index] = value``).

<hr class="classref-item-separator"/>

<a id="Array_method_shuffle"></a>

<!-- classref-method -->

`void` **shuffle**\ (\ ) [ðŸ”—](#Array_method_shuffle)

Shuffles all elements of the array in a random order.

\ **Note:** Like many similar functions in the engine (such as [@GlobalScope.randi()](@GlobalScope.md#@GlobalScope_method_randi) or [pick_random()](Array.md#Array_method_pick_random)), this method uses a common, global random seed. To get a predictable outcome from this method, see [@GlobalScope.seed()](@GlobalScope.md#@GlobalScope_method_seed).

<hr class="classref-item-separator"/>

<a id="Array_method_size"></a>

<!-- classref-method -->

[int](int.md) **size**\ (\ ) <span class="const">const</span> [ðŸ”—](#Array_method_size)

Returns the number of elements in the array. Empty arrays (``[]``) always return ``0``. See also [is_empty()](Array.md#Array_method_is_empty).

<hr class="classref-item-separator"/>

<a id="Array_method_slice"></a>

<!-- classref-method -->

[Array](Array.md) **slice**\ (\ begin\: [int](int.md), end\: [int](int.md) = 2147483647, step\: [int](int.md) = 1, deep\: [bool](bool.md) = false\ ) <span class="const">const</span> [ðŸ”—](#Array_method_slice)

Returns a new **Array** containing this array's elements, from index `begin` (inclusive) to `end` (exclusive), every `step` elements.

If either `begin` or `end` are negative, their value is relative to the end of the array.

If `step` is negative, this method iterates through the array in reverse, returning a slice ordered backwards. For this to work, `begin` must be greater than `end`.

If `deep` is ``true``, all nested **Array** and [Dictionary](Dictionary.md) elements in the slice are duplicated from the original, recursively. See also [duplicate()](Array.md#Array_method_duplicate).

```
    var letters = ["A", "B", "C", "D", "E", "F"]

    print(letters.slice(0, 2))  # Prints ["A", "B"]
    print(letters.slice(2, -2)) # Prints ["C", "D"]
    print(letters.slice(-2, 6)) # Prints ["E", "F"]

    print(letters.slice(0, 6, 2))  # Prints ["A", "C", "E"]
    print(letters.slice(4, 1, -1)) # Prints ["E", "D", "C"]
```


<hr class="classref-item-separator"/>

<a id="Array_method_sort"></a>

<!-- classref-method -->

`void` **sort**\ (\ ) [ðŸ”—](#Array_method_sort)

Sorts the array in ascending order. The final order is dependent on the "less than" (``&lt;``) comparison between elements.




```gdscript
    var numbers = [10, 5, 2.5, 8]
    numbers.sort()
    print(numbers) # Prints [2.5, 5, 8, 10]
```


```csharp
    Godot.Collections.Array numbers = [10, 5, 2.5, 8];
    numbers.Sort();
    GD.Print(numbers); // Prints [2.5, 5, 8, 10]
```




\ **Note:** The sorting algorithm used is not [stable](https://en.wikipedia.org/wiki/Sorting_algorithm#Stability). This means that equivalent elements (such as ``2`` and ``2.0``) may have their order changed when calling [sort()](Array.md#Array_method_sort).

<hr class="classref-item-separator"/>

<a id="Array_method_sort_custom"></a>

<!-- classref-method -->

`void` **sort_custom**\ (\ func\: [Callable](Callable.md)\ ) [ðŸ”—](#Array_method_sort_custom)

Sorts the array using a custom [Callable](Callable.md).

\ `func` is called as many times as necessary, receiving two array elements as arguments. The function should return ``true`` if the first element should be moved *before* the second one, otherwise it should return ``false``.

```
    func sort_ascending(a, b):
        if a[1] &lt; b[1]:
            return true
        return false

    func _ready():
        var my_items = [["Tomato", 5], ["Apple", 9], ["Rice", 4]]
        my_items.sort_custom(sort_ascending)
        print(my_items) # Prints [["Rice", 4], ["Tomato", 5], ["Apple", 9]]

        # Sort descending, using a lambda function.
        my_items.sort_custom(func(a, b): return a[1] &gt; b[1])
        print(my_items) # Prints [["Apple", 9], ["Tomato", 5], ["Rice", 4]]
```


It may also be necessary to use this method to sort strings by natural order, with [String.naturalnocasecmp_to()](String.md#String_method_naturalnocasecmp_to), as in the following example:

```
    var files = ["newfile1", "newfile2", "newfile10", "newfile11"]
    files.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) &lt; 0)
    print(files) # Prints ["newfile1", "newfile2", "newfile10", "newfile11"]
```


\ **Note:** In C#, this method is not supported.

\ **Note:** The sorting algorithm used is not [stable](https://en.wikipedia.org/wiki/Sorting_algorithm#Stability). This means that values considered equal may have their order changed when calling this method.

\ **Note:** You should not randomize the return value of `func`, as the heapsort algorithm expects a consistent result. Randomizing the return value will result in unexpected behavior.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Operator Descriptions

<a id="Array_operator_neq_Array"></a>

<!-- classref-operator -->

[bool](bool.md) **operator !=**\ (\ right\: [Array](Array.md)\ ) [ðŸ”—](#Array_operator_neq_Array)

Returns ``true`` if the array's size or its elements are different than `right`'s.

<hr class="classref-item-separator"/>

<a id="Array_operator_sum_Array"></a>

<!-- classref-operator -->

[Array](Array.md) **operator +**\ (\ right\: [Array](Array.md)\ ) [ðŸ”—](#Array_operator_sum_Array)

Appends the `right` array to the left operand, creating a new **Array**. This is also known as an array concatenation.




```gdscript
    var array1 = ["One", 2]
    var array2 = [3, "Four"]
    print(array1 + array2) # Prints ["One", 2, 3, "Four"]
```


```csharp
    // Note that concatenation is not possible with C#'s native Array type.
    Godot.Collections.Array array1 = ["One", 2];
    Godot.Collections.Array array2 = [3, "Four"];
    GD.Print(array1 + array2); // Prints ["One", 2, 3, "Four"]
```




\ **Note:** For existing arrays, [append_array()](Array.md#Array_method_append_array) is much more efficient than concatenation and assignment with the ``+=`` operator.

<hr class="classref-item-separator"/>

<a id="Array_operator_lt_Array"></a>

<!-- classref-operator -->

[bool](bool.md) **operator &lt;**\ (\ right\: [Array](Array.md)\ ) [ðŸ”—](#Array_operator_lt_Array)

Compares the elements of both arrays in order, starting from index ``0`` and ending on the last index in common between both arrays. For each pair of elements, returns ``true`` if this array's element is less than `right`'s, ``false`` if this element is greater. Otherwise, continues to the next pair.

If all searched elements are equal, returns ``true`` if this array's size is less than `right`'s, otherwise returns ``false``.

<hr class="classref-item-separator"/>

<a id="Array_operator_lte_Array"></a>

<!-- classref-operator -->

[bool](bool.md) **operator &lt;=**\ (\ right\: [Array](Array.md)\ ) [ðŸ”—](#Array_operator_lte_Array)

Compares the elements of both arrays in order, starting from index ``0`` and ending on the last index in common between both arrays. For each pair of elements, returns ``true`` if this array's element is less than `right`'s, ``false`` if this element is greater. Otherwise, continues to the next pair.

If all searched elements are equal, returns ``true`` if this array's size is less or equal to `right`'s, otherwise returns ``false``.

<hr class="classref-item-separator"/>

<a id="Array_operator_eq_Array"></a>

<!-- classref-operator -->

[bool](bool.md) **operator ==**\ (\ right\: [Array](Array.md)\ ) [ðŸ”—](#Array_operator_eq_Array)

Compares the left operand **Array** against the `right` **Array**. Returns ``true`` if the sizes and contents of the arrays are equal, ``false`` otherwise.

<hr class="classref-item-separator"/>

<a id="Array_operator_gt_Array"></a>

<!-- classref-operator -->

[bool](bool.md) **operator &gt;**\ (\ right\: [Array](Array.md)\ ) [ðŸ”—](#Array_operator_gt_Array)

Compares the elements of both arrays in order, starting from index ``0`` and ending on the last index in common between both arrays. For each pair of elements, returns ``true`` if this array's element is greater than `right`'s, ``false`` if this element is less. Otherwise, continues to the next pair.

If all searched elements are equal, returns ``true`` if this array's size is greater than `right`'s, otherwise returns ``false``.

<hr class="classref-item-separator"/>

<a id="Array_operator_gte_Array"></a>

<!-- classref-operator -->

[bool](bool.md) **operator &gt;=**\ (\ right\: [Array](Array.md)\ ) [ðŸ”—](#Array_operator_gte_Array)

Compares the elements of both arrays in order, starting from index ``0`` and ending on the last index in common between both arrays. For each pair of elements, returns ``true`` if this array's element is greater than `right`'s, ``false`` if this element is less. Otherwise, continues to the next pair.

If all searched elements are equal, returns ``true`` if this array's size is greater or equal to `right`'s, otherwise returns ``false``.

<hr class="classref-item-separator"/>

<a id="Array_operator_idx_int"></a>

<!-- classref-operator -->

[Variant](Variant.md) **operator []**\ (\ index\: [int](int.md)\ ) [ðŸ”—](#Array_operator_idx_int)

Returns the [Variant](Variant.md) element at the specified `index`. Arrays start at index 0. If `index` is greater or equal to ``0``, the element is fetched starting from the beginning of the array. If `index` is a negative value, the element is fetched starting from the end. Accessing an array out-of-bounds will cause a run-time error, pausing the project execution if run from the editor.

