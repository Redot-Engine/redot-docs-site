<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/NavigationMesh.xml. -->

<a id="NavigationMesh"></a>

# NavigationMesh

**Experimental:** This class may be changed or removed in future versions.

**Inherits:** [Resource](Resource.md) **\<** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

A navigation mesh that defines traversable areas and obstacles.

<!-- classref-introduction-group -->

## Description

A navigation mesh is a collection of polygons that define which areas of an environment are traversable to aid agents in pathfinding through complicated spaces.

<!-- classref-introduction-group -->

## Tutorials

- [Using NavigationMeshes](../tutorials/navigation/navigation_using_navigationmeshes.md)

- [3D Navigation Demo](https://godotengine.org/asset-library/asset/2743)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[float](float.md)</th>
      <th>[agent_height](#NavigationMesh_property_agent_height)</th>
      <th>`1.5`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[float](float.md)</td>
      <td>[agent_max_climb](#NavigationMesh_property_agent_max_climb)</td>
      <td>`0.25`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[agent_max_slope](#NavigationMesh_property_agent_max_slope)</td>
      <td>`45.0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[agent_radius](#NavigationMesh_property_agent_radius)</td>
      <td>`0.5`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[border_size](#NavigationMesh_property_border_size)</td>
      <td>`0.0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[cell_height](#NavigationMesh_property_cell_height)</td>
      <td>`0.25`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[cell_size](#NavigationMesh_property_cell_size)</td>
      <td>`0.25`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[detail_sample_distance](#NavigationMesh_property_detail_sample_distance)</td>
      <td>`6.0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[detail_sample_max_error](#NavigationMesh_property_detail_sample_max_error)</td>
      <td>`1.0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[edge_max_error](#NavigationMesh_property_edge_max_error)</td>
      <td>`1.3`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[edge_max_length](#NavigationMesh_property_edge_max_length)</td>
      <td>`0.0`</td>
    </tr>
    <tr>
      <td>[AABB](AABB.md)</td>
      <td>[filter_baking_aabb](#NavigationMesh_property_filter_baking_aabb)</td>
      <td>`AABB(0, 0, 0, 0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector3](Vector3.md)</td>
      <td>[filter_baking_aabb_offset](#NavigationMesh_property_filter_baking_aabb_offset)</td>
      <td>`Vector3(0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[filter_ledge_spans](#NavigationMesh_property_filter_ledge_spans)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[filter_low_hanging_obstacles](#NavigationMesh_property_filter_low_hanging_obstacles)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[filter_walkable_low_height_spans](#NavigationMesh_property_filter_walkable_low_height_spans)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[geometry_collision_mask](#NavigationMesh_property_geometry_collision_mask)</td>
      <td>`4294967295`</td>
    </tr>
    <tr>
      <td>[ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType)</td>
      <td>[geometry_parsed_geometry_type](#NavigationMesh_property_geometry_parsed_geometry_type)</td>
      <td>`2`</td>
    </tr>
    <tr>
      <td>[SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode)</td>
      <td>[geometry_source_geometry_mode](#NavigationMesh_property_geometry_source_geometry_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[StringName](StringName.md)</td>
      <td>[geometry_source_group_name](#NavigationMesh_property_geometry_source_group_name)</td>
      <td>`&"navigation_mesh_source_group"`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[region_merge_size](#NavigationMesh_property_region_merge_size)</td>
      <td>`20.0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[region_min_size](#NavigationMesh_property_region_min_size)</td>
      <td>`2.0`</td>
    </tr>
    <tr>
      <td>[SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType)</td>
      <td>[sample_partition_type](#NavigationMesh_property_sample_partition_type)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[vertices_per_polygon](#NavigationMesh_property_vertices_per_polygon)</td>
      <td>`6.0`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>`void`</th>
      <th>[add_polygon](#NavigationMesh_method_add_polygon)\ (\ polygon\: [PackedInt32Array](PackedInt32Array.md)\ )</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`void`</td>
      <td>[clear](#NavigationMesh_method_clear)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[clear_polygons](#NavigationMesh_method_clear_polygons)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[create_from_mesh](#NavigationMesh_method_create_from_mesh)\ (\ mesh\: [Mesh](Mesh.md)\ )</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[get_collision_mask_value](#NavigationMesh_method_get_collision_mask_value)\ (\ layer_number\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[PackedInt32Array](PackedInt32Array.md)</td>
      <td>[get_polygon](#NavigationMesh_method_get_polygon)\ (\ idx\: [int](int.md)\ )</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[get_polygon_count](#NavigationMesh_method_get_polygon_count)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[PackedVector3Array](PackedVector3Array.md)</td>
      <td>[get_vertices](#NavigationMesh_method_get_vertices)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_collision_mask_value](#NavigationMesh_method_set_collision_mask_value)\ (\ layer_number\: [int](int.md), value\: [bool](bool.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_vertices](#NavigationMesh_method_set_vertices)\ (\ vertices\: [PackedVector3Array](PackedVector3Array.md)\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_NavigationMesh_SamplePartitionType"></a>

<!-- classref-enumeration -->

enum **SamplePartitionType**: [ðŸ”—](#enum_NavigationMesh_SamplePartitionType)

<a id="NavigationMesh_constant_SAMPLE_PARTITION_WATERSHED"></a>

<!-- classref-enumeration-constant -->

[SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType) **SAMPLE_PARTITION_WATERSHED** = `0`

Watershed partitioning. Generally the best choice if you precompute the navigation mesh, use this if you have large open areas.<a id="NavigationMesh_constant_SAMPLE_PARTITION_MONOTONE"></a>

<!-- classref-enumeration-constant -->

[SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType) **SAMPLE_PARTITION_MONOTONE** = `1`

Monotone partitioning. Use this if you want fast navigation mesh generation.<a id="NavigationMesh_constant_SAMPLE_PARTITION_LAYERS"></a>

<!-- classref-enumeration-constant -->

[SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType) **SAMPLE_PARTITION_LAYERS** = `2`

Layer partitioning. Good choice to use for tiled navigation mesh with medium and small sized tiles.<a id="NavigationMesh_constant_SAMPLE_PARTITION_MAX"></a>

<!-- classref-enumeration-constant -->

[SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType) **SAMPLE_PARTITION_MAX** = `3`

Represents the size of the [SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType) enum.<hr class="classref-item-separator"/>

<a id="enum_NavigationMesh_ParsedGeometryType"></a>

<!-- classref-enumeration -->

enum **ParsedGeometryType**: [ðŸ”—](#enum_NavigationMesh_ParsedGeometryType)

<a id="NavigationMesh_constant_PARSED_GEOMETRY_MESH_INSTANCES"></a>

<!-- classref-enumeration-constant -->

[ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType) **PARSED_GEOMETRY_MESH_INSTANCES** = `0`

Parses mesh instances as geometry. This includes [MeshInstance3D](MeshInstance3D.md), [CSGShape3D](CSGShape3D.md), and [GridMap](GridMap.md) nodes.<a id="NavigationMesh_constant_PARSED_GEOMETRY_STATIC_COLLIDERS"></a>

<!-- classref-enumeration-constant -->

[ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType) **PARSED_GEOMETRY_STATIC_COLLIDERS** = `1`

Parses [StaticBody3D](StaticBody3D.md) colliders as geometry. The collider should be in any of the layers specified by [geometry_collision_mask](NavigationMesh.md#NavigationMesh_property_geometry_collision_mask).<a id="NavigationMesh_constant_PARSED_GEOMETRY_BOTH"></a>

<!-- classref-enumeration-constant -->

[ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType) **PARSED_GEOMETRY_BOTH** = `2`

Both [PARSED_GEOMETRY_MESH_INSTANCES](NavigationMesh.md#NavigationMesh_constant_PARSED_GEOMETRY_MESH_INSTANCES) and [PARSED_GEOMETRY_STATIC_COLLIDERS](NavigationMesh.md#NavigationMesh_constant_PARSED_GEOMETRY_STATIC_COLLIDERS).<a id="NavigationMesh_constant_PARSED_GEOMETRY_MAX"></a>

<!-- classref-enumeration-constant -->

[ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType) **PARSED_GEOMETRY_MAX** = `3`

Represents the size of the [ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType) enum.<hr class="classref-item-separator"/>

<a id="enum_NavigationMesh_SourceGeometryMode"></a>

<!-- classref-enumeration -->

enum **SourceGeometryMode**: [ðŸ”—](#enum_NavigationMesh_SourceGeometryMode)

<a id="NavigationMesh_constant_SOURCE_GEOMETRY_ROOT_NODE_CHILDREN"></a>

<!-- classref-enumeration-constant -->

[SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode) **SOURCE_GEOMETRY_ROOT_NODE_CHILDREN** = `0`

Scans the child nodes of the root node recursively for geometry.<a id="NavigationMesh_constant_SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN"></a>

<!-- classref-enumeration-constant -->

[SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode) **SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN** = `1`

Scans nodes in a group and their child nodes recursively for geometry. The group is specified by [geometry_source_group_name](NavigationMesh.md#NavigationMesh_property_geometry_source_group_name).<a id="NavigationMesh_constant_SOURCE_GEOMETRY_GROUPS_EXPLICIT"></a>

<!-- classref-enumeration-constant -->

[SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode) **SOURCE_GEOMETRY_GROUPS_EXPLICIT** = `2`

Uses nodes in a group for geometry. The group is specified by [geometry_source_group_name](NavigationMesh.md#NavigationMesh_property_geometry_source_group_name).<a id="NavigationMesh_constant_SOURCE_GEOMETRY_MAX"></a>

<!-- classref-enumeration-constant -->

[SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode) **SOURCE_GEOMETRY_MAX** = `3`

Represents the size of the [SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode) enum.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="NavigationMesh_property_agent_height"></a>

<!-- classref-property -->

[float](float.md) **agent_height** = `1.5` [ðŸ”—](#NavigationMesh_property_agent_height)

<!-- classref-property-setget -->

- `void` **set_agent_height**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_agent_height**\ (\ )

The minimum floor to ceiling height that will still allow the floor area to be considered walkable.

\ **Note:** While baking, this value will be rounded up to the nearest multiple of [cell_height](NavigationMesh.md#NavigationMesh_property_cell_height).

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_agent_max_climb"></a>

<!-- classref-property -->

[float](float.md) **agent_max_climb** = `0.25` [ðŸ”—](#NavigationMesh_property_agent_max_climb)

<!-- classref-property-setget -->

- `void` **set_agent_max_climb**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_agent_max_climb**\ (\ )

The minimum ledge height that is considered to still be traversable.

\ **Note:** While baking, this value will be rounded down to the nearest multiple of [cell_height](NavigationMesh.md#NavigationMesh_property_cell_height).

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_agent_max_slope"></a>

<!-- classref-property -->

[float](float.md) **agent_max_slope** = `45.0` [ðŸ”—](#NavigationMesh_property_agent_max_slope)

<!-- classref-property-setget -->

- `void` **set_agent_max_slope**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_agent_max_slope**\ (\ )

The maximum slope that is considered walkable, in degrees.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_agent_radius"></a>

<!-- classref-property -->

[float](float.md) **agent_radius** = `0.5` [ðŸ”—](#NavigationMesh_property_agent_radius)

<!-- classref-property-setget -->

- `void` **set_agent_radius**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_agent_radius**\ (\ )

The distance to erode/shrink the walkable area of the heightfield away from obstructions.

\ **Note:** While baking, this value will be rounded up to the nearest multiple of [cell_size](NavigationMesh.md#NavigationMesh_property_cell_size).

\ **Note:** The radius must be equal or higher than ``0.0``. If the radius is ``0.0``, it won't be possible to fix invalid outline overlaps and other precision errors during the baking process. As a result, some obstacles may be excluded incorrectly from the final navigation mesh, or may delete the navigation mesh's polygons.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_border_size"></a>

<!-- classref-property -->

[float](float.md) **border_size** = `0.0` [ðŸ”—](#NavigationMesh_property_border_size)

<!-- classref-property-setget -->

- `void` **set_border_size**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_border_size**\ (\ )

The size of the non-navigable border around the bake bounding area.

In conjunction with the [filter_baking_aabb](NavigationMesh.md#NavigationMesh_property_filter_baking_aabb) and a [edge_max_error](NavigationMesh.md#NavigationMesh_property_edge_max_error) value at ``1.0`` or below the border size can be used to bake tile aligned navigation meshes without the tile edges being shrunk by [agent_radius](NavigationMesh.md#NavigationMesh_property_agent_radius).

\ **Note:** If this value is not ``0.0``, it will be rounded up to the nearest multiple of [cell_size](NavigationMesh.md#NavigationMesh_property_cell_size) during baking.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_cell_height"></a>

<!-- classref-property -->

[float](float.md) **cell_height** = `0.25` [ðŸ”—](#NavigationMesh_property_cell_height)

<!-- classref-property-setget -->

- `void` **set_cell_height**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_cell_height**\ (\ )

The cell height used to rasterize the navigation mesh vertices on the Y axis. Must match with the cell height on the navigation map.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_cell_size"></a>

<!-- classref-property -->

[float](float.md) **cell_size** = `0.25` [ðŸ”—](#NavigationMesh_property_cell_size)

<!-- classref-property-setget -->

- `void` **set_cell_size**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_cell_size**\ (\ )

The cell size used to rasterize the navigation mesh vertices on the XZ plane. Must match with the cell size on the navigation map.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_detail_sample_distance"></a>

<!-- classref-property -->

[float](float.md) **detail_sample_distance** = `6.0` [ðŸ”—](#NavigationMesh_property_detail_sample_distance)

<!-- classref-property-setget -->

- `void` **set_detail_sample_distance**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_detail_sample_distance**\ (\ )

The sampling distance to use when generating the detail mesh, in cell unit.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_detail_sample_max_error"></a>

<!-- classref-property -->

[float](float.md) **detail_sample_max_error** = `1.0` [ðŸ”—](#NavigationMesh_property_detail_sample_max_error)

<!-- classref-property-setget -->

- `void` **set_detail_sample_max_error**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_detail_sample_max_error**\ (\ )

The maximum distance the detail mesh surface should deviate from heightfield, in cell unit.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_edge_max_error"></a>

<!-- classref-property -->

[float](float.md) **edge_max_error** = `1.3` [ðŸ”—](#NavigationMesh_property_edge_max_error)

<!-- classref-property-setget -->

- `void` **set_edge_max_error**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_edge_max_error**\ (\ )

The maximum distance a simplified contour's border edges should deviate the original raw contour.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_edge_max_length"></a>

<!-- classref-property -->

[float](float.md) **edge_max_length** = `0.0` [ðŸ”—](#NavigationMesh_property_edge_max_length)

<!-- classref-property-setget -->

- `void` **set_edge_max_length**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_edge_max_length**\ (\ )

The maximum allowed length for contour edges along the border of the mesh. A value of ``0.0`` disables this feature.

\ **Note:** While baking, this value will be rounded up to the nearest multiple of [cell_size](NavigationMesh.md#NavigationMesh_property_cell_size).

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_filter_baking_aabb"></a>

<!-- classref-property -->

[AABB](AABB.md) **filter_baking_aabb** = `AABB(0, 0, 0, 0, 0, 0)` [ðŸ”—](#NavigationMesh_property_filter_baking_aabb)

<!-- classref-property-setget -->

- `void` **set_filter_baking_aabb**\ (\ value\: [AABB](AABB.md)\ )
- [AABB](AABB.md) **get_filter_baking_aabb**\ (\ )

If the baking [AABB](AABB.md) has a volume the navigation mesh baking will be restricted to its enclosing area.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_filter_baking_aabb_offset"></a>

<!-- classref-property -->

[Vector3](Vector3.md) **filter_baking_aabb_offset** = `Vector3(0, 0, 0)` [ðŸ”—](#NavigationMesh_property_filter_baking_aabb_offset)

<!-- classref-property-setget -->

- `void` **set_filter_baking_aabb_offset**\ (\ value\: [Vector3](Vector3.md)\ )
- [Vector3](Vector3.md) **get_filter_baking_aabb_offset**\ (\ )

The position offset applied to the [filter_baking_aabb](NavigationMesh.md#NavigationMesh_property_filter_baking_aabb) [AABB](AABB.md).

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_filter_ledge_spans"></a>

<!-- classref-property -->

[bool](bool.md) **filter_ledge_spans** = `false` [ðŸ”—](#NavigationMesh_property_filter_ledge_spans)

<!-- classref-property-setget -->

- `void` **set_filter_ledge_spans**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_filter_ledge_spans**\ (\ )

If ``true``, marks spans that are ledges as non-walkable.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_filter_low_hanging_obstacles"></a>

<!-- classref-property -->

[bool](bool.md) **filter_low_hanging_obstacles** = `false` [ðŸ”—](#NavigationMesh_property_filter_low_hanging_obstacles)

<!-- classref-property-setget -->

- `void` **set_filter_low_hanging_obstacles**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_filter_low_hanging_obstacles**\ (\ )

If ``true``, marks non-walkable spans as walkable if their maximum is within [agent_max_climb](NavigationMesh.md#NavigationMesh_property_agent_max_climb) of a walkable neighbor.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_filter_walkable_low_height_spans"></a>

<!-- classref-property -->

[bool](bool.md) **filter_walkable_low_height_spans** = `false` [ðŸ”—](#NavigationMesh_property_filter_walkable_low_height_spans)

<!-- classref-property-setget -->

- `void` **set_filter_walkable_low_height_spans**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **get_filter_walkable_low_height_spans**\ (\ )

If ``true``, marks walkable spans as not walkable if the clearance above the span is less than [agent_height](NavigationMesh.md#NavigationMesh_property_agent_height).

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_geometry_collision_mask"></a>

<!-- classref-property -->

[int](int.md) **geometry_collision_mask** = `4294967295` [ðŸ”—](#NavigationMesh_property_geometry_collision_mask)

<!-- classref-property-setget -->

- `void` **set_collision_mask**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_collision_mask**\ (\ )

The physics layers to scan for static colliders.

Only used when [geometry_parsed_geometry_type](NavigationMesh.md#NavigationMesh_property_geometry_parsed_geometry_type) is [PARSED_GEOMETRY_STATIC_COLLIDERS](NavigationMesh.md#NavigationMesh_constant_PARSED_GEOMETRY_STATIC_COLLIDERS) or [PARSED_GEOMETRY_BOTH](NavigationMesh.md#NavigationMesh_constant_PARSED_GEOMETRY_BOTH).

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_geometry_parsed_geometry_type"></a>

<!-- classref-property -->

[ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType) **geometry_parsed_geometry_type** = `2` [ðŸ”—](#NavigationMesh_property_geometry_parsed_geometry_type)

<!-- classref-property-setget -->

- `void` **set_parsed_geometry_type**\ (\ value\: [ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType)\ )
- [ParsedGeometryType](NavigationMesh.md#enum_NavigationMesh_ParsedGeometryType) **get_parsed_geometry_type**\ (\ )

Determines which type of nodes will be parsed as geometry.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_geometry_source_geometry_mode"></a>

<!-- classref-property -->

[SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode) **geometry_source_geometry_mode** = `0` [ðŸ”—](#NavigationMesh_property_geometry_source_geometry_mode)

<!-- classref-property-setget -->

- `void` **set_source_geometry_mode**\ (\ value\: [SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode)\ )
- [SourceGeometryMode](NavigationMesh.md#enum_NavigationMesh_SourceGeometryMode) **get_source_geometry_mode**\ (\ )

The source of the geometry used when baking.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_geometry_source_group_name"></a>

<!-- classref-property -->

[StringName](StringName.md) **geometry_source_group_name** = `&"navigation_mesh_source_group"` [ðŸ”—](#NavigationMesh_property_geometry_source_group_name)

<!-- classref-property-setget -->

- `void` **set_source_group_name**\ (\ value\: [StringName](StringName.md)\ )
- [StringName](StringName.md) **get_source_group_name**\ (\ )

The name of the group to scan for geometry.

Only used when [geometry_source_geometry_mode](NavigationMesh.md#NavigationMesh_property_geometry_source_geometry_mode) is [SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN](NavigationMesh.md#NavigationMesh_constant_SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN) or [SOURCE_GEOMETRY_GROUPS_EXPLICIT](NavigationMesh.md#NavigationMesh_constant_SOURCE_GEOMETRY_GROUPS_EXPLICIT).

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_region_merge_size"></a>

<!-- classref-property -->

[float](float.md) **region_merge_size** = `20.0` [ðŸ”—](#NavigationMesh_property_region_merge_size)

<!-- classref-property-setget -->

- `void` **set_region_merge_size**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_region_merge_size**\ (\ )

Any regions with a size smaller than this will be merged with larger regions if possible.

\ **Note:** This value will be squared to calculate the number of cells. For example, a value of 20 will set the number of cells to 400.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_region_min_size"></a>

<!-- classref-property -->

[float](float.md) **region_min_size** = `2.0` [ðŸ”—](#NavigationMesh_property_region_min_size)

<!-- classref-property-setget -->

- `void` **set_region_min_size**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_region_min_size**\ (\ )

The minimum size of a region for it to be created.

\ **Note:** This value will be squared to calculate the minimum number of cells allowed to form isolated island areas. For example, a value of 8 will set the number of cells to 64.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_sample_partition_type"></a>

<!-- classref-property -->

[SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType) **sample_partition_type** = `0` [ðŸ”—](#NavigationMesh_property_sample_partition_type)

<!-- classref-property-setget -->

- `void` **set_sample_partition_type**\ (\ value\: [SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType)\ )
- [SamplePartitionType](NavigationMesh.md#enum_NavigationMesh_SamplePartitionType) **get_sample_partition_type**\ (\ )

Partitioning algorithm for creating the navigation mesh polys.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_property_vertices_per_polygon"></a>

<!-- classref-property -->

[float](float.md) **vertices_per_polygon** = `6.0` [ðŸ”—](#NavigationMesh_property_vertices_per_polygon)

<!-- classref-property-setget -->

- `void` **set_vertices_per_polygon**\ (\ value\: [float](float.md)\ )
- [float](float.md) **get_vertices_per_polygon**\ (\ )

The maximum number of vertices allowed for polygons generated during the contour to polygon conversion process.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="NavigationMesh_method_add_polygon"></a>

<!-- classref-method -->

`void` **add_polygon**\ (\ polygon\: [PackedInt32Array](PackedInt32Array.md)\ ) [ðŸ”—](#NavigationMesh_method_add_polygon)

Adds a polygon using the indices of the vertices you get when calling [get_vertices()](NavigationMesh.md#NavigationMesh_method_get_vertices).

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_clear"></a>

<!-- classref-method -->

`void` **clear**\ (\ ) [ðŸ”—](#NavigationMesh_method_clear)

Clears the internal arrays for vertices and polygon indices.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_clear_polygons"></a>

<!-- classref-method -->

`void` **clear_polygons**\ (\ ) [ðŸ”—](#NavigationMesh_method_clear_polygons)

Clears the array of polygons, but it doesn't clear the array of vertices.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_create_from_mesh"></a>

<!-- classref-method -->

`void` **create_from_mesh**\ (\ mesh\: [Mesh](Mesh.md)\ ) [ðŸ”—](#NavigationMesh_method_create_from_mesh)

Initializes the navigation mesh by setting the vertices and indices according to a [Mesh](Mesh.md).

\ **Note:** The given `mesh` must be of type [Mesh.PRIMITIVE_TRIANGLES](Mesh.md#Mesh_constant_PRIMITIVE_TRIANGLES) and have an index array.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_get_collision_mask_value"></a>

<!-- classref-method -->

[bool](bool.md) **get_collision_mask_value**\ (\ layer_number\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#NavigationMesh_method_get_collision_mask_value)

Returns whether or not the specified layer of the [geometry_collision_mask](NavigationMesh.md#NavigationMesh_property_geometry_collision_mask) is enabled, given a `layer_number` between 1 and 32.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_get_polygon"></a>

<!-- classref-method -->

[PackedInt32Array](PackedInt32Array.md) **get_polygon**\ (\ idx\: [int](int.md)\ ) [ðŸ”—](#NavigationMesh_method_get_polygon)

Returns a [PackedInt32Array](PackedInt32Array.md) containing the indices of the vertices of a created polygon.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_get_polygon_count"></a>

<!-- classref-method -->

[int](int.md) **get_polygon_count**\ (\ ) <span class="const">const</span> [ðŸ”—](#NavigationMesh_method_get_polygon_count)

Returns the number of polygons in the navigation mesh.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_get_vertices"></a>

<!-- classref-method -->

[PackedVector3Array](PackedVector3Array.md) **get_vertices**\ (\ ) <span class="const">const</span> [ðŸ”—](#NavigationMesh_method_get_vertices)

Returns a [PackedVector3Array](PackedVector3Array.md) containing all the vertices being used to create the polygons.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_set_collision_mask_value"></a>

<!-- classref-method -->

`void` **set_collision_mask_value**\ (\ layer_number\: [int](int.md), value\: [bool](bool.md)\ ) [ðŸ”—](#NavigationMesh_method_set_collision_mask_value)

Based on `value`, enables or disables the specified layer in the [geometry_collision_mask](NavigationMesh.md#NavigationMesh_property_geometry_collision_mask), given a `layer_number` between 1 and 32.

<hr class="classref-item-separator"/>

<a id="NavigationMesh_method_set_vertices"></a>

<!-- classref-method -->

`void` **set_vertices**\ (\ vertices\: [PackedVector3Array](PackedVector3Array.md)\ ) [ðŸ”—](#NavigationMesh_method_set_vertices)

Sets the vertices that can be then indexed to create polygons with the [add_polygon()](NavigationMesh.md#NavigationMesh_method_add_polygon) method.

