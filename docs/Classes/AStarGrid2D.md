<!-- github_url: hide -->

<!-- DO NOT EDIT THIS FILE!!! -->
<!-- Generated automatically from Redot engine sources. -->
<!-- Generator: https://github.com/Redot-Engine/redot-engine/tree/master/doc/tools/make_md.py. -->
<!-- XML source: https://github.com/Redot-Engine/redot-engine/tree/master/doc/classes/AStarGrid2D.xml. -->

<a id="AStarGrid2D"></a>

# AStarGrid2D

**Inherits:** [RefCounted](RefCounted.md) **\<** [Object](Object.md)

An implementation of A\* for finding the shortest path between two points on a partial 2D grid.

<!-- classref-introduction-group -->

## Description

**AStarGrid2D** is a variant of [AStar2D](AStar2D.md) that is specialized for partial 2D grids. It is simpler to use because it doesn't require you to manually create points and connect them together. This class also supports multiple types of heuristics, modes for diagonal movement, and a jumping mode to speed up calculations.

To use **AStarGrid2D**, you only need to set the [region](AStarGrid2D.md#AStarGrid2D_property_region) of the grid, optionally set the [cell_size](AStarGrid2D.md#AStarGrid2D_property_cell_size), and then call the [update()](AStarGrid2D.md#AStarGrid2D_method_update) method:




```gdscript
    var astar_grid = AStarGrid2D.new()
    astar_grid.region = Rect2i(0, 0, 32, 32)
    astar_grid.cell_size = Vector2(16, 16)
    astar_grid.update()
    print(astar_grid.get_id_path(Vector2i(0, 0), Vector2i(3, 4))) # Prints [(0, 0), (1, 1), (2, 2), (3, 3), (3, 4)]
    print(astar_grid.get_point_path(Vector2i(0, 0), Vector2i(3, 4))) # Prints [(0, 0), (16, 16), (32, 32), (48, 48), (48, 64)]
```


```csharp
    AStarGrid2D astarGrid = new AStarGrid2D();
    astarGrid.Region = new Rect2I(0, 0, 32, 32);
    astarGrid.CellSize = new Vector2I(16, 16);
    astarGrid.Update();
    GD.Print(astarGrid.GetIdPath(Vector2I.Zero, new Vector2I(3, 4))); // Prints [(0, 0), (1, 1), (2, 2), (3, 3), (3, 4)]
    GD.Print(astarGrid.GetPointPath(Vector2I.Zero, new Vector2I(3, 4))); // Prints [(0, 0), (16, 16), (32, 32), (48, 48), (48, 64)]
```




To remove a point from the pathfinding grid, it must be set as "solid" with [set_point_solid()](AStarGrid2D.md#AStarGrid2D_method_set_point_solid).

<!-- classref-introduction-group -->

## Tutorials

- [Grid-based Navigation with AStarGrid2D Demo](https://godotengine.org/asset-library/asset/2723)

<!-- classref-reftable-group -->

## Properties

<table>
  <thead>
    <tr>
      <th>[CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape)</th>
      <th>[cell_shape](#AStarGrid2D_property_cell_shape)</th>
      <th>`0`</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[cell_size](#AStarGrid2D_property_cell_size)</td>
      <td>`Vector2(1, 1)`</td>
    </tr>
    <tr>
      <td>[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic)</td>
      <td>[default_compute_heuristic](#AStarGrid2D_property_default_compute_heuristic)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic)</td>
      <td>[default_estimate_heuristic](#AStarGrid2D_property_default_estimate_heuristic)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode)</td>
      <td>[diagonal_mode](#AStarGrid2D_property_diagonal_mode)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[jumping_enabled](#AStarGrid2D_property_jumping_enabled)</td>
      <td>`false`</td>
    </tr>
    <tr>
      <td>[int](int.md)</td>
      <td>[max_traversals](#AStarGrid2D_property_max_traversals)</td>
      <td>`0`</td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[offset](#AStarGrid2D_property_offset)</td>
      <td>`Vector2(0, 0)`</td>
    </tr>
    <tr>
      <td>[Rect2i](Rect2i.md)</td>
      <td>[region](#AStarGrid2D_property_region)</td>
      <td>`Rect2i(0, 0, 0, 0)`</td>
    </tr>
    <tr>
      <td>[Vector2i](Vector2i.md)</td>
      <td>[size](#AStarGrid2D_property_size)</td>
      <td>`Vector2i(0, 0)`</td>
    </tr>
  </tbody>
</table>

<!-- classref-reftable-group -->

## Methods

<table>
  <thead>
    <tr>
      <th>[float](float.md)</th>
      <th>[_compute_cost](#AStarGrid2D_private_method__compute_cost)\ (\ from_id\: [Vector2i](Vector2i.md), to_id\: [Vector2i](Vector2i.md)\ ) <span class="virtual">virtual</span> <span class="const">const</span></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[float](float.md)</td>
      <td>[_estimate_cost](#AStarGrid2D_private_method__estimate_cost)\ (\ from_id\: [Vector2i](Vector2i.md), end_id\: [Vector2i](Vector2i.md)\ ) <span class="virtual">virtual</span> <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[clear](#AStarGrid2D_method_clear)\ (\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[fill_solid_region](#AStarGrid2D_method_fill_solid_region)\ (\ region\: [Rect2i](Rect2i.md), solid\: [bool](bool.md) = true\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[fill_weight_scale_region](#AStarGrid2D_method_fill_weight_scale_region)\ (\ region\: [Rect2i](Rect2i.md), weight_scale\: [float](float.md)\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)\[[Vector2i](Vector2i.md)\]</td>
      <td>[get_id_path](#AStarGrid2D_method_get_id_path)\ (\ from_id\: [Vector2i](Vector2i.md), to_id\: [Vector2i](Vector2i.md), allow_partial_path\: [bool](bool.md) = false\ )</td>
    </tr>
    <tr>
      <td>[Array](Array.md)\[[Dictionary](Dictionary.md)\]</td>
      <td>[get_point_data_in_region](#AStarGrid2D_method_get_point_data_in_region)\ (\ region\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[PackedVector2Array](PackedVector2Array.md)</td>
      <td>[get_point_path](#AStarGrid2D_method_get_point_path)\ (\ from_id\: [Vector2i](Vector2i.md), to_id\: [Vector2i](Vector2i.md), allow_partial_path\: [bool](bool.md) = false\ )</td>
    </tr>
    <tr>
      <td>[Vector2](Vector2.md)</td>
      <td>[get_point_position](#AStarGrid2D_method_get_point_position)\ (\ id\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[float](float.md)</td>
      <td>[get_point_weight_scale](#AStarGrid2D_method_get_point_weight_scale)\ (\ id\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_dirty](#AStarGrid2D_method_is_dirty)\ (\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_in_bounds](#AStarGrid2D_method_is_in_bounds)\ (\ x\: [int](int.md), y\: [int](int.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_in_boundsv](#AStarGrid2D_method_is_in_boundsv)\ (\ id\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>[bool](bool.md)</td>
      <td>[is_point_solid](#AStarGrid2D_method_is_point_solid)\ (\ id\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span></td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_point_solid](#AStarGrid2D_method_set_point_solid)\ (\ id\: [Vector2i](Vector2i.md), solid\: [bool](bool.md) = true\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[set_point_weight_scale](#AStarGrid2D_method_set_point_weight_scale)\ (\ id\: [Vector2i](Vector2i.md), weight_scale\: [float](float.md)\ )</td>
    </tr>
    <tr>
      <td>`void`</td>
      <td>[update](#AStarGrid2D_method_update)\ (\ )</td>
    </tr>
  </tbody>
</table>

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Enumerations

<a id="enum_AStarGrid2D_Heuristic"></a>

<!-- classref-enumeration -->

enum **Heuristic**: [ðŸ”—](#enum_AStarGrid2D_Heuristic)

<a id="AStarGrid2D_constant_HEURISTIC_EUCLIDEAN"></a>

<!-- classref-enumeration-constant -->

[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **HEURISTIC_EUCLIDEAN** = `0`

The [Euclidean heuristic](https://en.wikipedia.org/wiki/Euclidean_distance) to be used for the pathfinding using the following formula:

```
    dx = abs(to_id.x - from_id.x)
    dy = abs(to_id.y - from_id.y)
    result = sqrt(dx * dx + dy * dy)
```


\ **Note:** This is also the internal heuristic used in [AStar3D](AStar3D.md) and [AStar2D](AStar2D.md) by default (with the inclusion of possible z-axis coordinate).<a id="AStarGrid2D_constant_HEURISTIC_MANHATTAN"></a>

<!-- classref-enumeration-constant -->

[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **HEURISTIC_MANHATTAN** = `1`

The [Manhattan heuristic](https://en.wikipedia.org/wiki/Taxicab_geometry) to be used for the pathfinding using the following formula:

```
    dx = abs(to_id.x - from_id.x)
    dy = abs(to_id.y - from_id.y)
    result = dx + dy
```


\ **Note:** This heuristic is intended to be used with 4-side orthogonal movements, provided by setting the [diagonal_mode](AStarGrid2D.md#AStarGrid2D_property_diagonal_mode) to [DIAGONAL_MODE_NEVER](AStarGrid2D.md#AStarGrid2D_constant_DIAGONAL_MODE_NEVER).<a id="AStarGrid2D_constant_HEURISTIC_OCTILE"></a>

<!-- classref-enumeration-constant -->

[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **HEURISTIC_OCTILE** = `2`

The Octile heuristic to be used for the pathfinding using the following formula:

```
    dx = abs(to_id.x - from_id.x)
    dy = abs(to_id.y - from_id.y)
    f = sqrt(2) - 1
    result = (dx < dy) ? f * dx + dy : f * dy + dx;
```
<a id="AStarGrid2D_constant_HEURISTIC_CHEBYSHEV"></a>

<!-- classref-enumeration-constant -->

[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **HEURISTIC_CHEBYSHEV** = `3`

The [Chebyshev heuristic](https://en.wikipedia.org/wiki/Chebyshev_distance) to be used for the pathfinding using the following formula:

```
    dx = abs(to_id.x - from_id.x)
    dy = abs(to_id.y - from_id.y)
    result = max(dx, dy)
```
<a id="AStarGrid2D_constant_HEURISTIC_MAX"></a>

<!-- classref-enumeration-constant -->

[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **HEURISTIC_MAX** = `4`

Represents the size of the [Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) enum.<hr class="classref-item-separator"/>

<a id="enum_AStarGrid2D_DiagonalMode"></a>

<!-- classref-enumeration -->

enum **DiagonalMode**: [ðŸ”—](#enum_AStarGrid2D_DiagonalMode)

<a id="AStarGrid2D_constant_DIAGONAL_MODE_ALWAYS"></a>

<!-- classref-enumeration-constant -->

[DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) **DIAGONAL_MODE_ALWAYS** = `0`

The pathfinding algorithm will ignore solid neighbors around the target cell and allow passing using diagonals.<a id="AStarGrid2D_constant_DIAGONAL_MODE_NEVER"></a>

<!-- classref-enumeration-constant -->

[DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) **DIAGONAL_MODE_NEVER** = `1`

The pathfinding algorithm will ignore all diagonals and the way will be always orthogonal.<a id="AStarGrid2D_constant_DIAGONAL_MODE_AT_LEAST_ONE_WALKABLE"></a>

<!-- classref-enumeration-constant -->

[DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) **DIAGONAL_MODE_AT_LEAST_ONE_WALKABLE** = `2`

The pathfinding algorithm will avoid using diagonals if at least two obstacles have been placed around the neighboring cells of the specific path segment.<a id="AStarGrid2D_constant_DIAGONAL_MODE_ONLY_IF_NO_OBSTACLES"></a>

<!-- classref-enumeration-constant -->

[DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) **DIAGONAL_MODE_ONLY_IF_NO_OBSTACLES** = `3`

The pathfinding algorithm will avoid using diagonals if any obstacle has been placed around the neighboring cells of the specific path segment.<a id="AStarGrid2D_constant_DIAGONAL_MODE_MAX"></a>

<!-- classref-enumeration-constant -->

[DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) **DIAGONAL_MODE_MAX** = `4`

Represents the size of the [DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) enum.<hr class="classref-item-separator"/>

<a id="enum_AStarGrid2D_CellShape"></a>

<!-- classref-enumeration -->

enum **CellShape**: [ðŸ”—](#enum_AStarGrid2D_CellShape)

<a id="AStarGrid2D_constant_CELL_SHAPE_SQUARE"></a>

<!-- classref-enumeration-constant -->

[CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape) **CELL_SHAPE_SQUARE** = `0`

Rectangular cell shape.<a id="AStarGrid2D_constant_CELL_SHAPE_ISOMETRIC_RIGHT"></a>

<!-- classref-enumeration-constant -->

[CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape) **CELL_SHAPE_ISOMETRIC_RIGHT** = `1`

Diamond cell shape (for isometric look). Cell coordinates layout where the horizontal axis goes up-right, and the vertical one goes down-right.<a id="AStarGrid2D_constant_CELL_SHAPE_ISOMETRIC_DOWN"></a>

<!-- classref-enumeration-constant -->

[CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape) **CELL_SHAPE_ISOMETRIC_DOWN** = `2`

Diamond cell shape (for isometric look). Cell coordinates layout where the horizontal axis goes down-right, and the vertical one goes down-left.<a id="AStarGrid2D_constant_CELL_SHAPE_MAX"></a>

<!-- classref-enumeration-constant -->

[CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape) **CELL_SHAPE_MAX** = `3`

Represents the size of the [CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape) enum.<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Property Descriptions

<a id="AStarGrid2D_property_cell_shape"></a>

<!-- classref-property -->

[CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape) **cell_shape** = `0` [ðŸ”—](#AStarGrid2D_property_cell_shape)

<!-- classref-property-setget -->

- `void` **set_cell_shape**\ (\ value\: [CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape)\ )
- [CellShape](AStarGrid2D.md#enum_AStarGrid2D_CellShape) **get_cell_shape**\ (\ )

The cell shape. Affects how the positions are placed in the grid. If changed, [update()](AStarGrid2D.md#AStarGrid2D_method_update) needs to be called before finding the next path.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_cell_size"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **cell_size** = `Vector2(1, 1)` [ðŸ”—](#AStarGrid2D_property_cell_size)

<!-- classref-property-setget -->

- `void` **set_cell_size**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_cell_size**\ (\ )

The size of the point cell which will be applied to calculate the resulting point position returned by [get_point_path()](AStarGrid2D.md#AStarGrid2D_method_get_point_path). If changed, [update()](AStarGrid2D.md#AStarGrid2D_method_update) needs to be called before finding the next path.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_default_compute_heuristic"></a>

<!-- classref-property -->

[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **default_compute_heuristic** = `0` [ðŸ”—](#AStarGrid2D_property_default_compute_heuristic)

<!-- classref-property-setget -->

- `void` **set_default_compute_heuristic**\ (\ value\: [Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic)\ )
- [Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **get_default_compute_heuristic**\ (\ )

The default [Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) which will be used to calculate the cost between two points if [_compute_cost()](AStarGrid2D.md#AStarGrid2D_private_method__compute_cost) was not overridden.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_default_estimate_heuristic"></a>

<!-- classref-property -->

[Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **default_estimate_heuristic** = `0` [ðŸ”—](#AStarGrid2D_property_default_estimate_heuristic)

<!-- classref-property-setget -->

- `void` **set_default_estimate_heuristic**\ (\ value\: [Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic)\ )
- [Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) **get_default_estimate_heuristic**\ (\ )

The default [Heuristic](AStarGrid2D.md#enum_AStarGrid2D_Heuristic) which will be used to calculate the cost between the point and the end point if [_estimate_cost()](AStarGrid2D.md#AStarGrid2D_private_method__estimate_cost) was not overridden.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_diagonal_mode"></a>

<!-- classref-property -->

[DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) **diagonal_mode** = `0` [ðŸ”—](#AStarGrid2D_property_diagonal_mode)

<!-- classref-property-setget -->

- `void` **set_diagonal_mode**\ (\ value\: [DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode)\ )
- [DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) **get_diagonal_mode**\ (\ )

A specific [DiagonalMode](AStarGrid2D.md#enum_AStarGrid2D_DiagonalMode) mode which will force the path to avoid or accept the specified diagonals.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_jumping_enabled"></a>

<!-- classref-property -->

[bool](bool.md) **jumping_enabled** = `false` [ðŸ”—](#AStarGrid2D_property_jumping_enabled)

<!-- classref-property-setget -->

- `void` **set_jumping_enabled**\ (\ value\: [bool](bool.md)\ )
- [bool](bool.md) **is_jumping_enabled**\ (\ )

Enables or disables jumping to skip up the intermediate points and speeds up the searching algorithm.

\ **Note:** Currently, toggling it on disables the consideration of weight scaling in pathfinding.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_max_traversals"></a>

<!-- classref-property -->

[int](int.md) **max_traversals** = `0` [ðŸ”—](#AStarGrid2D_property_max_traversals)

<!-- classref-property-setget -->

- `void` **set_max_traversals**\ (\ value\: [int](int.md)\ )
- [int](int.md) **get_max_traversals**\ (\ )

The maximum number of points to traverse before giving up. If set to ``0``, the search will continue until the end point is reached or the whole grid is traversed.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_offset"></a>

<!-- classref-property -->

[Vector2](Vector2.md) **offset** = `Vector2(0, 0)` [ðŸ”—](#AStarGrid2D_property_offset)

<!-- classref-property-setget -->

- `void` **set_offset**\ (\ value\: [Vector2](Vector2.md)\ )
- [Vector2](Vector2.md) **get_offset**\ (\ )

The offset of the grid which will be applied to calculate the resulting point position returned by [get_point_path()](AStarGrid2D.md#AStarGrid2D_method_get_point_path). If changed, [update()](AStarGrid2D.md#AStarGrid2D_method_update) needs to be called before finding the next path.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_region"></a>

<!-- classref-property -->

[Rect2i](Rect2i.md) **region** = `Rect2i(0, 0, 0, 0)` [ðŸ”—](#AStarGrid2D_property_region)

<!-- classref-property-setget -->

- `void` **set_region**\ (\ value\: [Rect2i](Rect2i.md)\ )
- [Rect2i](Rect2i.md) **get_region**\ (\ )

The region of grid cells available for pathfinding. If changed, [update()](AStarGrid2D.md#AStarGrid2D_method_update) needs to be called before finding the next path.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_property_size"></a>

<!-- classref-property -->

[Vector2i](Vector2i.md) **size** = `Vector2i(0, 0)` [ðŸ”—](#AStarGrid2D_property_size)

<!-- classref-property-setget -->

- `void` **set_size**\ (\ value\: [Vector2i](Vector2i.md)\ )
- [Vector2i](Vector2i.md) **get_size**\ (\ )

**Deprecated:** Use [region](AStarGrid2D.md#AStarGrid2D_property_region) instead.

The size of the grid (number of cells of size [cell_size](AStarGrid2D.md#AStarGrid2D_property_cell_size) on each axis). If changed, [update()](AStarGrid2D.md#AStarGrid2D_method_update) needs to be called before finding the next path.

<hr class="classref-section-separator"/>

<!-- classref-descriptions-group -->

## Method Descriptions

<a id="AStarGrid2D_private_method__compute_cost"></a>

<!-- classref-method -->

[float](float.md) **_compute_cost**\ (\ from_id\: [Vector2i](Vector2i.md), to_id\: [Vector2i](Vector2i.md)\ ) <span class="virtual">virtual</span> <span class="const">const</span> [ðŸ”—](#AStarGrid2D_private_method__compute_cost)

Called when computing the cost between two connected points.

Note that this function is hidden in the default **AStarGrid2D** class.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_private_method__estimate_cost"></a>

<!-- classref-method -->

[float](float.md) **_estimate_cost**\ (\ from_id\: [Vector2i](Vector2i.md), end_id\: [Vector2i](Vector2i.md)\ ) <span class="virtual">virtual</span> <span class="const">const</span> [ðŸ”—](#AStarGrid2D_private_method__estimate_cost)

Called when estimating the cost between a point and the path's ending point.

Note that this function is hidden in the default **AStarGrid2D** class.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_clear"></a>

<!-- classref-method -->

`void` **clear**\ (\ ) [ðŸ”—](#AStarGrid2D_method_clear)

Clears the grid and sets the [region](AStarGrid2D.md#AStarGrid2D_property_region) to ``Rect2i(0, 0, 0, 0)``.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_fill_solid_region"></a>

<!-- classref-method -->

`void` **fill_solid_region**\ (\ region\: [Rect2i](Rect2i.md), solid\: [bool](bool.md) = true\ ) [ðŸ”—](#AStarGrid2D_method_fill_solid_region)

Fills the given `region` on the grid with the specified value for the solid flag.

\ **Note:** Calling [update()](AStarGrid2D.md#AStarGrid2D_method_update) is not needed after the call of this function.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_fill_weight_scale_region"></a>

<!-- classref-method -->

`void` **fill_weight_scale_region**\ (\ region\: [Rect2i](Rect2i.md), weight_scale\: [float](float.md)\ ) [ðŸ”—](#AStarGrid2D_method_fill_weight_scale_region)

Fills the given `region` on the grid with the specified value for the weight scale.

\ **Note:** Calling [update()](AStarGrid2D.md#AStarGrid2D_method_update) is not needed after the call of this function.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_get_id_path"></a>

<!-- classref-method -->

[Array](Array.md)\[[Vector2i](Vector2i.md)\] **get_id_path**\ (\ from_id\: [Vector2i](Vector2i.md), to_id\: [Vector2i](Vector2i.md), allow_partial_path\: [bool](bool.md) = false\ ) [ðŸ”—](#AStarGrid2D_method_get_id_path)

Returns an array with the IDs of the points that form the path found by AStar2D between the given points. The array is ordered from the starting point to the ending point of the path.

If there is no valid path to the target, and `allow_partial_path` is ``true``, returns a path to the point closest to the target that can be reached.

\ **Note:** When `allow_partial_path` is ``true`` and `to_id` is solid the search may take an unusually long time to finish.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_get_point_data_in_region"></a>

<!-- classref-method -->

[Array](Array.md)\[[Dictionary](Dictionary.md)\] **get_point_data_in_region**\ (\ region\: [Rect2i](Rect2i.md)\ ) <span class="const">const</span> [ðŸ”—](#AStarGrid2D_method_get_point_data_in_region)

Returns an array of dictionaries with point data (``id``: [Vector2i](Vector2i.md), ``position``: [Vector2](Vector2.md), ``solid``: [bool](bool.md), ``weight_scale``: [float](float.md)) within a `region`.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_get_point_path"></a>

<!-- classref-method -->

[PackedVector2Array](PackedVector2Array.md) **get_point_path**\ (\ from_id\: [Vector2i](Vector2i.md), to_id\: [Vector2i](Vector2i.md), allow_partial_path\: [bool](bool.md) = false\ ) [ðŸ”—](#AStarGrid2D_method_get_point_path)

Returns an array with the points that are in the path found by **AStarGrid2D** between the given points. The array is ordered from the starting point to the ending point of the path.

If there is no valid path to the target, and `allow_partial_path` is ``true``, returns a path to the point closest to the target that can be reached.

\ **Note:** This method is not thread-safe; it can only be used from a single [Thread](Thread.md) at a given time. Consider using [Mutex](Mutex.md) to ensure exclusive access to one thread to avoid race conditions.

Additionally, when `allow_partial_path` is ``true`` and `to_id` is solid the search may take an unusually long time to finish.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_get_point_position"></a>

<!-- classref-method -->

[Vector2](Vector2.md) **get_point_position**\ (\ id\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span> [ðŸ”—](#AStarGrid2D_method_get_point_position)

Returns the position of the point associated with the given `id`.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_get_point_weight_scale"></a>

<!-- classref-method -->

[float](float.md) **get_point_weight_scale**\ (\ id\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span> [ðŸ”—](#AStarGrid2D_method_get_point_weight_scale)

Returns the weight scale of the point associated with the given `id`.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_is_dirty"></a>

<!-- classref-method -->

[bool](bool.md) **is_dirty**\ (\ ) <span class="const">const</span> [ðŸ”—](#AStarGrid2D_method_is_dirty)

Indicates that the grid parameters were changed and [update()](AStarGrid2D.md#AStarGrid2D_method_update) needs to be called.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_is_in_bounds"></a>

<!-- classref-method -->

[bool](bool.md) **is_in_bounds**\ (\ x\: [int](int.md), y\: [int](int.md)\ ) <span class="const">const</span> [ðŸ”—](#AStarGrid2D_method_is_in_bounds)

Returns ``true`` if the `x` and `y` is a valid grid coordinate (id), i.e. if it is inside [region](AStarGrid2D.md#AStarGrid2D_property_region). Equivalent to ``region.has_point(Vector2i(x, y))``.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_is_in_boundsv"></a>

<!-- classref-method -->

[bool](bool.md) **is_in_boundsv**\ (\ id\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span> [ðŸ”—](#AStarGrid2D_method_is_in_boundsv)

Returns ``true`` if the `id` vector is a valid grid coordinate, i.e. if it is inside [region](AStarGrid2D.md#AStarGrid2D_property_region). Equivalent to ``region.has_point(id)``.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_is_point_solid"></a>

<!-- classref-method -->

[bool](bool.md) **is_point_solid**\ (\ id\: [Vector2i](Vector2i.md)\ ) <span class="const">const</span> [ðŸ”—](#AStarGrid2D_method_is_point_solid)

Returns ``true`` if a point is disabled for pathfinding. By default, all points are enabled.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_set_point_solid"></a>

<!-- classref-method -->

`void` **set_point_solid**\ (\ id\: [Vector2i](Vector2i.md), solid\: [bool](bool.md) = true\ ) [ðŸ”—](#AStarGrid2D_method_set_point_solid)

Disables or enables the specified point for pathfinding. Useful for making an obstacle. By default, all points are enabled.

\ **Note:** Calling [update()](AStarGrid2D.md#AStarGrid2D_method_update) is not needed after the call of this function.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_set_point_weight_scale"></a>

<!-- classref-method -->

`void` **set_point_weight_scale**\ (\ id\: [Vector2i](Vector2i.md), weight_scale\: [float](float.md)\ ) [ðŸ”—](#AStarGrid2D_method_set_point_weight_scale)

Sets the `weight_scale` for the point with the given `id`. The `weight_scale` is multiplied by the result of [_compute_cost()](AStarGrid2D.md#AStarGrid2D_private_method__compute_cost) when determining the overall cost of traveling across a segment from a neighboring point to this point.

\ **Note:** Calling [update()](AStarGrid2D.md#AStarGrid2D_method_update) is not needed after the call of this function.

<hr class="classref-item-separator"/>

<a id="AStarGrid2D_method_update"></a>

<!-- classref-method -->

`void` **update**\ (\ ) [ðŸ”—](#AStarGrid2D_method_update)

Updates the internal state of the grid according to the parameters to prepare it to search the path. Needs to be called if parameters like [region](AStarGrid2D.md#AStarGrid2D_property_region), [cell_size](AStarGrid2D.md#AStarGrid2D_property_cell_size) or [offset](AStarGrid2D.md#AStarGrid2D_property_offset) are changed. [is_dirty()](AStarGrid2D.md#AStarGrid2D_method_is_dirty) will return ``true`` if this is the case and this needs to be called.

\ **Note:** All point data (solidity and weight scale) will be cleared.

